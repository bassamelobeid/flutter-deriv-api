#!/usr/bin/perl
package main;

use strict;
use warnings;

use BOM::Platform::Sysinit ();
use f_brokerincludeall;
use BOM::Database::AutoGenerated::Rose::Audit::Client::Manager;
use BOM::Database::AutoGenerated::Rose::Audit::ClientStatus::Manager;
use BOM::Database::AutoGenerated::Rose::Audit::ClientPromoCode::Manager;
use BOM::Database::AutoGenerated::Rose::Audit::ClientAuthenticationMethod::Manager;
use BOM::Database::AutoGenerated::Rose::Audit::ClientAuthenticationDocument::Manager;
use BOM::Database::AutoGenerated::Rose::Audit::PaymentAgent::Manager;
use BOM::Platform::Plack qw( PrintContentType );

BOM::Platform::Sysinit::init();

PrintContentType();
BrokerPresentation("SHOW AUDIT TRAIL");
BOM::Platform::Auth0::can_access(['CS']);

my $broker = request()->broker->code;

if ($broker eq 'FOG') {
    print "NOT RELEVANT FOR BROKER CODE FOG";
    code_exit_BO();
}

my $db = BOM::Database::ClientDB->new({
        broker_code => $broker,
    })->db;

my $category    = request()->param('category');
my $loginid     = request()->param('loginid');
my $page        = request()->param('page') || 0;
my $pagesize    = request()->param('pagesize') || 40;
my $offset      = $page * $pagesize;
my @system_cols = qw/stamp staff_name operation client_addr/;
my @noshow_cols = qw/pg_userid client_port id/;

my $myself_args = {
    broker   => $broker,
    category => $category
};
my $return_args = {broker => $broker};
my ($title_bar, $return_cgi);
my $page_1 = $page + 1;
if ($loginid) {
    $title_bar              = "Audit Trail ($category) on Client ($loginid) - Page ($page_1)";
    $myself_args->{loginid} = $loginid;
    $return_args->{loginID} = $loginid;
    $return_cgi             = 'f_clientloginid_edit.cgi';
} else {
    $title_bar  = "Audit Trail ($category) on Broker ($broker) - Page ($page_1)";
    $return_cgi = 'f_clientloginid.cgi';
}

my @tables;
for ($category) {
    if (/^client_status_(\w+)/) {
        my $status_code = $1;
        if (BOM::Platform::Client->client_status_types->{$status_code}) {
            @tables = ({
                    tabname => 'client_status',
                    MGR     => 'BOM::Database::AutoGenerated::Rose::Audit::ClientStatus::Manager',
                    query   => [
                        status_code    => $status_code,
                        client_loginid => {like => "$broker%"}
                    ],
                });
        }
    } elsif (/^client_details$/) {
        @tables = ({
                tabname => 'client',
                MGR     => 'BOM::Database::AutoGenerated::Rose::Audit::Client::Manager',
                query   => [loginid => $loginid],
            },
            {
                tabname => 'client_promo_code',
                query   => [client_loginid => $loginid],
                MGR     => 'BOM::Database::AutoGenerated::Rose::Audit::ClientPromoCode::Manager',
            },
            {
                tabname => 'client_authentication_method',
                query   => [client_loginid => $loginid],
                MGR     => 'BOM::Database::AutoGenerated::Rose::Audit::ClientAuthenticationMethod::Manager',
            },
            {
                tabname => 'client_authentication_document',
                query   => [client_loginid => $loginid],
                MGR     => 'BOM::Database::AutoGenerated::Rose::Audit::ClientAuthenticationDocument::Manager',
            },
            {
                tabname => 'client_status',
                query   => [client_loginid => $loginid],
                MGR     => 'BOM::Database::AutoGenerated::Rose::Audit::ClientStatus::Manager',
            },
        );
    } elsif (/^payment_agent$/) {
        @tables = ({
                tabname => 'payment_agent',
                query   => [client_loginid => $loginid],
                MGR     => 'BOM::Database::AutoGenerated::Rose::Audit::PaymentAgent::Manager',
            },
        );
    }
}
unless (@tables) {
    print "Unsupported audit-trail category [$category]";
    code_exit_BO();
}

my (@logs, %hdrs, $hitcount);

for my $table (@tables) {
    my $tabname   = $table->{tabname};
    my $query     = $table->{query};
    my $MGR       = $table->{MGR};
    my $hits_call = "get_${tabname}_count";
    my $rows_call = "get_${tabname}";
    $hitcount = $MGR->$hits_call(
        query => $query,
        db    => $db
    ) || next;
    my $rows = $MGR->$rows_call(
        query   => $query,
        db      => $db,
        sort_by => 'stamp',
        (
            $loginid
            ? ()
            : (
                limit  => $pagesize,
                offset => $offset
            )
        ),
    );
    my $firstrow = $rows->[0] || next;
    # accumulate new non-system column names into %hdrs
    my %cols = map { $_->name => 1 } $rows->[0]->meta->columns;
    delete $cols{$_} for (@system_cols, @noshow_cols);
    $hdrs{$_} = 1 for keys %cols;
    # now pre-process 'rows' to build 'log' entry (and flag changed cells, for individual users only)
    my $prevrow;
    for my $row (@$rows) {
        my $changes = {};
        my $data = {table => $tabname};
        for my $col (@system_cols) {
            $data->{$col} = $row->$col if $row->can($col);
        }
        for my $col (keys %cols) {
            $data->{$col} = $row->$col;
            if ($loginid && $prevrow) {
                $changes->{$col} = 1
                    if ($row->$col || '') ne ($prevrow->$col || '');
            }
        }
        $prevrow = $row;
        push @logs,
            {
            data    => $data,
            changes => $changes
            };
    }
}

my ($rowcount, $pages);
if ($loginid) {    # don't page for single login report
    $rowcount = scalar(@logs);
    $pages    = 1;
} else {
    $rowcount = $hitcount || 0;
    $pages = int($rowcount / $pagesize);
    $pages += 1 if $rowcount % $pagesize;
}

my @allhdrs;

if (@logs) {
    @allhdrs = (@system_cols, 'table', sort keys %hdrs);
} else {
    @allhdrs = ('no data found');
}

my $logs = [sort { $a->{data}->{stamp} cmp $b->{data}->{stamp} } @logs];
my $stash = {
    hdrs     => \@allhdrs,
    logs     => $logs,
    rowcount => $rowcount,
    pagesize => $pagesize,
    pages    => $pages,
    next     => $page < $pages ? $page + 1 : $page,
    prev     => $page > 0 ? $page - 1 : $page,
    pagesize => $pagesize,
    url_to_myself => request()->url_for("backoffice/show_audit_trail.cgi", $myself_args),
    url_to_client => request()->url_for("backoffice/$return_cgi",          $return_args),
};

Bar($title_bar);

BOM::Platform::Context::template->process('backoffice/show_audit_trail.html.tt', $stash) || die BOM::Platform::Context::template->error();

code_exit_BO();
