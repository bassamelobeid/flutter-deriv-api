package BOM::Database::Model::HandoffToken;

use Moose;
use Digest;
use BOM::Database::AutoGenerated::Rose::HandoffToken;
extends 'BOM::Database::Model::Base';

has 'handoff_token_record' => (
    is  => 'rw',
    isa => 'BOM::Database::AutoGenerated::Rose::HandoffToken',
);

sub BUILD {
    my $self = shift;
    my $args = shift;

    $self->handoff_token_record(
        $self->_initialize_data_access_object(
            'BOM::Database::AutoGenerated::Rose::HandoffToken',
            $self->_extract_related_attributes_for_class_hashref()));
    return;
}

sub _extract_related_attributes_for_class_hashref {
    my $self = shift;

    my $result = $self->_extract_related_attributes_for_class_based_on_table_definition_hashref('BOM::Database::AutoGenerated::Rose::HandoffToken');
    return $result;
}

=head1 METHODS

=head2 save

=cut

sub save {
    my $self = shift;
    my $args = shift;

    $self->_save_orm_object({'record' => $self->handoff_token_record});

    return;
}

=head2 delete

=cut

# We need to ignore (ProhibitBuiltinHomonyms) for this specific method which
# basically overrides delete method of Rose::DB::Object and we can't help to
# just ignore perl critic for this line
sub delete    ## no critic (ProhibitBuiltinHomonyms)
{
    my $self = shift;
    my $args = shift;

    $self->_delete_orm_object({'record' => $self->handoff_token_record});

    return;
}

=head2 load

=cut

sub load {
    my $self = shift;
    my $args = shift;

    return $self->_load_orm_object({
            'record'      => $self->handoff_token_record,
            'load_params' => $args->{'load_params'}});

}

=head2 exists

    my $handoff_token = BOM::Database::Model::HandoffToken->new({
        data_object_params => { key => $handoff_token_key },
        db => $connection_builder->db,
    });
    if ($handoff_token->exists)
        # do whatever

Allows you to check if the object exists. Unfortunately it does a load.

Might replace this by adding a HandoffToken::Manager class...

=cut

sub exists    ## no critic (ProhibitBuiltinHomonyms)
{
    my $self = shift;
    my $args = shift;
    if ($self->load({load_params => {speculative => 1}})) {
        return 1;
    }
    return;
}

sub class_orm_record {
    my $self = shift;

    return $self->handoff_token_record;
}

=head1 ACCESSORS

=head2 is_valid

=cut

sub is_valid {
    my $self = shift;
    if ($self->expires->epoch > time) {
        return 1;
    }
    return;
}

=head2 id

=cut

sub id {
    my $self = shift;
    return $self->handoff_token_record->id;
}

=head2 client_loginid

=cut

sub client_loginid {
    my $self = shift;
    return $self->handoff_token_record->client_loginid;
}

=head2 key

=cut

sub key {
    my $self = shift;
    return $self->handoff_token_record->key;
}

=head2 expires

=cut

sub expires {
    my $self = shift;
    return $self->handoff_token_record->expires;
}

#
# Not all that random hash seed =(
#
sub _session_hash_seed {
    return join("", time, rand, $$, {}, 'it is by will alone',);
}

=head2 generate_session_key

Generates a session id key

based loosely on Catalyst::Plugin::Session _generate_sessionid

=cut

sub generate_session_key {
    my $digest = Digest->new('SHA-1');
    $digest->add(_session_hash_seed());
    return $digest->hexdigest;
}

no Moose;
__PACKAGE__->meta->make_immutable;

1;
