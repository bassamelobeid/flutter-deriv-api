package BOM::RiskReporting::Dashboard;

=head1 NAME

BOM::RiskReporting::Dashboard

=head1 DESCRIPTION

Generates the report shown on our Risk Dashboard b/o page.

=cut

use strict;
use warnings;

use IO::File;
use List::Util qw(max first sum reduce);
use JSON::MaybeXS;
use Moose;
use Try::Tiny;
use Math::BigFloat;
use Cache::RedisDB;
use Date::Utility;
use Format::Util::Numbers qw(roundcommon financialrounding);
use Time::Duration::Concise::Localize;
extends 'BOM::RiskReporting::Base';
use BOM::Product::ContractFactory qw( produce_contract );
use BOM::Database::Model::Account;
use BOM::Database::ClientDB;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::FinancialMarketBet;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::DataMapper::CollectorReporting;
use BOM::Database::AutoGenerated::Rose::MyaffiliatesTokenDetail;
use BOM::Platform::Runtime;
use BOM::Backoffice::Request;
use List::MoreUtils qw(uniq);
use BOM::Product::ContractFactory qw( produce_contract );
use BOM::Product::Contract::PredefinedParameters;
use Postgres::FeedDB::CurrencyConverter qw(in_USD);
use BOM::MarketData qw(create_underlying);
my $json = JSON::MaybeXS->new;

=head1 ATTRIBUTES

=head2 start

The start date of the period over which the instance reports.

=head2 end

The end date of the period over which the instance reports.

=cut

has [qw( start )] => (
    is         => 'ro',
    isa        => 'Date::Utility',
    lazy_build => 1,
);

sub _build_start {
    return shift->end->minus_time_interval('1d');
}

has custom_client_profiles => (
    is         => 'ro',
    isa        => 'HashRef',
    lazy_build => 1,
);

sub _build_custom_client_profiles {
    return $json->decode(BOM::Platform::Runtime->instance->app_config->quants->custom_client_profiles);
}

has _affiliate_info => (
    is      => 'ro',
    isa     => 'HashRef',
    default => sub { return {}; },
);

sub _do_name_plus {
    my ($self, $href) = @_;

    if ($href->{affiliation} and $href->{affiliate_username}) {
        $self->_affiliate_info->{$href->{affiliation}} = {
            id       => $href->{affiliation},
            username => $href->{affiliate_username},
            email    => $href->{affiliate_email},
        };
    }

    my $app_config = $self->custom_client_profiles;
    my $reason = $app_config->{$href->{loginid}}->{reason} // '';
    $href->{being_watched_for} = $reason;
    return $href;
}

sub _report_mapper {
    return BOM::Database::DataMapper::CollectorReporting->new({db => shift->_db});
}

has _report => (
    is         => 'ro',
    lazy_build => 1,
);

sub _build__report {
    my $self = shift;

    my $report = {
        start_date => $self->start->datetime_yyyymmdd_hhmmss,
        end_date   => $self->end->datetime_yyyymmdd_hhmmss,
    };
    my $ttl = Cache::RedisDB->ttl('RISK_DASHBOARD', 'report');
    my $pap_report = $self->_payment_and_profit_report;
    $report->{big_deposits}    = $pap_report->{big_deposits};
    $report->{big_withdrawals} = $pap_report->{big_withdrawals};
    $report->{big_winners}     = $pap_report->{big_winners};
    $report->{big_losers}      = $pap_report->{big_losers};
    $report->{watched}         = $pap_report->{watched};
    $report->{top_turnover}    = $self->_top_turnover;
    $report->{generated_time}  = Date::Utility->new->plus_time_interval(($ttl - 1800) . 's')->datetime;

    return $report;
}

sub _open_bets_at_end {
    my $self = shift;

    my $open_bets = $self->_report_mapper->get_open_bet_overviews($self->end);

    foreach my $bet (@{$open_bets}) {
        $self->_do_name_plus($bet);
    }

    return $open_bets;
}

sub _top_turnover {
    my $self = shift;

    my $tops = $self->_report_mapper->turnover_in_period({
        start_date => $self->start->db_timestamp,
        end_date   => $self->end->db_timestamp
    });
    my @sorted_top =
        sort { $b->{turnover} <=> $a->{turnover} }
        map { $self->_do_name_plus($tops->{$_}) } (keys %$tops);
    foreach my $entry (@sorted_top) {
        $self->_affiliate_info->{$entry->{affiliation}}->{turnover} += $entry->{turnover}
            if ($entry->{affiliation} and defined $entry->{turnover});
    }
    my @sorted_affils =
        sort { $b->{turnover} <=> $a->{turnover} }
        grep { defined $_->{turnover} }
        map  { $self->_affiliate_info->{$_} } keys %{$self->_affiliate_info};
    return +{
        clients => [(scalar @sorted_top <= 10) ? @sorted_top : @sorted_top[0 .. 9]],
        affiliates => [
            (scalar @sorted_affils <= 10)
            ? @sorted_affils
            : @sorted_affils[0 .. 9]]};
}

sub _payment_and_profit_report {
    my $self = shift;

    my @movers = $self->_report_mapper->get_active_accounts_payment_profit({
        start_time => $self->start,
        end_time   => $self->end
    });

    my @deposits = sort { $b->{usd_payments} <=> $a->{usd_payments} } @movers;
    my @withdrawals = reverse @deposits;
    my (@big_deposits, @big_withdrawals);

    for my $i (0 .. 9) {
        push @big_deposits, $deposits[$i]
            if ($deposits[$i] and $deposits[$i]->{usd_payments} > 0);
        push @big_withdrawals, $withdrawals[$i]
            if ($withdrawals[$i] and $withdrawals[$i]->{usd_payments} < 0);
    }

    my @winners = sort { $b->{usd_profit} <=> $a->{usd_profit} } @movers;
    my @losers = reverse @winners;
    my (@big_winners, @big_losers, @watched);

    for my $i (0 .. 9) {
        push @big_winners, $winners[$i]
            if ($winners[$i] and $winners[$i]->{usd_profit} > 0);
        push @big_losers, $losers[$i]
            if ($losers[$i] and $losers[$i]->{usd_profit} < 0);
    }
    my %all_watched =
        map { $_ => 1 } (keys %{$self->custom_client_profiles});

    foreach my $mover (@movers) {
        $self->_do_name_plus($mover);
        if ($all_watched{$mover->{loginid}}) {
            push @watched, $mover;
            delete $all_watched{$mover->{loginid}};
        }
    }

    # Add in the inactive limitlist
    foreach my $espied (
        map { +{loginid => $_, currency => 'ALL'} }
        keys %all_watched
        )
    {
        $self->_do_name_plus($espied);
        push @watched, $espied;
    }

    @watched =
        sort { $a->{loginid} cmp $b->{loginid} }
        sort { $a->{currency} cmp $b->{currency} } grep { $_->{being_watched_for} } @watched;

    return {
        big_deposits    => \@big_deposits,
        big_withdrawals => \@big_withdrawals,
        big_winners     => \@big_winners,
        big_losers      => \@big_losers,
        watched         => \@watched,
    };
}

sub multibarrierreport {
    my $self      = shift;
    my @open_bets = @{$self->_open_bets_at_end};
    my $multibarrier;
    my $symbol;
    foreach my $open_contract (@open_bets) {
        my $contract = produce_contract($open_contract->{short_code}, $open_contract->{currency_code});
        next if not $contract->can("trading_period_start");
        next if not $contract->is_intraday;

        my @available_barrier = @{$contract->predefined_contracts->{available_barriers}};

        # Rearrange the index of the barrier from  the median of the barrier list (ie the ATM barrier)
        my %reindex_barrier_list = map { $available_barrier[$_] => $_ - (int @available_barrier / 2) } (0 .. $#available_barrier);
        my $barrier_index        = $reindex_barrier_list{$contract->barrier->as_absolute};
        my $spot                 = $contract->current_spot;
        my ($closest_barrier_to_spot) =
            map { $_->{barrier} } sort { $a->{diff} <=> $b->{diff} } map { {barrier => $_, diff => abs($spot - $_)} } @available_barrier;
        my $spot_index           = $reindex_barrier_list{$closest_barrier_to_spot};
        my $trading_period_start = Date::Utility->new($contract->trading_period_start)->datetime;
        $multibarrier->{$trading_period_start . '_' . $contract->date_expiry->datetime}->{$contract->bet_type}->{barrier}->{$barrier_index}
            ->{$contract->underlying->symbol} +=
            financialrounding('price', 'USD', in_USD($open_contract->{buy_price}, $open_contract->{currency_code}));
        push @{$symbol->{$trading_period_start . '_' . $contract->date_expiry->datetime}}, $contract->underlying->symbol;

        $multibarrier->{$trading_period_start . '_' . $contract->date_expiry->datetime}->{spot}->{$contract->underlying->symbol} = $spot_index;
    }
    my $final;
    foreach my $expiry (sort keys %{$multibarrier}) {
        my $max = 0;

        for (-3 ... 3) {
            $final->{$expiry}->{PUT}->{barrier}->{$_}   = {};
            $final->{$expiry}->{CALLE}->{barrier}->{$_} = {};
            foreach my $symbol (uniq @{$symbol->{$expiry}}) {
                my $CALL = $multibarrier->{$expiry}->{CALLE}->{barrier}->{$_}->{$symbol} // 0;
                my $PUT  = $multibarrier->{$expiry}->{PUT}->{barrier}->{$_}->{$symbol}   // 0;
                $final->{$expiry}->{CALLE}->{barrier}->{$_}->{$symbol}->{'isSpot'} = 1
                    if defined $multibarrier->{$expiry}->{spot}->{$symbol} && $multibarrier->{$expiry}->{spot}->{$symbol} == $_;
                $final->{$expiry}->{PUT}->{barrier}->{$_}->{$symbol}->{'isSpot'} = 1
                    if defined $multibarrier->{$expiry}->{spot}->{$symbol} && $multibarrier->{$expiry}->{spot}->{$symbol} == $_;
                if ($CALL > 0 or $PUT > 0) {
                    if ($CALL > $PUT) {
                        $final->{$expiry}->{CALLE}->{barrier}->{$_}->{$symbol}->{value} = $CALL - $PUT;
                        $final->{$expiry}->{PUT}->{barrier}->{$_}->{$symbol}->{value}   = 0;
                        $max = ($CALL - $PUT) > $max ? $CALL - $PUT : $max;
                    } else {
                        $final->{$expiry}->{PUT}->{barrier}->{$_}->{$symbol}->{value}   = $PUT - $CALL;
                        $final->{$expiry}->{CALLE}->{barrier}->{$_}->{$symbol}->{value} = 0;
                        $max = ($PUT - $CALL) > $max ? $PUT - $CALL : $max;
                    }
                }
            }
        }
        $final->{$expiry}->{max} = $max;
    }

    $final->{generated_time} =
        BOM::Database::DataMapper::CollectorReporting->new({broker_code => 'CR'})->get_last_generated_historical_marked_to_market_time;
    return $final;
}

sub open_contract_exposures {
    my $self      = shift;
    my @open_bets = @{$self->_open_bets_at_end};
    my $final;
    my $symbol;
    foreach my $open_contract (@open_bets) {
        my $contract = produce_contract($open_contract->{short_code}, $open_contract->{currency_code});
        my $purchase_price = financialrounding('price', 'USD', in_USD($open_contract->{buy_price},    $open_contract->{currency_code}));
        my $payout_price   = financialrounding('price', 'USD', in_USD($open_contract->{payout_price}, $open_contract->{currency_code}));

        if ($contract->is_intraday) {

            my $intraday_category = ($contract->is_atm_bet) ? 'atm' : 'non_atm';
            $final->{$contract->underlying->market->name}->{intraday}->{$intraday_category}->{total_turnover} += $purchase_price;
            $final->{$contract->underlying->market->name}->{intraday}->{$intraday_category}->{total_payout}   += $payout_price;
            $final->{$contract->underlying->market->name}->{intraday}->{total_turnover}                       += $purchase_price;
            $final->{$contract->underlying->market->name}->{intraday}->{total_payout}                         += $payout_price;
            $final->{$contract->underlying->market->name}->{intraday}->{$intraday_category}->{$contract->underlying->symbol}->{turnover} +=
                $purchase_price;
            $final->{$contract->underlying->market->name}->{intraday}->{$intraday_category}->{$contract->underlying->symbol}->{payout} +=
                $payout_price;

        } else {

            my $daily_category = ($contract->is_atm_bet) ? 'atm' : 'non_atm';
            $final->{$contract->underlying->market->name}->{daily}->{$daily_category}->{total_turnover}                            += $purchase_price;
            $final->{$contract->underlying->market->name}->{daily}->{$daily_category}->{total_payout}                              += $payout_price;
            $final->{$contract->underlying->market->name}->{daily}->{total_turnover}                                               += $purchase_price;
            $final->{$contract->underlying->market->name}->{daily}->{total_payout}                                                 += $payout_price;
            $final->{$contract->underlying->market->name}->{daily}->{$daily_category}->{$contract->underlying->symbol}->{payout}   += $payout_price;
            $final->{$contract->underlying->market->name}->{daily}->{$daily_category}->{$contract->underlying->symbol}->{turnover} += $purchase_price;
        }
        $final->{$contract->underlying->market->name}->{total_turnover} += $purchase_price;
        $final->{$contract->underlying->market->name}->{total_payout}   += $payout_price;

    }
    my $report;
    $report->{pl} = sorting_data($final, 'open_bet');

    $report->{generated_time} =
        BOM::Database::DataMapper::CollectorReporting->new({broker_code => 'CR'})->get_last_generated_historical_marked_to_market_time;

    return $report;
}

sub closed_contract_exposure {
    my $self   = shift;
    my $today  = Date::Utility->new;
    my $closed = $self->closed_PL_by_underlying($today->truncate_to_day->db_timestamp);
    my $summary;
    foreach my $underlying (keys %$closed) {
        my $market      = create_underlying($underlying)->market->name;
        my $expiry_type = $closed->{$underlying}->{expiry_daily} ? 'daily' : 'intraday';
        my $atm_type    = $closed->{$underlying}->{is_atm} ? 'atm' : 'non_atm';
        $summary->{$market}->{$expiry_type}->{$atm_type}->{$underlying}->{closed_pl} =
            financialrounding('price', 'USD', $closed->{$underlying}->{usd_closed_pl});
    }
    $DB::single = 1;
    foreach my $market (keys %$summary) {
        my @sorted_by_underlying =
            map { [$_, $summary->{$market}->{$_}] }
            sort { $summary->{$market}->{$a} <=> $summary->{$market}->{$b} } grep { $_ ne 'total_closed_pl' } keys %{$summary->{$market}};
        my $total = $summary->{$market}->{total_closed_pl};
        delete $summary->{$market};
        $summary->{$market}->{total_closed_pl} = $total;
        for (my $i = 0; $i < scalar @sorted_by_underlying; $i++) {
            $summary->{$market}->{$i} = {$sorted_by_underlying[$i][0] => $sorted_by_underlying[$i][1]};
        }
    }
    my $report;
    my @sorted_closed_pl =
        map { [$_, $summary->{$_}] } sort { $summary->{$a}->{total_closed_pl} <=> $summary->{$b}->{total_closed_pl} } keys %{$summary};
    for (my $i = 0; $i < scalar @sorted_closed_pl; $i++) { $report->{pl}->{$i} = {$sorted_closed_pl[$i][0] => $sorted_closed_pl[$i][1]}; }

    $report->{generated_time} = $today->datetime;
    return $report;

}

sub sorting_data {
    my ($final, $for) = @_;
    my $sorting_arg = $for eq 'open_bet' ? 'total_payout' : 'total_closed_pl';

    foreach my $market (keys %$final) {
        next if $market =~ /total/;
        foreach my $expiry (keys %{$final->{$market}}) {
            next if $expiry =~ /total/;
            foreach my $atm (keys %{$final->{$market}->{$expiry}}) {
                next if $atm =~ /total/;
                my @sorted_by_underlying =
                    map { [$_, $final->{$market}->{$expiry}->{$atm}->{$_}->{payout}, $final->{$market}->{$expiry}->{$atm}->{$_}->{turnover}] }
                    sort { $final->{$market}->{$expiry}->{$atm}->{$b}->{payout} <=> $final->{$market}->{$expiry}->{$atm}->{$a}->{payout} }
                    grep { $_ !~ /total/ } keys %{$final->{$market}->{$expiry}->{$atm}};

                for (my $i = 0; $i < scalar @sorted_by_underlying; $i++) {
                    delete $final->{$market}->{$expiry}->{$atm}->{$sorted_by_underlying[$i][0]};
                    $final->{$market}->{$expiry}->{$atm}->{$i}->{$sorted_by_underlying[$i][0]} = {
                        payout   => $sorted_by_underlying[$i][1],
                        turnover => $sorted_by_underlying[$i][2]};
                }
            }
        }
    }
    my @sorted =
        map { [$_, $final->{$_}] }
        sort { $final->{$b}->{$sorting_arg} <=> $final->{$a}->{$sorting_arg} } grep { $_ !~ /total/ } keys %{$final};
    my $report;
    for (my $i = 0; $i < scalar @sorted; $i++) { $report->{$i} = {$sorted[$i][0] => $sorted[$i][1]}; }

    return $report;

}

sub exposures_report {
    my $self = shift;
    my $report;

    $report->{open_bet}  = $self->open_contract_exposures();
    $report->{closed_pl} = $self->closed_contract_exposure();

    return $report;
}

=head1 METHODS

=head2 generate

Generates the report, ignoring any caching. Returns the report, which is a HashRef.

=cut

sub generate {
    my $self = shift;

    _write_cache($self->_report, 1800);

    return $self->_report;
}

sub _read_cache { return Cache::RedisDB->get('RISK_DASHBOARD', 'report') }

sub _write_cache {
    my ($values, $ttl) = @_;
    Cache::RedisDB->set('RISK_DASHBOARD', 'report', $values, $ttl);
    return;
}

=head2 fetch

Same behavior as generate, but will take the report from cache if present.

=cut

sub fetch {
    my $self = shift;
    return (_read_cache || $self->generate);
}

no Moose;
__PACKAGE__->meta->make_immutable;
1;
