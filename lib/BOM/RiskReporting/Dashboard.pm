package BOM::RiskReporting::Dashboard;

=head1 NAME

BOM::RiskReporting::Dashboard

=head1 DESCRIPTION

Generates the report shown on our Risk Dashboard b/o page.

=cut

use strict;
use warnings;

use IO::File;
use List::Util qw(max first sum reduce);
use JSON::MaybeXS;
use Moose;
use Try::Tiny;
use Cache::RedisDB;
use Date::Utility;
use Format::Util::Numbers qw(roundcommon financialrounding);
use Time::Duration::Concise::Localize;
extends 'BOM::RiskReporting::Base';
use BOM::Product::ContractFactory qw( produce_contract );
use BOM::Database::Model::Account;
use BOM::Database::ClientDB;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::FinancialMarketBet;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::DataMapper::CollectorReporting;
use BOM::Database::AutoGenerated::Rose::MyaffiliatesTokenDetail;
use BOM::Platform::Runtime;
use BOM::Backoffice::Request;
use List::MoreUtils qw(uniq);
use BOM::Product::ContractFactory qw( produce_contract );
use BOM::Product::Contract::PredefinedParameters;
use Postgres::FeedDB::CurrencyConverter qw(in_USD);
use BOM::MarketData qw(create_underlying);
my $json = JSON::MaybeXS->new;

=head1 ATTRIBUTES

=head2 start

The start date of the period over which the instance reports.

=head2 end

The end date of the period over which the instance reports.

=cut

has [qw( start )] => (
    is         => 'ro',
    isa        => 'Date::Utility',
    lazy_build => 1,
);

sub _build_start {
    return shift->end->minus_time_interval('1d');
}

has custom_client_profiles => (
    is         => 'ro',
    isa        => 'HashRef',
    lazy_build => 1,
);

sub _build_custom_client_profiles {
    return $json->decode(BOM::Platform::Runtime->instance->app_config->quants->custom_client_profiles);
}

has _affiliate_info => (
    is      => 'ro',
    isa     => 'HashRef',
    default => sub { return {}; },
);

sub _do_name_plus {
    my ($self, $href) = @_;

    if ($href->{affiliation} and $href->{affiliate_username}) {
        $self->_affiliate_info->{$href->{affiliation}} = {
            id       => $href->{affiliation},
            username => $href->{affiliate_username},
            email    => $href->{affiliate_email},
        };
    }

    my $app_config = $self->custom_client_profiles;
    my $reason = $app_config->{$href->{loginid}}->{reason} // '';
    $href->{being_watched_for} = $reason;
    return $href;
}

sub _report_mapper {
    return BOM::Database::DataMapper::CollectorReporting->new({db => shift->_db});
}

has _report => (
    is         => 'ro',
    lazy_build => 1,
);

sub _build__report {
    my $self = shift;

    my $report = {
        start_date => $self->start->datetime_yyyymmdd_hhmmss,
        end_date   => $self->end->datetime_yyyymmdd_hhmmss,
    };
    my $ttl = Cache::RedisDB->ttl('RISK_DASHBOARD', 'report');
    my $pap_report = $self->_payment_and_profit_report;
    $report->{big_deposits}    = $pap_report->{big_deposits};
    $report->{big_withdrawals} = $pap_report->{big_withdrawals};
    $report->{big_winners}     = $pap_report->{big_winners};
    $report->{big_losers}      = $pap_report->{big_losers};
    $report->{watched}         = $pap_report->{watched};
    $report->{top_turnover}    = $self->_top_turnover;
    $report->{generated_time}  = Date::Utility->new->plus_time_interval(($ttl - 1800) . 's')->datetime;
    return $report;
}

sub _open_bets_at_end {
    my $self = shift;

    my $open_bets = $self->_report_mapper->get_open_bet_overviews($self->end);

    foreach my $bet (@{$open_bets}) {
        $self->_do_name_plus($bet);
    }

    return $open_bets;
}

sub _top_turnover {
    my $self = shift;

    my $tops = $self->_report_mapper->turnover_in_period({
        start_date => $self->start->db_timestamp,
        end_date   => $self->end->db_timestamp
    });
    my @sorted_top =
        sort { $b->{turnover} <=> $a->{turnover} }
        map { $self->_do_name_plus($tops->{$_}) } (keys %$tops);
    foreach my $entry (@sorted_top) {
        $self->_affiliate_info->{$entry->{affiliation}}->{turnover} += $entry->{turnover}
            if ($entry->{affiliation} and defined $entry->{turnover});
    }
    my @sorted_affils =
        sort { $b->{turnover} <=> $a->{turnover} }
        grep { defined $_->{turnover} }
        map  { $self->_affiliate_info->{$_} } keys %{$self->_affiliate_info};
    return +{
        clients => [(scalar @sorted_top <= 10) ? @sorted_top : @sorted_top[0 .. 9]],
        affiliates => [
            (scalar @sorted_affils <= 10)
            ? @sorted_affils
            : @sorted_affils[0 .. 9]]};
}

sub _payment_and_profit_report {
    my $self = shift;

    my @movers = $self->_report_mapper->get_active_accounts_payment_profit({
        start_time => $self->start,
        end_time   => $self->end
    });

    my @deposits = sort { $b->{usd_payments} <=> $a->{usd_payments} } @movers;
    my @withdrawals = reverse @deposits;
    my (@big_deposits, @big_withdrawals);

    for my $i (0 .. 9) {
        push @big_deposits, $deposits[$i]
            if ($deposits[$i] and $deposits[$i]->{usd_payments} > 0);
        push @big_withdrawals, $withdrawals[$i]
            if ($withdrawals[$i] and $withdrawals[$i]->{usd_payments} < 0);
    }

    my @winners = sort { $b->{usd_profit} <=> $a->{usd_profit} } @movers;
    my @losers = reverse @winners;
    my (@big_winners, @big_losers, @watched);

    for my $i (0 .. 9) {
        push @big_winners, $winners[$i]
            if ($winners[$i] and $winners[$i]->{usd_profit} > 0);
        push @big_losers, $losers[$i]
            if ($losers[$i] and $losers[$i]->{usd_profit} < 0);
    }
    my %all_watched =
        map { $_ => 1 } (keys %{$self->custom_client_profiles});

    foreach my $mover (@movers) {
        $self->_do_name_plus($mover);
        if ($all_watched{$mover->{loginid}}) {
            push @watched, $mover;
            delete $all_watched{$mover->{loginid}};
        }
    }

    # Add in the inactive limitlist
    foreach my $espied (
        map { +{loginid => $_, currency => 'ALL'} }
        keys %all_watched
        )
    {
        $self->_do_name_plus($espied);
        push @watched, $espied;
    }

    @watched =
        sort { $a->{loginid} cmp $b->{loginid} }
        sort { $a->{currency} cmp $b->{currency} } grep { $_->{being_watched_for} } @watched;

    return {
        big_deposits    => \@big_deposits,
        big_withdrawals => \@big_withdrawals,
        big_winners     => \@big_winners,
        big_losers      => \@big_losers,
        watched         => \@watched,
    };
}

sub open_bet_summary {
    my $self      = shift;
    my @open_bets = @{$self->_open_bets_at_end};
    my $final;
    my $symbol;
    foreach my $open_contract (@open_bets) {
        my $contract = produce_contract($open_contract->{short_code}, $open_contract->{currency_code});
        my $purchase_price = financialrounding('price', 'USD', in_USD($open_contract->{buy_price},    $open_contract->{currency_code}));
        my $payout_price   = financialrounding('price', 'USD', in_USD($open_contract->{payout_price}, $open_contract->{currency_code}));

        if ($contract->is_intraday) {

            my $intraday_category = ($contract->is_atm_bet) ? 'atm' : 'none_atm';
            $final->{$contract->underlying->market->name}->{intraday}->{$intraday_category}->{$contract->underlying->symbol}->{turnover} +=
                $purchase_price;
            $final->{$contract->underlying->market->name}->{intraday}->{$intraday_category}->{$contract->underlying->symbol}->{payout} +=
                $payout_price;
        } else {

            my $daily_category = ($contract->is_atm_bet) ? 'atm' : 'none_atm';
            $final->{$contract->underlying->market->name}->{daily}->{$daily_category}->{$contract->underlying->symbol}->{payout}   += $payout_price;
            $final->{$contract->underlying->market->name}->{daily}->{$daily_category}->{$contract->underlying->symbol}->{turnover} += $purchase_price;
        }
    }
    my $new_final;
    foreach my $market (keys %$final) {
        my ($total_turnover_by_market, $total_payout_by_market);
        foreach my $expiry (keys %{$final->{$market}}) {
            my ($total_turnover_by_expiry, $total_payout_by_expiry);
            foreach my $atm (keys %{$final->{$market}->{$expiry}}) {
                my ($total_turnover_by_atm, $total_payout_by_atm);
                my @sorted_by_underlying =
                    map { [$_, $final->{$market}->{$expiry}->{$atm}->{$_}->{payout}, $final->{$market}->{$expiry}->{$atm}->{$_}->{turnover}] }
                    sort { $final->{$market}->{$expiry}->{$atm}->{$a}->{payout} <=> $final->{$market}->{$expiry}->{$atm}->{$b}->{payout} }
                    keys %{$final->{$market}->{$expiry}->{$atm}};
                map { $total_turnover_by_market += $final->{$market}->{$expiry}->{$atm}->{$_}->{turnover} } keys %{$final->{$market}->{$expiry}->{$atm}};
                map { $total_payout_by_market   += $final->{$market}->{$expiry}->{$atm}->{$_}->{payout} } keys %{$final->{$market}->{$expiry}->{$atm}};

                $new_final->{$market}->{total_turnover} = $total_turnover_by_market;
                $new_final->{$market}->{total_payout}   = $total_payout_by_market;

                for (my $i = 0; $i < scalar @sorted_by_underlying; $i++) {
                    $new_final->{$market}->{$expiry}->{$atm}->{$i}->{$sorted_by_underlying[$i][0]} = {
                        payout   => $sorted_by_underlying[$i][1],
                        turnover => $sorted_by_underlying[$i][2]};
                }
            }
        }
    }
    my @sorted =
        map { [$_, $new_final->{$_}] }
        sort { $new_final->{$b}->{total_payout} <=> $new_final->{$a}->{total_payout} } grep { $_ !~ /total/ } keys %{$new_final};
    my $report;
    for (my $i = 0; $i < scalar @sorted; $i++) { $report->{pl}->{$i} = {$sorted[$i][0] => $sorted[$i][1]}; }

    $report->{generated_time} =
        BOM::Database::DataMapper::CollectorReporting->new({broker_code => 'CR'})->get_last_generated_historical_marked_to_market_time;
    return $report;
}

sub closedplreport {
    my $self   = shift;
    my $today  = Date::Utility->new;
    my $closed = $self->closed_PL_by_underlying($today->truncate_to_day->db_timestamp);
    my $summary;
    foreach my $underlying (keys %$closed) {
        my $market = create_underlying($underlying)->market->name;
        $summary->{$market}->{$underlying} = financialrounding('price', 'USD', $closed->{$underlying}->{usd_closed_pl});
        $summary->{$market}->{total_closed_pl} += financialrounding('price', 'USD', $closed->{$underlying}->{usd_closed_pl});
    }

    foreach my $market (keys %$summary) {
        my @sorted_by_underlying =
            map { [$_, $summary->{$market}->{$_}] }
            sort { $summary->{$market}->{$a} <=> $summary->{$market}->{$b} } grep { $_ ne 'total_closed_pl' } keys %{$summary->{$market}};
        my $total = $summary->{$market}->{total_closed_pl};
        delete $summary->{$market};
        $summary->{$market}->{total_closed_pl} = $total;
        for (my $i = 0; $i < scalar @sorted_by_underlying; $i++) {
            $summary->{$market}->{$i} = {$sorted_by_underlying[$i][0] => $sorted_by_underlying[$i][1]};
        }
    }

    my @sorted = map { [$_, $summary->{$_}] } sort { $summary->{$a}->{total_closed_pl} <=> $summary->{$b}->{total_closed_pl} } keys %{$summary};
    my $final;
    for (my $i = 0; $i < scalar @sorted; $i++) { $final->{pl}->{$i} = {$sorted[$i][0] => $sorted[$i][1]}; }

    $final->{generated_time} = $today->datetime;
    return $final;
}

=head1 METHODS

=head2 generate

Generates the report, ignoring any caching. Returns the report, which is a HashRef.

=cut

sub generate {
    my $self = shift;

    _write_cache($self->_report, 1800);

    return $self->_report;
}

sub _read_cache { return Cache::RedisDB->get('RISK_DASHBOARD', 'report') }

sub _write_cache {
    my ($values, $ttl) = @_;
    Cache::RedisDB->set('RISK_DASHBOARD', 'report', $values, $ttl);
    return;
}

=head2 fetch

Same behavior as generate, but will take the report from cache if present.

=cut

sub fetch {
    my $self = shift;
    return (_read_cache || $self->generate);
}

no Moose;
__PACKAGE__->meta->make_immutable;
1;
