package BOM::Rules::Registry::Rule::Group;

=head1 NAME

BOM::Rules::Registry::Rule::Group

=head1 SYNOPSIS

# rule group configuration (in a file like 'config/rule_groups/group_name.yml')
demo_group:
  required_arguments:
    - loginid
    - currency
  ruleset:
    - client.is_not_virtual
    - landing_company.currency_is_allowed

# usage in an action configuration file:
demo_action_with_groups: 
  ruleset:
    - residence.not_restricted   # a simple rule
    - type: group                # a rule group
      rule_group: demo_group
      argument_mapping: 
        currency: "'USD'"              # set a literal value (enclosed by quotation)
        landing_company: company_name  # or map to an action argument (without quitaion)
        loginid: client_loginid


=head1 DESCRIPTION

A collection of rules groupped together.
Rule groups can be used for different purposes: reusing as set of rules,
changing the names or values of args.

It can be extended in a number of ways in future, like changing the error codes generated by rules.

=cut

use strict;
use warnings;

use Moo;
use Syntax::Keyword::Try;

extends 'BOM::Rules::Registry::Rule';

=head2 BUILDARGS

This method is implemented to override the default constructor by initializing the attributes.

=cut

around BUILDARGS => sub {
    my ($orig, $class, %args) = @_;

    return $class->$orig(
        %args,
        required_arguments => $args{required_arguments} // [],
        argument_mapping   => $args{argument_mapping}   // {},
        ruleset            => $args{ruleset}            // []);
};

=head2 required_arguments

An array-ref containiung the args required by the underlying rules.

=cut

has required_arguments => (
    is => 'ro',
);

=head2 argument_mapping

A hash map that translated event args into rule B <arguments> .

=cut

has argument_mapping => (
    is => 'ro',
);

=head2 ruleset

An array of rules groupped together.

=cut

has ruleset => (
    is => 'ro',
);

=head2 tag

Tag assigned to the rule group. It's specially useful when a rule group is imported for more than once in a single action.
Tags of all enclosing groups are combined in to an array and returned in the `tags` attribute of every rule engine error;
this enables the client code to identify the source of the error easily and produce the correct error message.
For an example you can take a look at `payment_agent_transfer` action configuration and it's corresponding RPC code.

=cut

has tag => (
    is => 'ro',
);

=head2 _map_arguments

Maps action arguments to group arguments based on B<arguments> and B<argument_mapping> configurations.
It takes following args:

=over 4

=item C<context> The context of the rule engine.

=item C<action_args> The arguments by which an action is going to take place.

=back

=cut

sub _map_arguments {
    my ($self, $context, $action_args) = @_;
    $action_args //= {};
    my $result = {%$action_args};

    for my $arg (keys $self->argument_mapping->%*) {
        my $mapped_to = $self->argument_mapping->{$arg} // '';

        if ($mapped_to =~ qr/^'(.*)'$/) {
            # If the value is enclosed by quitation mark, take it as a constant (literal)
            $result->{$arg} = $1;
        } else {
            # otherwise it's an argument name and value will be read from action arguments
            $result->{$arg} = $action_args->{$mapped_to} if exists $action_args->{$mapped_to};
        }
    }

    for my $arg ($self->required_arguments->@*) {
        die "No value found for required argument '$arg'" unless exists $result->{$arg};
    }

    return $result;
}

=head2 apply

Applies the rules in the C<ruleset>, taking following arguments:

=over 4

=item C<context> The context of the rule engine.

=item C<action_args> The arguments by which an action is going to take place.

=back

=cut

sub apply {
    my ($self, $context, $args) = @_;

    my $group_args = $self->_map_arguments($context, $args);

    my $final_results = BOM::Rules::Result->new();
    for my $rule ($self->ruleset->@*) {
        my $rule_result;
        try {
            $rule_result = $rule->apply($context, $group_args);
        } catch ($e) {
            die $e unless ref $e;
            push($e->{tags}->@*, $self->tag) if $self->tag;
            die $e;
        };

        if ($self->tag && $rule_result->isa('BOM::Rules::Result')) {
            push($_->{tags}->@*, $self->tag) for $rule_result->{failed_rules}->@*;
        }

        $final_results->merge($rule_result);
    }

    return $final_results;
}

1;
