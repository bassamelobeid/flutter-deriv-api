package BOM::Transaction;

use Moose;
use Data::Dumper;
use Error::Base;
use Path::Tiny;
use Scalar::Util qw(blessed);
use Time::HiRes qw(tv_interval gettimeofday time);
use List::Util qw(min max first);
use JSON qw( from_json to_json );
use Date::Utility;
use ExpiryQueue qw( enqueue_new_transaction enqueue_multiple_new_transactions );
use Format::Util::Numbers qw(commas roundnear to_monetary_number_format);
use Try::Tiny;
use YAML::XS qw(LoadFile);
use DataDog::DogStatsd::Helper qw(stats_inc stats_timing stats_count);

use Brands;
use Client::Account;
use LandingCompany::Registry;
use Finance::Asset::Market::Types;
use Postgres::FeedDB::CurrencyConverter qw(amount_from_to_currency);

use BOM::Platform::Context qw(localize request);
use BOM::Platform::Runtime;
use BOM::Platform::Config;
use BOM::Product::ContractFactory qw( produce_contract make_similar_contract );
use BOM::Database::DataMapper::Payment;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::FinancialMarketBet;
use BOM::Database::ClientDB;
use BOM::Database::Model::Account;
use BOM::Database::Model::DataCollection::QuantsBetVariables;
use BOM::Database::Model::Constants;
use BOM::Database::Helper::FinancialMarketBet;
use BOM::Database::Helper::RejectedTrade;
use BOM::Database::ClientDB;

has client => (
    is  => 'ro',
    isa => 'Client::Account',
);

has multiple => (
    is  => 'ro',
    isa => 'Maybe[ArrayRef]',
);

has contract => (
    is => 'rw',
);

has price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

# price_slippage is the price difference between the requested buy or sell price from the recomputed price.
# If the slippage is within the acceptable amount, 50% of commission then we will honour the requested price.
has price_slippage => (
    is      => 'rw',
    default => 0,
);

# trading period of a contract
has trading_period_start => (
    is     => 'rw',
    isa    => 'date_object',
    coerce => 1,
);

# This is the requested buy or sell price
has requested_price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

# This is the recomputed buy or sell price
has recomputed_price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has transaction_record => (
    is         => 'ro',
    isa        => 'BOM::Database::AutoGenerated::Rose::Transaction',
    lazy_build => 1,
);

sub _build_transaction_record {
    my $self = shift;
    my $id = $self->transaction_id || die 'transaction not written yet';
    return $self->client->default_account->find_transaction({id => $id})->[0];
}

has balance_after => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has limits => (
    is      => 'rw',
    isa     => 'HashRef',
    default => sub { +{} },
);

has payout => (
    is         => 'rw',
    isa        => 'Num',
    lazy_build => 1,
);

sub _build_payout {
    my $self = shift;
    return $self->contract->payout;
}

has amount_type => (
    is         => 'rw',
    isa        => 'Str',
    lazy_build => 1,
);

sub _build_amount_type {
    my $self = shift;

    return 'payout' if $self->contract->is_spread;
    die 'amount type is required';

}

has comment => (
    is      => 'rw',
    isa     => 'ArrayRef',
    default => sub { [] },
);

has staff => (
    is         => 'rw',
    isa        => 'Str',
    lazy_build => 1,
);

sub _build_staff {
    my $self = shift;
    return $self->client->loginid;
}

has transaction_id => (
    is  => 'rw',
    isa => 'Int',
);

has contract_id => (
    is  => 'rw',
    isa => 'Int',
);

has execute_at_better_price => (
    is      => 'rw',
    isa     => 'Bool',
    default => 0,
);

# calling server should capture time of request
has purchase_date => (
    is         => 'rw',
    isa        => 'date_object',
    coerce     => 1,
    lazy_build => 1,
);

has contract_class => (
    is  => 'rw',
    isa => 'Str',
);

has source => (
    is  => 'ro',
    isa => 'Maybe[Int]',
);

has transaction_parameters => (
    is      => 'ro',
    isa     => 'HashRef',
    default => sub { {}; },
);

has app_markup => (
    is         => 'ro',
    isa        => 'Maybe[Num]',
    lazy_build => 1
);

sub _build_app_markup {
    my $self = shift;

    return 0 if $self->contract->is_spread;
    return $self->contract->app_markup_dollar_amount;
}

sub BUILDARGS {
    my ($class, $args) = @_;

    if (exists $args->{price}) {
        $args->{transaction_parameters}->{price} = $args->{price};
    }
    if (exists $args->{payout}) {
        $args->{transaction_parameters}->{payout} = $args->{payout};
    }
    return $args;
}

my $payment_limits = LoadFile(File::ShareDir::dist_file('Client-Account', 'payment_limits.yml'));

my %known_errors;              # forward declaration
sub sell_expired_contracts;    # forward declaration

sub _build_purchase_date {

# Purchase is considered to have happened at time of request; if no such info available, then now.
# Classic case: REQUEST_STARTTIME is present (epoch-style) in the binary.com cgi context.
    return $ENV{REQUEST_STARTTIME} // time;
}

sub stats_start {
    my $self = shift;
    my $what = shift;

    my $client   = $self->client;
    my $contract = $self->contract;

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::Platform::Config::env;
    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    my $tags      = {tags => ["broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "contract_class:$bet_class",]};

    if ($what eq 'buy' or $what eq 'batch_buy') {
        if ($self->contract->is_spread) {
            push @{$tags->{tags}}, "stop_type:" . lc($contract->stop_type);
        } else {
            push @{$tags->{tags}}, "amount_type:" . lc($self->amount_type), "expiry_type:" . ($contract->fixed_expiry ? 'fixed' : 'duration');
        }
    } elsif ($what eq 'sell') {
        push @{$tags->{tags}}, "sell_type:manual";
    }
    stats_inc("transaction.$what.attempt", $tags);

    return +{
        start   => [gettimeofday],
        tags    => $tags,
        virtual => $virtual,
        rmgenv  => $rmgenv,
        what    => $what,
    };
}

sub stats_validation_done {
    my $self = shift;
    my $data = shift;

    $data->{validation_done} = [gettimeofday];

    return;
}

# Given a generic error, try to turn it into a tag-friendly string which
# might be the same across multiple failures.
sub _normalize_error {
    my $error = shift;

    if (my $whatsit = blessed $error) {
        if ($whatsit eq 'Error::Base') {
            my $type = $error->get_type;    # These are nice short camelCase descriptions
            $error = (
                       $type eq 'InvalidtoBuy'
                    or $type eq 'InvalidtoSell'
            ) ? $error->get_mesg : $type;    # In these special cases, we'd like to get the underlying contract message, instead.
        } elsif ($whatsit eq 'MooseX::Role::Validatable::Error') {
            $error = $error->message;        # These should be sentence-like.
        } else {
            $error = "$error";               # Assume it's stringifiable.
        }
    }

    $error =~ s/(?<=[^A-Z])([A-Z])/ $1/g;    # camelCase to words
    $error =~ s/\[[^\]]+\]//g;               # Bits between [] should be dynamic
    $error = join('_', split /\s+/, lc $error);

    return $error;
}

sub stats_stop {
    my ($self, $data, $error, $extra) = @_;

    my $what = $data->{what};
    my $tags = $data->{tags};

    if ($error) {
        stats_inc("transaction.$what.failure", {tags => [@{$tags->{tags}}, 'reason:' . _normalize_error($error)]});

        return $error;
    }

    my $now = [gettimeofday];
    stats_timing("transaction.$what.elapsed_time", 1000 * tv_interval($data->{start},           $now), $tags);
    stats_timing("transaction.$what.db_time",      1000 * tv_interval($data->{validation_done}, $now), $tags);
    stats_inc("transaction.$what.success", $tags);

    if ($what eq 'batch_buy') {
        my @tags = grep { !/^(?:broker|virtual):/ } @{$tags->{tags}};
        for my $broker (keys %$extra) {
            my $xd = $extra->{$broker};
            my $tags = {tags => ["broker:" . lc($broker), "virtual:" . ($broker =~ /^VR/ ? "yes" : "no"), @tags]};
            stats_count("transaction.buy.attempt", $xd->{attempt}, $tags);
            stats_count("transaction.buy.success", $xd->{success}, $tags);
        }
        return;
    }
    return;
}

sub calculate_limits {
    my $self = shift;
    my $client = shift || $self->client;

    my %limits;

    my $static_config = BOM::Platform::Config::quants;

    my $contract = $self->contract;
    my $currency = $contract->currency;

    $limits{max_balance} = $client->get_limit_for_account_balance;

    if (not $contract->tick_expiry) {
        $limits{max_open_bets}        = $client->get_limit_for_open_positions;
        $limits{max_payout_open_bets} = $client->get_limit_for_payout;
        $limits{max_payout_per_symbol_and_bet_type} =
            $static_config->{bet_limits}->{open_positions_payout_per_symbol_and_bet_type_limit}->{$currency};
    }

    my $lim;
    defined($lim = $client->get_limit_for_daily_losses)
        and $limits{max_losses} = $lim;
    defined($lim = $client->get_limit_for_7day_turnover)
        and $limits{max_7day_turnover} = $lim;
    defined($lim = $client->get_limit_for_7day_losses)
        and $limits{max_7day_losses} = $lim;
    defined($lim = $client->get_limit_for_30day_turnover)
        and $limits{max_30day_turnover} = $lim;
    defined($lim = $client->get_limit_for_30day_losses)
        and $limits{max_30day_losses} = $lim;

    $limits{max_turnover} = $client->get_limit_for_daily_turnover;

    my $rp = $contract->risk_profile;
    my @cl_rp = $rp->get_client_profiles($client->loginid, $client->landing_company->short);
    if ($contract->is_spread) {
        # limits are calculated differently for spreads
        $limits{spread_bet_profit_limit} = $static_config->{risk_profile}{$rp->get_risk_profile(\@cl_rp)}{turnover}{$currency};
    } else {
        push @{$limits{specific_turnover_limits}}, @{$rp->get_turnover_limit_parameters(\@cl_rp)};
    }

    return \%limits;
}

sub prepare_bet_data_for_buy {
    my $self = shift;

    my $client   = $self->client;
    my $contract = $self->contract;

    if ($self->purchase_date->is_after($contract->date_start)) {
        my $d1 = $self->purchase_date->datetime_yyyymmdd_hhmmss;
        my $d2 = $contract->date_start->datetime_yyyymmdd_hhmmss;
        return Error::Base->cuss(
            -type              => 'ContractAlreadyStarted',
            -mesg              => "buy at $d1 too late for $d2 contract",
            -message_to_client => BOM::Platform::Context::localize("Start time is in the past"));
    }

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        quantity          => 1,
        short_code        => scalar $contract->shortcode,
        buy_price         => $self->price,
        remark            => $self->comment->[0] || '',
        underlying_symbol => scalar $contract->underlying->symbol,
        bet_type          => scalar $contract->code,
        bet_class         => $bet_class,
        purchase_time     => scalar $self->purchase_date->db_timestamp,
        start_time        => scalar $contract->date_start->db_timestamp,
        expiry_time       => scalar $contract->date_expiry->db_timestamp,
        settlement_time   => scalar $contract->date_settlement->db_timestamp,
        payout_price      => scalar $self->payout,
    };

    $bet_params->{expiry_daily} = 1 if $contract->expiry_daily;
    $bet_params->{fixed_expiry} = 1 if $contract->fixed_expiry;
    if ($contract->tick_expiry) {
        $bet_params->{tick_expiry} = 1;
        $bet_params->{tick_count}  = scalar $contract->tick_count;
    }

    if ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_SPREAD_BET) {
        $bet_params->{$_} = $contract->$_ for qw(amount_per_point spread stop_type spread_divisor);
        $bet_params->{stop_loss}   = $contract->supplied_stop_loss;
        $bet_params->{stop_profit} = $contract->supplied_stop_profit;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_HIGHER_LOWER_BET) {
        # only store barrier in the database if it is defined.
        # asian contracts have barriers at/after expiry.
        if ($contract->barrier) {
            $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
        }
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_DIGIT_BET) {
        $bet_params->{prediction} = $contract->sentiment;
        $bet_params->{last_digit} = $contract->barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_RANGE_BET) {
        $bet_params->{$contract->high_barrier->barrier_type . '_higher_barrier'} = $contract->high_barrier->supplied_barrier;
        $bet_params->{$contract->low_barrier->barrier_type . '_lower_barrier'}   = $contract->low_barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_TOUCH_BET) {
        $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
    } else {
        return Error::Base->cuss(
            -type              => 'UnsupportedBetClass',
            -mesg              => "Unsupported bet class $bet_params->{bet_class}",
            -message_to_client => BOM::Platform::Context::localize("Unsupported bet class $bet_params->{bet_class}"),
        );
    }

    my $quants_bet_variables;
    if (my $comment_hash = $self->comment->[1]) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $comment_hash,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
                app_markup    => $self->app_markup
            },
            bet_data             => $bet_params,
            quants_bet_variables => $quants_bet_variables,
        });
}

sub prepare_buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my %options = @_;

    my $error_status;

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        #
        # Keep the transaction rate test first to limit the impact of abusive buyers
        $error_status = $self->$_ and return $error_status
            for (
            qw/
            _validate_iom_withdrawal_limit
            _validate_available_currency
            _validate_currency
            _validate_jurisdictional_restrictions
            _validate_client_status
            _validate_client_self_exclusion
            _is_valid_to_buy
            _validate_date_pricing
            _validate_trade_pricing_adjustment
            _validate_payout_limit
            _validate_stake_limit/
            );

        if ($self->multiple) {
            for my $m (@{$self->multiple}) {
                next if $m->{code};
                $m->{limits} = $self->calculate_limits($m->{client});
            }
        } else {
            $self->limits($self->calculate_limits);
        }

        $self->comment(
            _build_pricing_comment({
                    contract         => $self->contract,
                    price            => $self->price,
                    requested_price  => $self->requested_price,
                    recomputed_price => $self->recomputed_price,
                    ($self->price_slippage) ? (price_slippage => $self->price_slippage) : (),
                    ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                    action => 'buy'
                })) unless @{$self->comment};
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_buy;
    return $error_status if $error_status;

    return $error_status, $bet_data;
}

sub buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my @options = @_;

    my $stats_data = $self->stats_start('buy');

    my ($error_status, $bet_data) = $self->prepare_buy(@options);
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        account_data => {
            client_loginid => $self->client->loginid,
            currency_code  => $self->contract->currency,
        },
        limits => $self->limits,
        db     => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $error = 1;
    my ($fmb, $txn);
    try {
        ($fmb, $txn) = $fmb_helper->buy_bet;
        $error = 0;
    }
    catch {
        # if $error_status is defined, return it
        # otherwise the function re-throws the exception
        $error_status = $self->_recover($_);
    };
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});
    $self->contract_id($fmb->{id});

    enqueue_new_transaction(_get_params_for_expiryqueue($self));    # For soft realtime expiration notification.

    return;
}

# expected parameters:
# $self->multiple
#   an array of hashes. Elements with a key "code" are ignored. They are
#   thought to be already erroneous. Otherwise the element should contain
#   a "loginid" key.
#   The following keys are added:
#   * client: the Client::Account object corresponding to the loginid
#   * limits: a hash representing the betting limits of this client
#   * fmb and txn: the FMB and transaction records that have been written
#     to the database in case of success
#   * code and error: in case of an error during the transaction these keys
#     contain the error description corresponding to the usual -type and
#     -message_to_client members of an Error::Base object.
# $self->contract
#   the contract
# $self->staff
# $self->source
# ...
#
# set or modified during operation:
# $self->price
#   the price
# @{$self->multiple}
#   see above
#
# return value:
#   - empty list on success. Success means the database function has been called.
#     It does not mean any contract has been bought.
#   - an Error::Base object indicates that something more fundamental went wrong.
#     For instance the contract's start date may be in the past.
#
# Exceptions:
#   The function may throw exceptions. However, it is guaranteed that after
#   contract validation no exception whatsoever is thrown. That means there
#   is no way for a contract to be bought but not reported back to the caller.

sub batch_buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my @options = @_;

    # TODO: shall we allow this operation only if $self->client is real-money?
    #       Or allow virtual $self->client only if all other clients are also
    #       virtual?

    my $stats_data = $self->stats_start('batch_buy');

    for my $m (@{$self->multiple}) {
        next if $m->{code};
        my $c = try { Client::Account->new({loginid => $m->{loginid}}) };
        unless ($c) {
            $m->{code}  = 'InvalidLoginid';
            $m->{error} = BOM::Platform::Context::localize('Invalid loginid');
            next;
        }

        $m->{client} = $c;
    }

    my ($error_status, $bet_data) = $self->prepare_buy(@options);
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my %per_broker;
    for my $m (@{$self->multiple}) {
        next if $m->{code};
        push @{$per_broker{$m->{client}->broker_code}}, $m;
    }

    my %stat = map { $_ => {attempt => 0 + @{$per_broker{$_}}} } keys %per_broker;

    for my $broker (keys %per_broker) {
        my $list = $per_broker{$broker};
        # with hash key caching introduced in recent perl versions
        # the "map sort map" pattern does not make sense anymore.

        # this sorting is to prevent deadlocks in the database
        @$list = sort { $a->{loginid} cmp $b->{loginid} } @$list;

        my @general_error = ('UnexpectedError', BOM::Platform::Context::localize('An unexpected error occurred'));

        try {
            my $currency   = $self->contract->currency;
            my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
                %$bet_data,
                # great readablility provided by our tidy rules
                account_data => [map                                      { +{client_loginid => $_->{loginid}, currency_code => $currency} } @$list],
                limits       => [map                                      { $_->{limits} } @$list],
                db           => BOM::Database::ClientDB->new({broker_code => $broker})->db,
            );

            my $success = 0;
            my $result  = $fmb_helper->batch_buy_bet;
            for my $el (@$list) {
                my $res = shift @$result;
                if (my $ecode = $res->{e_code}) {
                    # map DB errors to client messages
                    if (my $ref = $known_errors{$ecode}) {
                        my $error = (
                            ref $ref eq 'CODE'
                            ? $ref->($self, $el->{client}, $res->{e_description})
                            : $ref
                        );
                        $el->{code}  = $error->{-type};
                        $el->{error} = $error->{-message_to_client};
                    } else {
                        @{$el}{qw/code error/} = @general_error;
                    }
                } else {
                    $el->{fmb} = $res->{fmb};
                    $el->{txn} = $res->{txn};
                    $success++;
                }
            }
            $stat{$broker}->{success} = $success;
            enqueue_multiple_new_transactions(_get_params_for_expiryqueue($self), _get_list_for_expiryqueue($list));
        }
        catch {
            warn __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it

            for my $el (@$list) {
                @{$el}{qw/code error/} = @general_error unless $el->{code} or $el->{fmb};
            }
        };
    }

    $self->stats_stop($stats_data, undef, \%stat);

    return;
}

sub prepare_bet_data_for_sell {
    my $self = shift;
    my $contract = shift || $self->contract;

    my $client   = $self->client;
    my $loginid  = $client->loginid;
    my $currency = $contract->currency;

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        id         => scalar $self->contract_id,
        sell_price => scalar $self->price,
        sell_time  => scalar $contract->date_pricing->db_timestamp,
        $contract->category_code eq 'asian' && $contract->is_after_settlement
        ? (absolute_barrier => scalar $contract->barrier->as_absolute)
        : (),
    };

    my $quants_bet_variables;
    if (my $comment_hash = $self->comment->[1]) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $comment_hash,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
            },
            bet_data             => $bet_params,
            quants_bet_variables => $quants_bet_variables,
        });
}

sub sell {
    my ($self, %options) = @_;

    my $error_status;

    my $stats_data = $self->stats_start('sell');

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        $error_status = $self->$_ and return $self->stats_stop($stats_data, $error_status)
            for (
            qw/
            _validate_iom_withdrawal_limit
            _is_valid_to_sell
            _validate_available_currency
            _validate_currency
            _validate_sell_pricing_adjustment
            _validate_date_pricing/
            );

        $self->comment(
            _build_pricing_comment({
                    contract         => $self->contract,
                    price            => $self->price,
                    requested_price  => $self->requested_price,
                    recomputed_price => $self->recomputed_price,
                    ($self->price_slippage) ? (price_slippage => $self->price_slippage) : (),
                    ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                    action => 'sell'
                })) unless @{$self->comment};
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_sell;
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $bet_data->{account_data} = {
        client_loginid => $self->client->loginid,
        currency_code  => $self->contract->currency,
    };

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $error = 1;
    my ($fmb, $txn);
    try {
        ($fmb, $txn) = $fmb_helper->sell_bet;
        $error = 0;
    }
    catch {
        # if $error_status is defined, return it
        # otherwise the function re-throws the exception
        $error_status = $self->_recover($_);
    };
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'NoOpenPosition',
            -mesg              => 'No such open contract.',
            -message_to_client => BOM::Platform::Context::localize('This contract was not found among your open positions.'),
        )) unless defined $txn->{id};

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});

    return;
}

sub sell_by_shortcode {
    my ($self, %options) = @_;

    my $stats_data   = $self->stats_start('sell');
    my $error_status = undef;

    for my $m (@{$self->multiple}) {
        next if $m->{code};
        my $c = try { Client::Account->new({loginid => $m->{loginid}}) };
        unless ($c) {
            $m->{code}  = 'InvalidLoginid';
            $m->{error} = BOM::Platform::Context::localize('Invalid loginid');
            next;
        }

        $m->{client} = $c;
    }

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        $error_status = $self->$_ and return $self->stats_stop($stats_data, $error_status)
            for (
            qw/
            _is_valid_to_sell
            _validate_available_currency
            _validate_currency
            _validate_sell_pricing_adjustment
            _validate_date_pricing/
            );

        $self->comment(
            _build_pricing_comment({
                    contract         => $self->contract,
                    price            => $self->price,
                    requested_price  => $self->requested_price,
                    recomputed_price => $self->recomputed_price,
                    ($self->price_slippage) ? (price_slippage => $self->price_slippage) : (),
                    ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                    action => 'sell'
                })) unless @{$self->comment};
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_sell;

    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $currency = $self->contract->currency;

    my %per_broker;
    for my $m (@{$self->multiple}) {
        next if $m->{code};
        push @{$per_broker{$m->{client}->broker_code}}, $m;
    }

    my %stat = map { $_ => {attempt => 0 + @{$per_broker{$_}}} } keys %per_broker;

    for my $broker (keys %per_broker) {
        my $list    = $per_broker{$broker};
        my $success = 0;
        # with hash key caching introduced in recent perl versions
        # the "map sort map" pattern does not make sense anymore.

        # this sorting is to prevent deadlocks in the database
        @$list = sort { $a->{loginid} cmp $b->{loginid} } @$list;

        my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
            %$bet_data,
            account_data => [map                                      { +{client_loginid => $_->{loginid}, currency_code => $currency} } @$list],
            db           => BOM::Database::ClientDB->new({broker_code => $broker})->db,
        );
        try {
            my $res = $fmb_helper->sell_by_shortcode($self->contract->shortcode);

            foreach my $r (@$list) {
                my $res_row = shift @$res;
                if (my $ecode = $res_row->{e_code}) {
                    # map DB errors to client messages
                    if (my $ref = $known_errors{$ecode}) {
                        my $error = (
                            ref $ref eq 'CODE'
                            ? $ref->($self, $r->{client}, $res_row->{e_description})
                            : $ref
                        );

                        $r->{code}  = $error->{-type};
                        $r->{error} = $error->{-message_to_client};
                    } else {
                        @{$r}{qw/code error/} = ('UnexpectedError' . $ecode, BOM::Platform::Context::localize('An unexpected error occurred'));
                    }
                } else {
                    $r->{tnx}       = $res_row->{txn};
                    $r->{fmb}       = $res_row->{fmb};
                    $r->{buy_tr_id} = $res_row->{buy_tr_id};
                    $success++;
                }
            }
            $stat{$broker}->{success} = $success;
        }
        catch {
            warn __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it
            for my $el (@$list) {
                @{$el}{qw/code error/} = ('UnexpectedError', BOM::Platform::Context::localize('An unexpected error occurred'))
                    unless $el->{code} or $el->{fmb};
            }
        };
    }

    $self->stats_stop($stats_data, undef, \%stat);

    return;
}

=head2 C<< $self->_recover($error) >>

This function tries to recover from an unsuccessful buy/sell.
It may decide to retry the operation. And it may decide to
sell expired bets before doing so.

=head4 Parameters

=over 4

=item * C<< $error >>
the error exception thrown by BOM::Platform::Data::Persistence::DB::_handle_errors

=back

=head3 Return Value

L<Error::Base> object
which means an unrecoverable but expected condition has been found.
Typically that means a precondition, like sufficient balance, was
not met.

=head3 Exceptions

In case of an unexpected error, the exception is re-thrown unmodified.

=cut

%known_errors = (
    BI001 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_daily_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchasing this contract will cause you to exceed your daily turnover limit of [_1][_2].',
            $currency, $limit);
        if (not $client->client_fully_authenticated) {
            $error_message .= ' ' . BOM::Platform::Context::localize('If you wish to raise these limits, please authenticate your account.');
        }

        return Error::Base->cuss(
            -type              => 'DailyTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a daily turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI002 => sub {
        my $self   = shift;
        my $client = shift;

        my $limit = $client->get_limit_for_open_positions;
        return Error::Base->cuss(
            -type              => 'OpenPositionLimit',
            -mesg              => "Client has reached the limit of $limit open positions.",
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, you cannot hold more than [_1] contracts at a given time. Please visit the statement page to automatically sell your expired contracts.',
                $limit
            ),
        );
    },
    BI003 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $account  = BOM::Database::DataMapper::Account->new({
            client_loginid => $client->loginid,
            currency_code  => $currency,
        });
        my $balance = $currency eq 'JPY' ? commas($account->get_balance(), 0) : to_monetary_number_format($account->get_balance());
        my $price   = $currency eq 'JPY' ? commas($self->price,            0) : to_monetary_number_format($self->price);

        return Error::Base->cuss(
            -type              => 'InsufficientBalance',
            -message           => 'Client\'s account balance was insufficient to buy bet.',
            -message_to_client => BOM::Platform::Context::localize(
                'Your account balance ([_1][_2]) is insufficient to buy this contract ([_1][_3]).',
                $currency, $balance, $price
            ));
    },
    BI007 => sub {
        my $self   = shift;
        my $client = shift;

        return Error::Base->cuss(
            -type              => 'PotentialPayoutLimitForSameContractExceeded',
            -mesg              => "Client has exceeded potential payout limit for open contracts with the same symbol and bet_type",
            -message_to_client => BOM::Platform::Context::localize(
                'Purchasing this contract will cause you to exceed our payout limit for open contracts of this type. To continue, please sell some of your open contracts or trade in different contract types.'
            ),
        );
    },
    BI008 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_account_balance, 1);

        my $account = BOM::Database::DataMapper::Account->new({
            client_loginid => $client->loginid,
            currency_code  => $currency,
        });
        my $balance = $account->get_balance();

        return Error::Base->cuss(
            -type              => 'AccountBalanceExceedsLimit',
            -mesg              => 'Client balance is above the allowed limits',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, your account cash balance is too high ([_1]). Your maximum account balance is [_2].', "$currency$balance",
                "$currency$limit"
            ),
        );
    },
    BI009 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_payout, 1);

        return Error::Base->cuss(
            -type              => 'OpenPositionPayoutLimit',
            -mesg              => 'Client has reached maximum net payout for open positions',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, the aggregate payouts of contracts on your account cannot exceed [_1][_2].',
                $currency, $limit
            ),
        );
    },
    BI010 => Error::Base->cuss(
        -type              => 'PromoCodeLimitExceeded',
        -mesg              => 'Client won more than 25 times of the promo code amount',
        -message_to_client => BOM::Platform::Context::localize(
            'Your account has exceeded the trading limit with free promo code, please deposit if you wish to continue trading.'),
    ),
    BI011 => sub {
        my $self   = shift;
        my $client = shift;
        my $msg    = shift;

        my $limit_name = 'Unknown';
        $msg =~ /^.+: ([^,]+)/ and $limit_name = $1;

        return Error::Base->cuss(
            -type              => $limit_name . 'Exceeded',
            -mesg              => 'Exceeds turnover limit on ' . $limit_name,
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI012 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_daily_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your daily limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => 'DailyLossLimitExceeded',
            -mesg              => "Client has exceeded his daily loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI013 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_7day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchasing this contract will cause you to exceed your 7-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 7-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI014 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_7day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 7-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 7-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI015 => sub {
        my $self = shift;

        return Error::Base->cuss(
            -type              => 'SpreadDailyProfitLimitExceeded',
            -mesg              => 'Exceeds profit limit on spread',
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI016 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_30day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchasing this contract will cause you to exceed your 30-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 30-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI017 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_30day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 30-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 30-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI018 => sub {
        my $self   = shift;
        my $client = shift;

        return Error::Base->cuss(
            -type              => 'DailyProfitLimitExceeded',
            -mesg              => 'Exceeds daily profit limit',
            -message_to_client => BOM::Platform::Context::localize('No further trading is allowed for the current trading session.'),
        );
    },
    BI050 => sub {
        my $self   = shift;
        my $client = shift;
        my $msg    = shift;

        Error::Base->cuss(
            -type              => 'NoOpenPosition',
            -mesg              => $msg,
            -message_to_client => BOM::Platform::Context::localize('This contract was not found among your open positions.'),
        );
    },
    BI103 => Error::Base->cuss(
        -type              => 'RoundingExceedPermittedEpsilon',
        -mesg              => 'Rounding exceed permitted epsilon',
        -message_to_client => BOM::Platform::Context::localize('Only a maximum of two decimal points are allowed for the amount.'),
    ),
);

sub _recover {
    my $self   = shift;
    my $err    = shift;
    my $client = shift;
    if (blessed($self)) {
        $client //= $self->client;
    }

    if (ref($err) eq 'ARRAY') {    # special BINARY code
        my $ref = $known_errors{$err->[0]};
        return ref $ref eq 'CODE' ? $ref->($self, $client, $err->[1]) : $ref if $ref;
    } else {
        # TODO: recover from deadlocks & co.
    }
    die $err;
}

sub format_error {
    my ($self, %args) = @_;
    my $err               = $args{err};
    my $client            = $args{client};
    my $bak_type          = $args{bak_type} // 'InternalError';             # maybe caller know the type
    my $bak_msg           = Dumper($err);
    my $bak_msg_to_client = $args{bak_msg_to_client} // 'Internal Error';
    return try {
        return $self->_recover($err, $client);
    }
    catch {
        return Error::Base->cuss(
            -type              => $bak_type,
            -mesg              => $bak_msg,
            -message_to_client => BOM::Platform::Context::localize($bak_msg_to_client),
        );
    }
}

sub _validate_available_currency {
    my $self     = shift;
    my $currency = $self->contract->currency;

    if (not grep { $currency eq $_ } @{LandingCompany::Registry::get_by_broker($self->client->broker_code)->legal_allowed_currencies}) {
        return Error::Base->cuss(
            -type              => 'InvalidCurrency',
            -mesg              => "Invalid $currency",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is invalid.", $currency),
        );
    }
    return;
}

sub _create_validator {
    my $name   = shift;
    my $method = "_$name";

    my $sub = sub {
        my $self = shift;

        if ($self->multiple) {
            for my $m (@{$self->multiple}) {
                next if $m->{code};
                my $res = $self->$method($m->{client});
                if ($res) {
                    $m->{code}  = $res->{-type};
                    $m->{error} = $res->{-message_to_client};
                }
            }
            return;
        } else {
            return $self->$method($self->client);
        }
    };

    no warnings 'redefine';    ## no critic
    no strict 'refs';
    *{$name} = $sub;

    return;
}

sub __validate_currency {
    my $self     = shift;
    my $client   = shift;
    my $broker   = $client->broker_code;
    my $currency = $self->contract->currency;

    if ($client->default_account and $currency ne $client->currency) {
        return Error::Base->cuss(
            -type              => 'NotDefaultCurrency',
            -mesg              => "not default currency for client [$currency], client currency[" . $client->currency . "]",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is not the default currency", $currency),
        );
    }

    if (not LandingCompany::Registry::get_by_broker($broker)->is_currency_legal($currency)) {
        return Error::Base->cuss(
            -type              => 'IllegalCurrency',
            -mesg              => "Illegal $currency for $broker",
            -message_to_client => BOM::Platform::Context::localize("[_1] transactions may not be performed with this account.", $currency),
        );
    }
    return;
}
BEGIN { _create_validator '_validate_currency' }

sub _build_pricing_comment {
    my $args = shift;

    my ($contract, $price, $action, $price_slippage, $requested_price, $recomputed_price, $trading_period_start) =
        @{$args}{'contract', 'price', 'action', 'price_slippage', 'requested_price', 'recomputed_price', 'trading_period_start'};

    my @comment_fields;
    if ($contract->is_spread) {
        @comment_fields = map { defined $_->[1] ? @$_ : () } (
            [amount_per_point => $contract->amount_per_point],
            [stop_profit      => $contract->stop_profit],
            [stop_loss        => $contract->stop_loss],
            [spread           => $contract->spread],
        );
    } else {

        # IV is the pricing vol (high barrier vol if it is double barrier contract), iv_2 is the low barrier vol.
        my $iv   = $contract->pricing_vol;
        my $iv_2 = 0;

        if ($contract->pricing_vol_for_two_barriers) {

            $iv   = $contract->pricing_vol_for_two_barriers->{high_barrier_vol};
            $iv_2 = $contract->pricing_vol_for_two_barriers->{low_barrier_vol};

        }

        # This way the order of the fields is well-defined.
        @comment_fields = map { defined $_->[1] ? @$_ : (); } (
            [theo  => $contract->theo_price],
            [iv    => $iv],
            [iv_2  => $iv_2],
            [win   => $contract->payout],
            [div   => $contract->q_rate],
            [int   => $contract->r_rate],
            [delta => $contract->delta],
            [gamma => $contract->gamma],
            [vega  => $contract->vega],
            [theta => $contract->theta],
            [vanna => $contract->vanna],
            [volga => $contract->volga],
            [spot  => $contract->current_spot]);

        # only manual sell and buy has a price
        if ($price) {
            push @comment_fields, (trade => $price);
        }

        if ($contract->entry_tick) {
            push @comment_fields, (entry_spot       => $contract->entry_tick->quote);
            push @comment_fields, (entry_spot_epoch => $contract->entry_tick->epoch);
        }

        # Record price slippage in quants bet variable.
        # To always reproduce ask price, we would want to record the slippage allowed during transaction.
        if (defined $price_slippage) {
            push @comment_fields, (price_slippage => $price_slippage);
        }

        # Record requested price in quants bet variable.
        if (defined $requested_price) {
            push @comment_fields, (requested_price => $requested_price);
        }

        # Record recomputed price in quants bet variable.
        if (defined $recomputed_price) {
            push @comment_fields, (recomputed_price => $recomputed_price);
        }

        my $tick;
        if ($action eq 'sell') {
            # current tick is lazy, even though the realtime cache might have changed during the course of the transaction.
            $tick = $contract->current_tick;
        } elsif ($action eq 'autosell_expired_contract') {
            $tick = ($contract->is_path_dependent and $contract->hit_tick) ? $contract->hit_tick : $contract->exit_tick;
        }

        if ($tick) {
            push @comment_fields, (exit_spot       => $tick->quote);
            push @comment_fields, (exit_spot_epoch => $tick->epoch);
            if ($contract->two_barriers) {
                push @comment_fields, (high_barrier => $contract->high_barrier->as_absolute) if $contract->high_barrier;
                push @comment_fields, (low_barrier  => $contract->low_barrier->as_absolute)  if $contract->low_barrier;
            } else {
                push @comment_fields, (barrier => $contract->barrier->as_absolute) if $contract->barrier;
            }
        }

        my $news_factor = $contract->ask_probability->peek('news_factor');
        if ($news_factor) {
            push @comment_fields, news_fct => $news_factor->amount;
            my $news_impact = $news_factor->peek('news_impact');
            push @comment_fields, news_impact => $news_impact->amount if $news_impact;
        }

        if (@{$contract->corporate_actions}) {
            push @comment_fields,
                corporate_action => 1,
                actions          => join '|',
                map { $_->{description} . ',' . $_->{modifier} . ',' . $_->{value} } @{$contract->corporate_actions};
        }
    }

    my $comment_str = sprintf join(' ', ('%s[%0.5f]') x (@comment_fields / 2)), @comment_fields;

    if (defined $trading_period_start) {
        push @comment_fields, (trading_period_start => $trading_period_start);
    }

    my %comment_hash = map { $_ } @comment_fields;

    return [$comment_str, \%comment_hash];
}

sub _validate_sell_pricing_adjustment {
    my $self = shift;

    # always sell at recomputed bid price for spreads.
    if ($self->contract->is_spread or not defined $self->price) {
        $self->price($self->contract->bid_price);
        return;
    }

    if ($self->contract->is_expired) {
        return Error::Base->cuss(
            -type              => 'BetExpired',
            -mesg              => 'Contract expired with a new price',
            -message_to_client => BOM::Platform::Context::localize('The contract has expired'),
        );
    }

    my $contract = $self->contract;
    my $currency = $contract->currency;

    my $requested = $self->price / $self->payout;
    # set the requested price and recomputed  price to be store in db
    $self->requested_price($self->price);
    $self->recomputed_price($contract->bid_price);
    my $recomputed   = $contract->bid_probability->amount;
    my $move         = $recomputed - $requested;
    my $slippage     = $contract->bid_price - $self->price;
    my $allowed_move = $contract->allowed_slippage;
    $allowed_move = 0 if $recomputed == 1;
    my ($amount, $recomputed_amount) = ($self->price, $contract->bid_price);

    if ($move != 0) {
        my $final_value;
        if ($allowed_move == 0) {
            $final_value = $recomputed_amount;
        } elsif ($move < -$allowed_move) {
            my $market_moved = BOM::Platform::Context::localize('The underlying market has moved too much since you priced the contract. ');
            $market_moved .= BOM::Platform::Context::localize(
                'The contract [_4] has changed from [_1][_2] to [_1][_3].',
                $currency,
                to_monetary_number_format($amount),
                to_monetary_number_format($recomputed_amount),
                'sell price'
            );

            #Record failed transaction here.
            my $rejected_trade = BOM::Database::Helper::RejectedTrade->new({
                    login_id                => $self->client->loginid,
                    financial_market_bet_id => $self->contract_id,
                    shortcode               => $self->contract->shortcode,
                    action_type             => 'sell',
                    reason                  => 'SLIPPAGE',
                    details                 => JSON::to_json({
                            order_price      => $self->price,
                            recomputed_price => $contract->bid_price,
                            slippage         => $slippage,
                            option_type      => $contract->code,
                            currency_pair    => $contract->underlying->symbol,
                            ($contract->two_barriers)
                            ? (barriers => $contract->low_barrier->as_absolute . "," . $contract->high_barrier->as_absolute)
                            : (barriers => $contract->barrier->as_absolute),
                            expiry => $contract->date_expiry->db_timestamp,
                            payout => $contract->payout
                        }
                    ),
                    db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
                });
            $rejected_trade->record_fail_txn();

            return Error::Base->cuss(
                -type => 'PriceMoved',
                -mesg =>
                    "Difference between submitted and newly calculated bet price: currency $currency, amount: $amount, recomputed amount: $recomputed_amount",
                -message_to_client => $market_moved,
            );
        } else {
            if ($move <= $allowed_move and $move >= -$allowed_move) {
                $final_value = $amount;
                # We absorbed the price difference here and we want to keep it in our book.
                $self->price_slippage($slippage);
            } elsif ($move > $allowed_move) {
                $self->execute_at_better_price(1);
                # We need to keep record of slippage even it is executed at better price
                $self->price_slippage($slippage);
                $final_value = $recomputed_amount;
            }
        }

        $self->price($final_value);
    }

    return;
}

sub _validate_trade_pricing_adjustment {
    my $self = shift;

    # always buy at recomputed ask price for spreads.
    if ($self->contract->is_spread) {
        $self->price($self->contract->ask_price);
        return;
    }

    my $amount_type = $self->amount_type;
    my $contract    = $self->contract;
    my $currency    = $contract->currency;

    my $requested = $self->price / $self->payout;
    # set the requested price and recomputed price to be store in db
    $self->requested_price($self->price);
    $self->recomputed_price($contract->ask_price);
    my $recomputed   = $contract->ask_probability->amount;
    my $move         = $requested - $recomputed;
    my $slippage     = $self->price - $contract->ask_price;
    my $allowed_move = $contract->allowed_slippage;
    $allowed_move = 0 if $recomputed == 1;
    my ($amount, $recomputed_amount) = $amount_type eq 'payout' ? ($self->price, $contract->ask_price) : ($self->payout, $contract->payout);

    if ($move != 0) {
        my $final_value;
        if ($contract->is_expired) {
            return Error::Base->cuss(
                -type              => 'BetExpired',
                -mesg              => 'Bet expired with a new price[' . $recomputed_amount . '] (old price[' . $amount . '])',
                -message_to_client => BOM::Platform::Context::localize('The contract has expired'),
            );
        } elsif ($allowed_move == 0) {
            $final_value = $recomputed_amount;
        } elsif ($move < -$allowed_move) {
            my $what_changed = $amount_type eq 'payout' ? 'price' : 'payout';
            my $market_moved = BOM::Platform::Context::localize('The underlying market has moved too much since you priced the contract. ');
            $market_moved .= BOM::Platform::Context::localize(
                'The contract [_4] has changed from [_1][_2] to [_1][_3].',
                $currency,
                to_monetary_number_format($amount),
                to_monetary_number_format($recomputed_amount),
                $what_changed
            );

            #Record failed transaction here.
            my $rejected_trade = BOM::Database::Helper::RejectedTrade->new({
                    login_id    => $self->client->loginid,
                    shortcode   => $self->contract->shortcode,
                    action_type => 'buy',
                    reason      => 'SLIPPAGE',
                    details     => JSON::to_json({
                            order_price      => $self->price,
                            recomputed_price => $contract->ask_price,
                            slippage         => $slippage,
                            option_type      => $contract->code,
                            currency_pair    => $contract->underlying->symbol,
                            ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                            ($contract->two_barriers)
                            ? (barriers => $contract->low_barrier->as_absolute . "," . $contract->high_barrier->as_absolute)
                            : (barriers => $contract->barrier->as_absolute),
                            expiry => $contract->date_expiry->db_timestamp,
                            payout => $contract->payout
                        }
                    ),
                    db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
                });
            $rejected_trade->record_fail_txn();

            return Error::Base->cuss(
                -type => 'PriceMoved',
                -mesg =>
                    "Difference between submitted and newly calculated bet price: currency $currency, amount: $amount, recomputed amount: $recomputed_amount",
                -message_to_client => $market_moved,
            );
        } else {
            if ($move <= $allowed_move and $move >= -$allowed_move) {
                $final_value = $amount;
                # We absorbed the price difference here and we want to keep it in our book.
                $self->price_slippage($slippage);
            } elsif ($move > $allowed_move) {
                $self->execute_at_better_price(1);
                # We need to keep record of slippage even it is executed at better price
                $self->price_slippage($slippage);
                $final_value = $recomputed_amount;
            }
        }

        # adjust the value here
        if ($amount_type eq 'payout') {
            $self->price($final_value);
        } else {
            $self->payout($final_value);

            # They are all 'payout'-based when they hit the DB.
            my $new_contract = make_similar_contract(
                $contract,
                {
                    amount_type => 'payout',
                    amount      => $final_value,
                });
            $self->contract($new_contract);
        }
    }

    return;
}

sub _is_valid_to_buy {
    my $self     = shift;
    my $contract = $self->contract;

    if (
        not(
              $contract->is_spread
            ? $contract->is_valid_to_buy
            : $contract->is_valid_to_buy({landing_company => $self->client->landing_company->short})))
    {
        return Error::Base->cuss(
            -type              => 'InvalidtoBuy',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }

    return;
}

sub _is_valid_to_sell {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_valid_to_sell) {
        return Error::Base->cuss(
            -type              => 'InvalidtoSell',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }

    return;
}

sub _validate_date_pricing {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_expired
        and abs(time - $contract->date_pricing->epoch) > 20)
    {
        return Error::Base->cuss(
            -type              => 'InvalidDatePricing',
            -mesg              => 'Bet was validated for a time [' . $contract->date_pricing->epoch . '] too far from now[' . time . ']',
            -message_to_client => BOM::Platform::Context::localize('This contract cannot be properly validated at this time.'));
    }
    return;
}

=head2 $self->_validate_iom_withdrawal_limit
Validate the withdrawal limit for IOM region
=cut

sub __validate_iom_withdrawal_limit {
    my $self   = shift;
    my $client = shift;

    return if $client->is_virtual;

    my $landing_company = LandingCompany::Registry::get_by_broker($client->broker_code);
    return if ($landing_company->country ne 'Isle of Man');

    my $landing_company_short = $landing_company->short;
    my $withdrawal_limits     = $payment_limits->{withdrawal_limits};
    my $numdays               = $withdrawal_limits->{$landing_company_short}->{for_days};
    my $numdayslimit          = $withdrawal_limits->{$landing_company_short}->{limit_for_days};
    my $lifetimelimit         = $withdrawal_limits->{$landing_company_short}->{lifetime_limit};

    if ($client->client_fully_authenticated) {
        $numdayslimit  = 99999999;
        $lifetimelimit = 99999999;
    }

    # withdrawal since $numdays
    my $payment_mapper = BOM::Database::DataMapper::Payment->new({client_loginid => $client->loginid});
    my $withdrawal_in_days = $payment_mapper->get_total_withdrawal({
        start_time => Date::Utility->new(Date::Utility->new->epoch - 86400 * $numdays),
        exclude    => ['currency_conversion_transfer'],
    });
    $withdrawal_in_days = roundnear(0.01, amount_from_to_currency($withdrawal_in_days, $client->currency, 'EUR'));

    # withdrawal since inception
    my $withdrawal_since_inception = $payment_mapper->get_total_withdrawal({exclude => ['currency_conversion_transfer']});
    $withdrawal_since_inception = roundnear(0.01, amount_from_to_currency($withdrawal_since_inception, $client->currency, 'EUR'));

    my $remaining_withdrawal_eur =
        roundnear(0.01, min(($numdayslimit - $withdrawal_in_days), ($lifetimelimit - $withdrawal_since_inception)));

    if ($remaining_withdrawal_eur <= 0) {
        return Error::Base->cuss(
            -type              => 'iomWithdrawalLimit',
            -mesg              => $client->loginid . ' caught in IOM withdrawal limit check',
            -message_to_client => BOM::Platform::Context::localize(
                "Due to regulatory requirements, you are required to authenticate your account in order to continue trading."),
        );
    }
    return;
}
BEGIN { _create_validator '_validate_iom_withdrawal_limit' }

# This validation should always come after _validate_trade_pricing_adjustment
# because we recompute the price and that's the price that we going to transact with!
sub ___validate_stake_limit {
    my $self   = shift;
    my $client = shift;

    my $contract        = $self->contract;
    my $landing_company = $client->landing_company;
    my $currency        = $contract->currency;

    my $stake_limit =
        $landing_company->short eq 'maltainvest'
        ? BOM::Platform::Config::quants->{bet_limits}->{min_stake}->{maltainvest}->{$currency}
        : $contract->staking_limits->{min};    # minimum is always a stake check

    if ($contract->ask_price < $stake_limit) {
        return Error::Base->cuss(
            -type => 'StakeTooLow',
            -mesg => $client->loginid . ' stake [' . $contract->ask_price . '] is lower than minimum allowable stake [' . $stake_limit . ']',
            -message_to_client => BOM::Platform::Context::localize(
                "This contract's price is [_1][_2]. Contracts purchased from [_3] must have a purchase price above [_1][_4]. Please accordingly increase the contract amount to meet this minimum stake.",
                $currency,
                to_monetary_number_format($contract->ask_price),
                $landing_company->name,
                to_monetary_number_format($stake_limit)
            ),
        );
    }
    return;
}
BEGIN { _create_validator '__validate_stake_limit' }

sub _validate_stake_limit {
    my $self = shift;

    # spread stake validation is within its module.
    # spread bet won't be offered to maltainvest.
    return if $self->contract->is_spread;
    return $self->__validate_stake_limit;
}

=head2 $self->_validate_payout_limit
Validate if payout is not over the client limits
=cut

sub __validate_payout_limit {
    my $self   = shift;
    my $client = shift;

    my $contract = $self->contract;

    return if $contract->is_spread;

    my $rp = $self->contract->risk_profile;
    my @cl_rp = $rp->get_client_profiles($client->loginid, $client->landing_company->short);

    # setups client specific payout and turnover limits, if any.
    if (@cl_rp) {
        my $custom_profile = $rp->get_risk_profile(\@cl_rp);
        if ($custom_profile eq 'no_business') {
            return Error::Base->cuss(
                -type              => 'NoBusiness',
                -mesg              => $client->loginid . ' manually disabled by quants',
                -message_to_client => BOM::Platform::Context::localize('This contract is unavailable on this account.'),
            );
        }

        my $custom_limit = BOM::Platform::Config::quants->{risk_profile}{$custom_profile}{payout}{$contract->currency};
        if (defined $custom_limit and (my $payout = $self->payout) > $custom_limit) {
            return Error::Base->cuss(
                -type              => 'PayoutLimitExceeded',
                -mesg              => $client->loginid . ' payout [' . $payout . '] over custom limit[' . $custom_limit . ']',
                -message_to_client => ($custom_limit == 0)
                ? BOM::Platform::Context::localize('This contract is unavailable on this account.')
                : BOM::Platform::Context::localize(
                    'This contract is limited to ' . to_monetary_number_format($custom_limit) . ' payout on this account.'
                ),
            );
        }
    }

    return;
}
BEGIN { _create_validator '_validate_payout_limit' }

=head2 $self->_validate_jurisdictional_restrictions
Validates whether the client has provided his residence country
=cut

sub __validate_jurisdictional_restrictions {
    my $self   = shift;
    my $client = shift;

    my $contract    = $self->contract;
    my $residence   = $client->residence;
    my $loginid     = $client->loginid;
    my $market_name = $contract->market->name;

    if (!$residence && $loginid !~ /^VR/) {
        return Error::Base->cuss(
            -type              => 'NoResidenceCountry',
            -mesg              => 'Client cannot place contract as we do not know their residence.',
            -message_to_client => BOM::Platform::Context::localize(
                'In order for you to place contracts, we need to know your Residence (Country). Please update your settings.'),
        );
    }

    my $lc = LandingCompany::Registry::get_by_broker($loginid);

    my %legal_allowed_ct = map { $_ => 1 } @{$lc->legal_allowed_contract_types};
    if (not $legal_allowed_ct{$contract->code}) {
        return Error::Base->cuss(
            -type              => 'NotLegalContractCategory',
            -mesg              => 'Clients are not allowed to trade on this contract category as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this contract.'),
        );
    }

    if (not grep { $market_name eq $_ } @{$lc->legal_allowed_markets}) {
        return Error::Base->cuss(
            -type              => 'NotLegalMarket',
            -mesg              => 'Clients are not allowed to trade on this markets as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this market.'),
        );
    }

    my $countries_instance = Brands->new(name => request()->brand)->countries_instance;
    if ($residence && $market_name eq 'volidx' && $countries_instance->volidx_restricted_country($residence)) {
        return Error::Base->cuss(
            -type => 'RandomRestrictedCountry',
            -mesg => 'Clients are not allowed to place Volatility Index contracts as their country is restricted.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, contracts on Volatility Indices are not available in your country of residence'),
        );
    }

    # For certain countries such as Belgium, we are not allow to sell financial product to them.
    if (   $residence
        && $market_name ne 'volidx'
        && $countries_instance->financial_binaries_restricted_country($residence))
    {
        return Error::Base->cuss(
            -type => 'FinancialBinariesRestrictedCountry',
            -mesg => 'Clients are not allowed to place financial products contracts as their country is restricted.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, contracts on Financial Products are not available in your country of residence'),
        );
    }

    my %legal_allowed_underlyings = map { $_ => 1 } @{$lc->legal_allowed_underlyings};
    if (not $legal_allowed_underlyings{all} and not $legal_allowed_underlyings{$contract->underlying->symbol}) {
        return Error::Base->cuss(
            -type              => 'NotLegalUnderlying',
            -mesg              => 'Clients are not allowed to trade on this underlying as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this underlying.'),
        );
    }

    return;
}
BEGIN { _create_validator '_validate_jurisdictional_restrictions' }

=head2 $self->_validate_client_status
Validates to make sure that the client with unwelcome status
is not able to purchase contract
=cut

sub __validate_client_status {
    my $self   = shift;
    my $client = shift;

    if ($client->get_status('unwelcome') or $client->get_status('disabled')) {
        return Error::Base->cuss(
            -type              => 'ClientUnwelcome',
            -mesg              => 'your account is not authorised for any further contract purchases.',
            -message_to_client => BOM::Platform::Context::localize('Sorry, your account is not authorised for any further contract purchases.'),
        );
    }

    return;
}
BEGIN { _create_validator '_validate_client_status' }

=head2 $self->_validate_client_self_exclusion
Validates to make sure that the client with self exclusion
is not able to purchase contract
=cut

sub __validate_client_self_exclusion {
    my $self   = shift;
    my $client = shift;

    if (my $limit_excludeuntil = $client->get_self_exclusion_until_dt) {
        return Error::Base->cuss(
            -type => 'ClientSelfExcluded',
            -mesg => 'your account is not authorised for any further contract purchases.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, you have excluded yourself from the website until [_1].', $limit_excludeuntil),
        );
    }

    return;
}
BEGIN { _create_validator '_validate_client_self_exclusion' }

=head2 sell_expired_contracts
Static function: Sells expired contracts.
For contracts with missing market data, settle them manually for real money accounts, but sell with purchase price for virtual account
Returns: HashRef, with:
'total_credited', total amount credited to Client
'skip_contract', count for expired contracts that failed to be sold
'failures', the failure information
=cut

my %source_to_sell_type = (
    2 => 'expiryd',    # app id for `Binary.com expiryd.pl` in auth db => oauth.apps table
);

sub sell_expired_contracts {
    my $args         = shift;
    my $client       = $args->{client};
    my $source       = $args->{source};
    my $contract_ids = $args->{contract_ids};

    my $time_start = Time::HiRes::time;

    my $currency = $client->currency;
    my $loginid  = $client->loginid;

    my $result = {
        skip_contract => $contract_ids ? (scalar @$contract_ids) : 0,
        total_credited      => 0,
        number_of_sold_bets => 0,
        failures            => [],
    };

    my $mapper = BOM::Database::DataMapper::FinancialMarketBet->new({
        client_loginid => $loginid,
        currency_code  => $currency,
        broker_code    => $client->broker_code,
        operation      => 'replica',
    });

    my $clientdb = BOM::Database::ClientDB->new({
        broker_code => $client->broker_code,
        operation   => 'replica',
    });

    my $bets =
          (defined $contract_ids)
        ? [map { $_->financial_market_bet_record } @{$mapper->get_fmb_by_id($contract_ids)}]
        : $clientdb->getall_arrayref('select * from bet.get_open_bets_of_account(?,?,?)',
        [$client->loginid, $client->currency, ($args->{only_expired} ? 'true' : 'false')]);

    return $result unless $bets and @$bets;

    my $now = Date::Utility->new;
    my @bets_to_sell;
    my @quants_bet_variables;
    my @transdata;
    my %stats_attempt;
    my %stats_failure;
    for my $bet (@$bets) {
        my $contract;
        my $error;
        my $failure = {fmb_id => $bet->{id}};
        try { $contract = produce_contract($bet->{short_code}, $currency); } catch { $error = 1; };
        if ($error) {
            $failure->{reason} = 'Could not instantiate contract object';
            push @{$result->{failures}}, $failure;
            next;
        }

        my $logging_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
        $stats_attempt{$logging_class}++;
        if (not $contract->is_settleable) {
            $stats_failure{$logging_class}{'NotExpired'}++;
            $failure->{reason} = 'not expired';
            push @{$result->{failures}}, $failure;
            next;
        } elsif ($contract->category_code eq 'legacy') {
            $stats_failure{$logging_class}{Legacy}++;
            $failure->{reason} = 'legacy';
            push @{$result->{failures}}, $failure;
            next;
        }

        try {
            if ($contract->is_valid_to_sell) {
                @{$bet}{qw/sell_price sell_time/} = ($contract->bid_price, $contract->date_pricing->db_timestamp);
                $bet->{absolute_barrier} = $contract->barrier->as_absolute
                    if $contract->category_code eq 'asian' and $contract->is_after_settlement;
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };

                # price_slippage will not happen to expired contract, hence not needed.
                my $comment_hash = _build_pricing_comment({
                        contract => $contract,
                        action   => 'autosell_expired_contract',
                    })->[1];
                my $quants_bet_variables;
                if ($comment_hash) {
                    $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                        data_object_params => $comment_hash,
                    });
                }
                push @quants_bet_variables, $quants_bet_variables;

            } elsif ($client->is_virtual and $now->epoch >= $contract->date_settlement->epoch + 3600) {
                # for virtual, if can't settle bet due to missing market data, sell contract with buy price
                @{$bet}{qw/sell_price sell_time/} = ($bet->{buy_price}, $now->db_timestamp);
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };
                #empty list for virtual
                my $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                    data_object_params => {},
                });

                push @quants_bet_variables, $quants_bet_variables;
            } else {
                $stats_failure{$logging_class}{_normalize_error($contract->primary_validation_error)}++;
                $failure->{reason} = $contract->primary_validation_error->message;
                push @{$result->{failures}}, $failure;
            }
        }
        catch {
            warn 'SellExpiredContract Exception: ' . __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it
        };
    }

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::Platform::Config::env;
    my $sell_type = (defined $source and exists $source_to_sell_type{$source}) ? $source_to_sell_type{$source} : 'expired';
    my @tags      = ("broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "sell_type:$sell_type");

    for my $class (keys %stats_attempt) {
        stats_count("transaction.sell.attempt", $stats_attempt{$class}, {tags => [@tags, "contract_class:$class"]});
    }
    for my $class (keys %stats_failure) {
        for my $reason (keys %{$stats_failure{$class}}) {
            stats_count(
                "transaction.sell.failure",
                $stats_failure{$class}{$reason},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error($reason)]});
        }
    }

    return $result unless @bets_to_sell;    # nothing to do

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        transaction_data => \@transdata,
        bet_data         => \@bets_to_sell,
        account_data     => {
            client_loginid => $loginid,
            currency_code  => $currency
        },
        db                   => BOM::Database::ClientDB->new({broker_code => $client->broker_code})->db,
        quants_bet_variables => \@quants_bet_variables,
    );

    my $sold = try {
        $fmb_helper->batch_sell_bet;
    }
    catch {
        warn(ref eq 'ARRAY' ? "@$_" : "$_");
        return 0;
    };

    if (not $sold or @bets_to_sell > @$sold) {
        # We missed some, let's figure out which ones they are.
        my %sold_fmbs = map { $_->{fmb}->{id} => 1 } @{$sold // []};
        my %missed;
        foreach my $bet (@bets_to_sell) {
            next if $sold_fmbs{$bet->{id}};    # Was not missed.
            $missed{$bet->{bet_class}}++;
            push @{$result->{failures}},
                {
                fmb_id => $bet->{id},
                reason => _normalize_error("TransactionFailure")};
        }
        foreach my $class (keys %missed) {
            stats_count("transaction.sell.failure", $missed{$class},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error("TransactionFailure")]});

        }
    }

    return $result unless $sold and @$sold;    # nothing has been sold

    my $skip_contract  = @$bets - @$sold;
    my $total_credited = 0;
    my %stats_success;
    for my $t (@$sold) {
        $total_credited += $t->{txn}->{amount};
        $stats_success{$t->{fmb}->{bet_class}}->[0]++;
        $stats_success{$t->{fmb}->{bet_class}}->[1] += $t->{txn}->{amount};
    }
    for my $class (keys %stats_success) {
        stats_count("transaction.sell.success", $stats_success{$class}->[0], {tags => [@tags, "contract_class:$class"]});
    }

    $result->{skip_contract}       = $skip_contract;
    $result->{total_credited}      = $total_credited;
    $result->{number_of_sold_bets} = 0 + @$sold;
    return $result;
}

sub report {
    my $self = shift;
    return
          "Transaction Report:\n"
        . sprintf("%30s: %s\n", 'Client',                 $self->client)
        . sprintf("%30s: %s\n", 'Contract',               $self->contract->code)
        . sprintf("%30s: %s\n", 'Price',                  $self->price)
        . sprintf("%30s: %s\n", 'Payout',                 $self->payout)
        . sprintf("%30s: %s\n", 'Amount Type',            $self->amount_type)
        . sprintf("%30s: %s\n", 'Comment',                $self->comment->[0] || '')
        . sprintf("%30s: %s\n", 'Staff',                  $self->staff)
        . sprintf("%30s: %s",   'Transaction Parameters', Dumper($self->transaction_parameters))
        . sprintf("%30s: %s\n", 'Transaction ID',         $self->transaction_id || -1)
        . sprintf("%30s: %s\n", 'Purchase Date',          $self->purchase_date->datetime_yyyymmdd_hhmmss);
}

sub _get_params_for_expiryqueue {
    my $self = shift;

    my $contract = $self->contract;

    my $hash = {
        purchase_price        => $self->price,
        transaction_reference => $self->transaction_id,
        held_by               => $self->client->loginid,
        contract_id           => $self->contract_id,
        in_currency           => $contract->currency,
        symbol                => $contract->underlying->symbol,
    };

    if ($contract->is_spread) {
        # The barriers for spreads are the stop loss/profit level
        # There is no settlement
        @{$hash}{qw/up_level down_level/} = @{$contract->_highlow_args};
    } else {
        # These-are all non-exclusive conditions, we don't care if anything is
        # sold to which they all apply.
        $hash->{settlement_epoch} = $contract->date_settlement->epoch;
        # if we were to enable back the intraday path dependent, the barrier saved
        # in expiry queue might be wrong, since barrier is set based on next tick.
        if ($contract->is_path_dependent) {
            # just check one barrier type since they are not allowed to be different.
            if ($contract->two_barriers and $contract->high_barrier->barrier_type eq 'absolute') {
                $hash->{up_level}   = $contract->high_barrier->as_absolute;
                $hash->{down_level} = $contract->low_barrier->as_absolute;
            } elsif ($contract->barrier and $contract->barrier->barrier_type eq 'absolute') {
                my $which_level = ($contract->barrier->as_difference > 0) ? 'up_level' : 'down_level';
                $hash->{$which_level} = $contract->barrier->as_absolute;
            }
        }

        $hash->{tick_count} = $contract->tick_count if $contract->tick_expiry;
    }

    return $hash;
}

sub _get_list_for_expiryqueue {
    my $full_list = shift;

    my @eq_list = ();
    foreach my $elm (@$full_list) {
        next if $elm->{code};
        push @eq_list,
            {
            contract_id           => $elm->{fmb}->{id},
            held_by               => $elm->{loginid},
            transaction_reference => $elm->{txn}->{id},
            };
    }

    return \@eq_list;
}

no Moose;

__PACKAGE__->meta->make_immutable;

1;
