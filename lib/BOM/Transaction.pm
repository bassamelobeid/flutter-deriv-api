package BOM::Transaction;

use Moose;
use Data::Dumper;
use Error::Base;
use Path::Tiny;
use Scalar::Util qw(blessed);
use Time::HiRes qw(tv_interval gettimeofday time);

use JSON qw( from_json to_json );
use Date::Utility;
use ExpiryQueue qw( enqueue_new_transaction enqueue_multiple_new_transactions );
use Format::Util::Numbers qw(commas roundnear to_monetary_number_format);
use Try::Tiny;

use DataDog::DogStatsd::Helper qw(stats_inc stats_timing stats_count);

use Brands;
use Client::Account;

use Finance::Asset::Market::Types;

use BOM::Platform::Context qw(localize request);

use BOM::Platform::Config;
use BOM::Product::ContractFactory qw( produce_contract make_similar_contract );
use BOM::Database::DataMapper::Payment;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::FinancialMarketBet;
use BOM::Database::ClientDB;
use BOM::Database::Model::Account;
use BOM::Database::Model::DataCollection::QuantsBetVariables;
use BOM::Database::Model::Constants;
use BOM::Database::Helper::FinancialMarketBet;
use BOM::Database::Helper::RejectedTrade;
use BOM::Database::ClientDB;
use BOM::Transaction::Validation;

has client => (
    is  => 'ro',
    isa => 'Client::Account',
);

has multiple => (
    is  => 'ro',
    isa => 'Maybe[ArrayRef]',
);

has contract => (
    is => 'rw',
);

has price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

# price_slippage is the price difference between the requested buy or sell price from the recomputed price.
# If the slippage is within the acceptable amount, 50% of commission then we will honour the requested price.
has price_slippage => (
    is      => 'rw',
    default => 0,
);

# trading period of a contract
has trading_period_start => (
    is     => 'rw',
    isa    => 'date_object',
    coerce => 1,
);

# This is the requested buy or sell price
has requested_price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

# This is the recomputed buy or sell price
has recomputed_price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has transaction_record => (
    is         => 'ro',
    isa        => 'BOM::Database::AutoGenerated::Rose::Transaction',
    lazy_build => 1,
);

sub _build_transaction_record {
    my $self = shift;
    my $id = $self->transaction_id || die 'transaction not written yet';
    return $self->client->default_account->find_transaction({id => $id})->[0];
}

has balance_after => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has limits => (
    is      => 'rw',
    isa     => 'HashRef',
    default => sub { +{} },
);

has payout => (
    is         => 'rw',
    isa        => 'Num',
    lazy_build => 1,
);

sub _build_payout {
    my $self = shift;
    return $self->contract->payout;
}

has amount_type => (
    is         => 'rw',
    isa        => 'Str',
    lazy_build => 1,
);

sub _build_amount_type {
    my $self = shift;
    die 'amount type is required';
}

has comment => (
    is      => 'rw',
    isa     => 'ArrayRef',
    default => sub { [] },
);

has staff => (
    is         => 'rw',
    isa        => 'Str',
    lazy_build => 1,
);

sub _build_staff {
    my $self = shift;
    return $self->client->loginid;
}

has transaction_id => (
    is  => 'rw',
    isa => 'Int',
);

### For sell operations only
has reference_id => (
    is  => 'rw',
    isa => 'Int',
);

has contract_id => (
    is  => 'rw',
    isa => 'Int',
);

has execute_at_better_price => (
    is      => 'rw',
    isa     => 'Bool',
    default => 0,
);

# calling server should capture time of request
has purchase_date => (
    is     => 'rw',
    isa    => 'date_object',
    coerce => 1,
);

has contract_class => (
    is  => 'rw',
    isa => 'Str',
);

has source => (
    is  => 'ro',
    isa => 'Maybe[Int]',
);

has transaction_parameters => (
    is      => 'ro',
    isa     => 'HashRef',
    default => sub { {}; },
);

sub BUILDARGS {
    my ($class, $args) = @_;

    if (exists $args->{price}) {
        $args->{transaction_parameters}->{price} = $args->{price};
    }
    if (exists $args->{payout}) {
        $args->{transaction_parameters}->{payout} = $args->{payout};
    }
    return $args;
}

my %known_errors;              # forward declaration
sub sell_expired_contracts;    # forward declaration

sub stats_start {
    my $self = shift;
    my $what = shift;

    my $client   = $self->client;
    my $contract = $self->contract;

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::Platform::Config::env;
    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    my $tags      = {tags => ["broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "contract_class:$bet_class",]};

    if ($what eq 'buy' or $what eq 'batch_buy') {
        push @{$tags->{tags}}, "amount_type:" . lc($self->amount_type), "expiry_type:" . ($contract->fixed_expiry ? 'fixed' : 'duration');
    } elsif ($what eq 'sell') {
        push @{$tags->{tags}}, "sell_type:manual";
    }
    stats_inc("transaction.$what.attempt", $tags);

    return +{
        start   => [gettimeofday],
        tags    => $tags,
        virtual => $virtual,
        rmgenv  => $rmgenv,
        what    => $what,
    };
}

sub stats_validation_done {
    my $self = shift;
    my $data = shift;

    $data->{validation_done} = [gettimeofday];

    return;
}

# Given a generic error, try to turn it into a tag-friendly string which
# might be the same across multiple failures.
sub _normalize_error {
    my $error = shift;

    if (my $whatsit = blessed $error) {
        if ($whatsit eq 'Error::Base') {
            my $type = $error->get_type;    # These are nice short camelCase descriptions
            $error = (
                       $type eq 'InvalidtoBuy'
                    or $type eq 'InvalidtoSell'
            ) ? $error->get_mesg : $type;    # In these special cases, we'd like to get the underlying contract message, instead.
        } elsif ($whatsit eq 'MooseX::Role::Validatable::Error') {
            $error = $error->message;        # These should be sentence-like.
        } else {
            $error = "$error";               # Assume it's stringifiable.
        }
    }

    $error =~ s/(?<=[^A-Z])([A-Z])/ $1/g;    # camelCase to words
    $error =~ s/\[[^\]]+\]//g;               # Bits between [] should be dynamic
    $error = join('_', split /\s+/, lc $error);

    return $error;
}

sub stats_stop {
    my ($self, $data, $error, $extra) = @_;

    my $what = $data->{what};
    my $tags = $data->{tags};

    if ($error) {
        stats_inc("transaction.$what.failure", {tags => [@{$tags->{tags}}, 'reason:' . _normalize_error($error)]});

        return $error;
    }

    my $now = [gettimeofday];
    stats_timing("transaction.$what.elapsed_time", 1000 * tv_interval($data->{start},           $now), $tags);
    stats_timing("transaction.$what.db_time",      1000 * tv_interval($data->{validation_done}, $now), $tags);
    stats_inc("transaction.$what.success", $tags);

    if ($what eq 'batch_buy') {
        my @tags = grep { !/^(?:broker|virtual):/ } @{$tags->{tags}};
        for my $broker (keys %$extra) {
            my $xd = $extra->{$broker};
            my $tags = {tags => ["broker:" . lc($broker), "virtual:" . ($broker =~ /^VR/ ? "yes" : "no"), @tags]};
            stats_count("transaction.buy.attempt", $xd->{attempt}, $tags);
            stats_count("transaction.buy.success", $xd->{success}, $tags);
        }
        return;
    }
    return;
}

sub calculate_limits {
    my $self = shift;
    my $client = shift || $self->client;

    my %limits;

    my $static_config = BOM::Platform::Config::quants;

    my $contract = $self->contract;
    my $currency = $contract->currency;

    $limits{max_balance} = $client->get_limit_for_account_balance;

    if (not $contract->tick_expiry) {
        $limits{max_open_bets}        = $client->get_limit_for_open_positions;
        $limits{max_payout_open_bets} = $client->get_limit_for_payout;
        $limits{max_payout_per_symbol_and_bet_type} =
            $static_config->{bet_limits}->{open_positions_payout_per_symbol_and_bet_type_limit}->{$currency};
    }

    my $lim;
    defined($lim = $client->get_limit_for_daily_losses)
        and $limits{max_losses} = $lim;
    defined($lim = $client->get_limit_for_7day_turnover)
        and $limits{max_7day_turnover} = $lim;
    defined($lim = $client->get_limit_for_7day_losses)
        and $limits{max_7day_losses} = $lim;
    defined($lim = $client->get_limit_for_30day_turnover)
        and $limits{max_30day_turnover} = $lim;
    defined($lim = $client->get_limit_for_30day_losses)
        and $limits{max_30day_losses} = $lim;

    $limits{max_turnover} = $client->get_limit_for_daily_turnover;

    my $rp = $contract->risk_profile;
    my @cl_rp = $rp->get_client_profiles($client->loginid, $client->landing_company->short);
    push @{$limits{specific_turnover_limits}}, @{$rp->get_turnover_limit_parameters(\@cl_rp)};

    return \%limits;
}

sub prepare_bet_data_for_buy {
    my $self = shift;

    my $client   = $self->client;
    my $contract = $self->contract;

    if ($self->purchase_date->is_after($contract->date_start)) {
        my $d1 = $self->purchase_date->datetime_yyyymmdd_hhmmss;
        my $d2 = $contract->date_start->datetime_yyyymmdd_hhmmss;
        return Error::Base->cuss(
            -type              => 'ContractAlreadyStarted',
            -mesg              => "buy at $d1 too late for $d2 contract",
            -message_to_client => BOM::Platform::Context::localize("Start time is in the past"));
    }

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};

    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        quantity          => 1,
        short_code        => scalar $contract->shortcode,
        buy_price         => $self->price,
        remark            => $self->comment->[0] || '',
        underlying_symbol => scalar $contract->underlying->symbol,
        bet_type          => scalar $contract->code,
        bet_class         => $bet_class,
        purchase_time     => scalar $self->purchase_date->db_timestamp,
        start_time        => scalar $contract->date_start->db_timestamp,
        expiry_time       => scalar $contract->date_expiry->db_timestamp,
        settlement_time   => scalar $contract->date_settlement->db_timestamp,
        payout_price      => scalar $self->payout,
    };

    $bet_params->{expiry_daily} = 1 if $contract->expiry_daily;
    $bet_params->{fixed_expiry} = 1 if $contract->fixed_expiry;
    if ($contract->tick_expiry) {
        $bet_params->{tick_expiry} = 1;
        $bet_params->{tick_count}  = scalar $contract->tick_count;
    }

    if ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_HIGHER_LOWER_BET) {
        # only store barrier in the database if it is defined.
        # asian contracts have barriers at/after expiry.
        if ($contract->barrier) {
            $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
        }
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_DIGIT_BET) {
        $bet_params->{prediction} = $contract->sentiment;
        $bet_params->{last_digit} = $contract->barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_RANGE_BET) {
        $bet_params->{$contract->high_barrier->barrier_type . '_higher_barrier'} = $contract->high_barrier->supplied_barrier;
        $bet_params->{$contract->low_barrier->barrier_type . '_lower_barrier'}   = $contract->low_barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_TOUCH_BET) {
        $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
    } else {
        return Error::Base->cuss(
            -type              => 'UnsupportedBetClass',
            -mesg              => "Unsupported bet class $bet_params->{bet_class}",
            -message_to_client => BOM::Platform::Context::localize("Unsupported bet class $bet_params->{bet_class}"),
        );
    }

    my $quants_bet_variables;
    if (my $comment_hash = $self->comment->[1]) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $comment_hash,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
                app_markup    => $self->contract->app_markup_dollar_amount,
            },
            bet_data             => $bet_params,
            quants_bet_variables => $quants_bet_variables,
        });
}

sub prepare_buy {
    my ($self, $skip) = @_;

    if ($self->multiple) {
        for my $m (@{$self->multiple}) {
            next if $m->{code};
            $m->{limits} = $self->calculate_limits($m->{client});
            my $c = try { Client::Account->new({loginid => $m->{loginid}}) };
            unless ($c) {
                $m->{code}  = 'InvalidLoginid';
                $m->{error} = BOM::Platform::Context::localize('Invalid loginid');
                next;
            }

            $m->{client} = $c;
        }
    }

    return $self->prepare_bet_data_for_buy if $skip;

    $self->limits($self->calculate_limits) unless $self->multiple;
    my @clients = map { $_->{client} } grep { ref $_->{client} } @{$self->multiple || []};
    @clients = ($self->client) unless scalar @clients;

    my $error_status = BOM::Transaction::Validation->new({
            transaction => $self,
            clients     => \@clients,
        })->validate_trx_buy();

    return $error_status if $error_status;

    $self->comment(
        _build_pricing_comment({
                contract         => $self->contract,
                price            => $self->price,
                requested_price  => $self->requested_price,
                recomputed_price => $self->recomputed_price,
                ($self->price_slippage) ? (price_slippage => $self->price_slippage) : (),
                ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                action => 'buy'
            })) unless @{$self->comment};

    return $self->prepare_bet_data_for_buy;
}

sub buy {
    my ($self, %options) = @_;

    my $stats_data = $self->stats_start('buy');

    my ($error_status, $bet_data) = $self->prepare_buy($options{skip_validation});
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        account_data => {
            client_loginid => $self->client->loginid,
            currency_code  => $self->contract->currency,
        },
        limits => $self->limits,
        db     => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $error = 1;
    my ($fmb, $txn);
    try {
        ($fmb, $txn) = $fmb_helper->buy_bet;
        $error = 0;
    }
    catch {
        # if $error_status is defined, return it
        # otherwise the function re-throws the exception
        $error_status = $self->_recover($_);
    };
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});
    $self->contract_id($fmb->{id});

    enqueue_new_transaction(_get_params_for_expiryqueue($self));    # For soft realtime expiration notification.

    return;
}

# expected parameters:
# $self->multiple
#   an array of hashes. Elements with a key "code" are ignored. They are
#   thought to be already erroneous. Otherwise the element should contain
#   a "loginid" key.
#   The following keys are added:
#   * client: the Client::Account object corresponding to the loginid
#   * limits: a hash representing the betting limits of this client
#   * fmb and txn: the FMB and transaction records that have been written
#     to the database in case of success
#   * code and error: in case of an error during the transaction these keys
#     contain the error description corresponding to the usual -type and
#     -message_to_client members of an Error::Base object.
# $self->contract
#   the contract
# $self->staff
# $self->source
# ...
#
# set or modified during operation:
# $self->price
#   the price
# @{$self->multiple}
#   see above
#
# return value:
#   - empty list on success. Success means the database function has been called.
#     It does not mean any contract has been bought.
#   - an Error::Base object indicates that something more fundamental went wrong.
#     For instance the contract's start date may be in the past.
#
# Exceptions:
#   The function may throw exceptions. However, it is guaranteed that after
#   contract validation no exception whatsoever is thrown. That means there
#   is no way for a contract to be bought but not reported back to the caller.

sub batch_buy {
    my ($self, %options) = @_;

    # TODO: shall we allow this operation only if $self->client is real-money?
    #       Or allow virtual $self->client only if all other clients are also
    #       virtual?

    my $stats_data = $self->stats_start('batch_buy');

    my ($error_status, $bet_data) = $self->prepare_buy($options{skip_validation});

    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my %per_broker;
    for my $m (@{$self->multiple}) {
        next if $m->{code};
        push @{$per_broker{$m->{client}->broker_code}}, $m;
    }

    my %stat = map { $_ => {attempt => 0 + @{$per_broker{$_}}} } keys %per_broker;

    for my $broker (keys %per_broker) {
        my $list = $per_broker{$broker};
        # with hash key caching introduced in recent perl versions
        # the "map sort map" pattern does not make sense anymore.

        # this sorting is to prevent deadlocks in the database
        @$list = sort { $a->{loginid} cmp $b->{loginid} } @$list;

        my @general_error = ('UnexpectedError', BOM::Platform::Context::localize('An unexpected error occurred'));

        try {
            my $currency   = $self->contract->currency;
            my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
                %$bet_data,
                # great readablility provided by our tidy rules
                account_data => [map                                      { +{client_loginid => $_->{loginid}, currency_code => $currency} } @$list],
                limits       => [map                                      { $_->{limits} } @$list],
                db           => BOM::Database::ClientDB->new({broker_code => $broker})->db,
            );

            my $success = 0;
            my $result  = $fmb_helper->batch_buy_bet;
            for my $el (@$list) {
                my $res = shift @$result;
                if (my $ecode = $res->{e_code}) {
                    # map DB errors to client messages
                    if (my $ref = $known_errors{$ecode}) {
                        my $error = (
                            ref $ref eq 'CODE'
                            ? $ref->($self, $el->{client}, $res->{e_description})
                            : $ref
                        );
                        $el->{code}  = $error->{-type};
                        $el->{error} = $error->{-message_to_client};
                    } else {
                        @{$el}{qw/code error/} = @general_error;
                    }
                } else {
                    $el->{fmb} = $res->{fmb};
                    $el->{txn} = $res->{txn};
                    $success++;
                }
            }
            $stat{$broker}->{success} = $success;
            enqueue_multiple_new_transactions(_get_params_for_expiryqueue($self), _get_list_for_expiryqueue($list));
        }
        catch {
            warn __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it

            for my $el (@$list) {
                @{$el}{qw/code error/} = @general_error unless $el->{code} or $el->{fmb};
            }
        };
    }

    $self->stats_stop($stats_data, undef, \%stat);

    return;
}

sub prepare_bet_data_for_sell {
    my $self = shift;
    my $contract = shift || $self->contract;

    my $client   = $self->client;
    my $loginid  = $client->loginid;
    my $currency = $contract->currency;

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        id         => scalar $self->contract_id,
        sell_price => scalar $self->price,
        sell_time  => scalar $contract->date_pricing->db_timestamp,
        $contract->category_code eq 'asian' && $contract->is_after_settlement
        ? (absolute_barrier => scalar $contract->barrier->as_absolute)
        : (),
    };

    my $quants_bet_variables;
    if (my $comment_hash = $self->comment->[1]) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $comment_hash,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
            },
            bet_data             => $bet_params,
            quants_bet_variables => $quants_bet_variables,
        });
}

sub prepare_sell {
    my ($self, $skip) = @_;

    if ($self->multiple) {
        for my $m (@{$self->multiple}) {
            next if $m->{code};
            my $c = try { Client::Account->new({loginid => $m->{loginid}}) };
            unless ($c) {
                $m->{code}  = 'InvalidLoginid';
                $m->{error} = BOM::Platform::Context::localize('Invalid loginid');
                next;
            }

            $m->{client} = $c;
        }
    }

    return $self->prepare_bet_data_for_sell if $skip;

    ### Prepare clients list, get uniq only...
    my @clients = map { $_->{client} } grep { ref $_->{client} } @{$self->multiple || []};
    @clients = ($self->client) unless scalar @clients;

    my $error_status = BOM::Transaction::Validation->new({
            transaction => $self,
            clients     => \@clients,
        })->validate_trx_sell();

    return $error_status if $error_status;

    $self->comment(
        _build_pricing_comment({
                contract         => $self->contract,
                price            => $self->price,
                requested_price  => $self->requested_price,
                recomputed_price => $self->recomputed_price,
                ($self->price_slippage) ? (price_slippage => $self->price_slippage) : (),
                ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                action => 'sell'
            })) unless @{$self->comment};

    return $self->prepare_bet_data_for_sell;
}

sub sell {
    my ($self, %options) = @_;

    my $stats_data = $self->stats_start('sell');

    my ($error_status, $bet_data) = $self->prepare_sell($options{skip_validation});
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $bet_data->{account_data} = {
        client_loginid => $self->client->loginid,
        currency_code  => $self->contract->currency,
    };

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $error = 1;
    my ($fmb, $txn, $buy_txn_id);
    try {
        ($fmb, $txn, $buy_txn_id) = $fmb_helper->sell_bet;
        $error = 0;
    }
    catch {
        # if $error_status is defined, return it
        # otherwise the function re-throws the exception
        $error_status = $self->_recover($_);
    };
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'NoOpenPosition',
            -mesg              => 'No such open contract.',
            -message_to_client => BOM::Platform::Context::localize('This contract was not found among your open positions.'),
        )) unless defined $txn->{id} && defined $buy_txn_id;

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});
    $self->reference_id($buy_txn_id);

    return;
}

sub sell_by_shortcode {
    my ($self, %options) = @_;

    my $stats_data = $self->stats_start('sell');

    my ($error_status, $bet_data) = $self->prepare_sell($options{skip});

    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $currency = $self->contract->currency;

    my %per_broker;
    for my $m (@{$self->multiple}) {
        next if $m->{code};
        push @{$per_broker{$m->{client}->broker_code}}, $m;
    }

    my %stat = map { $_ => {attempt => 0 + @{$per_broker{$_}}} } keys %per_broker;

    for my $broker (keys %per_broker) {
        my $list    = $per_broker{$broker};
        my $success = 0;
        # with hash key caching introduced in recent perl versions
        # the "map sort map" pattern does not make sense anymore.

        # this sorting is to prevent deadlocks in the database
        @$list = sort { $a->{loginid} cmp $b->{loginid} } @$list;

        my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
            %$bet_data,
            account_data => [map                                      { +{client_loginid => $_->{loginid}, currency_code => $currency} } @$list],
            db           => BOM::Database::ClientDB->new({broker_code => $broker})->db,
        );
        try {
            my $res = $fmb_helper->sell_by_shortcode($self->contract->shortcode);

            foreach my $r (@$list) {
                my $res_row = shift @$res;
                if (my $ecode = $res_row->{e_code}) {
                    # map DB errors to client messages
                    if (my $ref = $known_errors{$ecode}) {
                        my $error = (
                            ref $ref eq 'CODE'
                            ? $ref->($self, $r->{client}, $res_row->{e_description})
                            : $ref
                        );

                        $r->{code}  = $error->{-type};
                        $r->{error} = $error->{-message_to_client};
                    } else {
                        @{$r}{qw/code error/} = ('UnexpectedError' . $ecode, BOM::Platform::Context::localize('An unexpected error occurred'));
                    }
                } else {
                    $r->{tnx}       = $res_row->{txn};
                    $r->{fmb}       = $res_row->{fmb};
                    $r->{buy_tr_id} = $res_row->{buy_tr_id};
                    $success++;
                }
            }
            $stat{$broker}->{success} = $success;
        }
        catch {
            warn __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it
            for my $el (@$list) {
                @{$el}{qw/code error/} = ('UnexpectedError', BOM::Platform::Context::localize('An unexpected error occurred'))
                    unless $el->{code} or $el->{fmb};
            }
        };
    }

    $self->stats_stop($stats_data, undef, \%stat);

    return;
}

=head2 C<< $self->_recover($error) >>

This function tries to recover from an unsuccessful buy/sell.
It may decide to retry the operation. And it may decide to
sell expired bets before doing so.

=head4 Parameters

=over 4

=item * C<< $error >>
the error exception thrown by BOM::Platform::Data::Persistence::DB::_handle_errors

=back

=head3 Return Value

L<Error::Base> object
which means an unrecoverable but expected condition has been found.
Typically that means a precondition, like sufficient balance, was
not met.

=head3 Exceptions

In case of an unexpected error, the exception is re-thrown unmodified.

=cut

%known_errors = (
    BI001 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_daily_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchasing this contract will cause you to exceed your daily turnover limit of [_1][_2].',
            $currency, $limit);
        if (not $client->client_fully_authenticated) {
            $error_message .= ' ' . BOM::Platform::Context::localize('If you wish to raise these limits, please authenticate your account.');
        }

        return Error::Base->cuss(
            -type              => 'DailyTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a daily turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI002 => sub {
        my $self   = shift;
        my $client = shift;

        my $limit = $client->get_limit_for_open_positions;
        return Error::Base->cuss(
            -type              => 'OpenPositionLimit',
            -mesg              => "Client has reached the limit of $limit open positions.",
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, you cannot hold more than [_1] contracts at a given time. Please visit the statement page to automatically sell your expired contracts.',
                $limit
            ),
        );
    },
    BI003 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $account  = BOM::Database::DataMapper::Account->new({
            client_loginid => $client->loginid,
            currency_code  => $currency,
        });
        my $balance = $currency eq 'JPY' ? commas($account->get_balance(), 0) : to_monetary_number_format($account->get_balance());
        my $price   = $currency eq 'JPY' ? commas($self->price,            0) : to_monetary_number_format($self->price);

        return Error::Base->cuss(
            -type              => 'InsufficientBalance',
            -message           => 'Client\'s account balance was insufficient to buy bet.',
            -message_to_client => BOM::Platform::Context::localize(
                'Your account balance ([_1][_2]) is insufficient to buy this contract ([_1][_3]).',
                $currency, $balance, $price
            ));
    },
    BI007 => sub {
        my $self   = shift;
        my $client = shift;

        return Error::Base->cuss(
            -type              => 'PotentialPayoutLimitForSameContractExceeded',
            -mesg              => "Client has exceeded potential payout limit for open contracts with the same symbol and bet_type",
            -message_to_client => BOM::Platform::Context::localize(
                'Purchasing this contract will cause you to exceed our payout limit for open contracts of this type. To continue, please sell some of your open contracts or trade in different contract types.'
            ),
        );
    },
    BI008 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_account_balance, 1);

        my $account = BOM::Database::DataMapper::Account->new({
            client_loginid => $client->loginid,
            currency_code  => $currency,
        });
        my $balance = $account->get_balance();

        return Error::Base->cuss(
            -type              => 'AccountBalanceExceedsLimit',
            -mesg              => 'Client balance is above the allowed limits',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, your account cash balance is too high ([_1]). Your maximum account balance is [_2].', "$currency$balance",
                "$currency$limit"
            ),
        );
    },
    BI009 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_payout, 1);

        return Error::Base->cuss(
            -type              => 'OpenPositionPayoutLimit',
            -mesg              => 'Client has reached maximum net payout for open positions',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, the aggregate payouts of contracts on your account cannot exceed [_1][_2].',
                $currency, $limit
            ),
        );
    },
    BI010 => Error::Base->cuss(
        -type              => 'PromoCodeLimitExceeded',
        -mesg              => 'Client won more than 25 times of the promo code amount',
        -message_to_client => BOM::Platform::Context::localize(
            'Your account has exceeded the trading limit with free promo code, please deposit if you wish to continue trading.'),
    ),
    BI011 => sub {
        my $self   = shift;
        my $client = shift;
        my $msg    = shift;

        my $limit_name = 'Unknown';
        $msg =~ /^.+: ([^,]+)/ and $limit_name = $1;

        return Error::Base->cuss(
            -type              => $limit_name . 'Exceeded',
            -mesg              => 'Exceeds turnover limit on ' . $limit_name,
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI012 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_daily_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your daily limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => 'DailyLossLimitExceeded',
            -mesg              => "Client has exceeded his daily loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI013 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_7day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchasing this contract will cause you to exceed your 7-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 7-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI014 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_7day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 7-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 7-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    # BI015 deprecated as spread is removed
    BI016 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_30day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchasing this contract will cause you to exceed your 30-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 30-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI017 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_30day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 30-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 30-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI018 => sub {
        my $self   = shift;
        my $client = shift;

        return Error::Base->cuss(
            -type              => 'DailyProfitLimitExceeded',
            -mesg              => 'Exceeds daily profit limit',
            -message_to_client => BOM::Platform::Context::localize('No further trading is allowed for the current trading session.'),
        );
    },
    BI050 => sub {
        my $self   = shift;
        my $client = shift;
        my $msg    = shift;

        Error::Base->cuss(
            -type              => 'NoOpenPosition',
            -mesg              => $msg,
            -message_to_client => BOM::Platform::Context::localize('This contract was not found among your open positions.'),
        );
    },
    BI103 => Error::Base->cuss(
        -type              => 'RoundingExceedPermittedEpsilon',
        -mesg              => 'Rounding exceed permitted epsilon',
        -message_to_client => BOM::Platform::Context::localize('Only a maximum of two decimal points are allowed for the amount.'),
    ),
);

sub _recover {
    my $self   = shift;
    my $err    = shift;
    my $client = shift;
    if (blessed($self)) {
        $client //= $self->client;
    }

    if (ref($err) eq 'ARRAY') {    # special BINARY code
        my $ref = $known_errors{$err->[0]};
        return ref $ref eq 'CODE' ? $ref->($self, $client, $err->[1]) : $ref if $ref;
    } else {
        # TODO: recover from deadlocks & co.
    }
    die $err;
}

sub format_error {
    my ($self, %args) = @_;
    my $err           = $args{err};
    my $client        = $args{client};
    my $type          = $args{type} // 'InternalError';             # maybe caller know the type. If the err cannot be parsed, then we use this value
    my $msg           = Dumper($err);
    my $msg_to_client = $args{msg_to_client} // 'Internal Error';
    return try {
        return $self->_recover($err, $client);
    }
    catch {
        return Error::Base->cuss(
            -type              => $type,
            -mesg              => $msg,
            -message_to_client => BOM::Platform::Context::localize($msg_to_client),
        );
    }
}

sub _build_pricing_comment {
    my $args = shift;

    my ($contract, $price, $action, $price_slippage, $requested_price, $recomputed_price, $trading_period_start) =
        @{$args}{'contract', 'price', 'action', 'price_slippage', 'requested_price', 'recomputed_price', 'trading_period_start'};

    my @comment_fields = @{$contract->pricing_details($action)};

    # only manual sell and buy has a price
    if ($price) {
        push @comment_fields, (trade => $price);
    }

    # Record price slippage in quants bet variable.
    # To always reproduce ask price, we would want to record the slippage allowed during transaction.
    if (defined $price_slippage) {
        push @comment_fields, (price_slippage => $price_slippage);
    }

    # Record requested price in quants bet variable.
    if (defined $requested_price) {
        push @comment_fields, (requested_price => $requested_price);
    }

    # Record recomputed price in quants bet variable.
    if (defined $recomputed_price) {
        push @comment_fields, (recomputed_price => $recomputed_price);
    }

    my $comment_str = sprintf join(' ', ('%s[%0.5f]') x (@comment_fields / 2)), @comment_fields;

    if (defined $trading_period_start) {
        push @comment_fields, (trading_period_start => $trading_period_start);
    }

    my %comment_hash = map { $_ } @comment_fields;

    return [$comment_str, \%comment_hash];
}

=head2 sell_expired_contracts
Static function: Sells expired contracts.
For contracts with missing market data, settle them manually for real money accounts, but sell with purchase price for virtual account
Returns: HashRef, with:
'total_credited', total amount credited to Client
'skip_contract', count for expired contracts that failed to be sold
'failures', the failure information
=cut

my %source_to_sell_type = (
    2 => 'expiryd',    # app id for `Binary.com expiryd.pl` in auth db => oauth.apps table
);

sub sell_expired_contracts {
    my $args         = shift;
    my $client       = $args->{client};
    my $source       = $args->{source};
    my $contract_ids = $args->{contract_ids};

    my $time_start = Time::HiRes::time;

    my $currency = $client->currency;
    my $loginid  = $client->loginid;

    my $result = {
        skip_contract => $contract_ids ? (scalar @$contract_ids) : 0,
        total_credited      => 0,
        number_of_sold_bets => 0,
        failures            => [],
    };

    my $mapper = BOM::Database::DataMapper::FinancialMarketBet->new({
        client_loginid => $loginid,
        currency_code  => $currency,
        broker_code    => $client->broker_code,
        operation      => 'replica',
    });

    my $clientdb = BOM::Database::ClientDB->new({
        broker_code => $client->broker_code,
        operation   => 'replica',
    });

    my $bets =
          (defined $contract_ids)
        ? [map { $_->financial_market_bet_record } @{$mapper->get_fmb_by_id($contract_ids)}]
        : $clientdb->getall_arrayref('select * from bet.get_open_bets_of_account(?,?,?)',
        [$client->loginid, $client->currency, ($args->{only_expired} ? 'true' : 'false')]);

    return $result unless $bets and @$bets;

    my $now = Date::Utility->new;
    my @bets_to_sell;
    my @quants_bet_variables;
    my @transdata;
    my %stats_attempt;
    my %stats_failure;
    for my $bet (@$bets) {
        my $contract;
        my $error;
        my $failure = {fmb_id => $bet->{id}};
        try { $contract = produce_contract($bet->{short_code}, $currency); } catch { $error = 1; };
        if ($error) {
            $failure->{reason} = 'Could not instantiate contract object';
            push @{$result->{failures}}, $failure;
            next;
        }

        my $logging_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
        $stats_attempt{$logging_class}++;
        if (not $contract->is_settleable) {
            $stats_failure{$logging_class}{'NotExpired'}++;
            $failure->{reason} = 'not expired';
            push @{$result->{failures}}, $failure;
            next;
        }

        try {
            if ($contract->is_valid_to_sell) {
                @{$bet}{qw/sell_price sell_time/} = ($contract->bid_price, $contract->date_pricing->db_timestamp);
                $bet->{absolute_barrier} = $contract->barrier->as_absolute
                    if $contract->category_code eq 'asian' and $contract->is_after_settlement;
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };

                # price_slippage will not happen to expired contract, hence not needed.
                my $comment_hash = _build_pricing_comment({
                        contract => $contract,
                        action   => 'autosell_expired_contract',
                    })->[1];
                my $quants_bet_variables;
                if ($comment_hash) {
                    $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                        data_object_params => $comment_hash,
                    });
                }
                push @quants_bet_variables, $quants_bet_variables;

            } elsif ($client->is_virtual and $now->epoch >= $contract->date_settlement->epoch + 3600) {
                # for virtual, if can't settle bet due to missing market data, sell contract with buy price
                @{$bet}{qw/sell_price sell_time/} = ($bet->{buy_price}, $now->db_timestamp);
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };
                #empty list for virtual
                my $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                    data_object_params => {},
                });

                push @quants_bet_variables, $quants_bet_variables;
            } else {
                $stats_failure{$logging_class}{_normalize_error($contract->primary_validation_error)}++;
                $failure->{reason} = $contract->primary_validation_error->message;
                push @{$result->{failures}}, $failure;
            }
        }
        catch {
            warn 'SellExpiredContract Exception: ' . __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it
        };
    }

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::Platform::Config::env;
    my $sell_type = (defined $source and exists $source_to_sell_type{$source}) ? $source_to_sell_type{$source} : 'expired';
    my @tags      = ("broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "sell_type:$sell_type");

    for my $class (keys %stats_attempt) {
        stats_count("transaction.sell.attempt", $stats_attempt{$class}, {tags => [@tags, "contract_class:$class"]});
    }
    for my $class (keys %stats_failure) {
        for my $reason (keys %{$stats_failure{$class}}) {
            stats_count(
                "transaction.sell.failure",
                $stats_failure{$class}{$reason},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error($reason)]});
        }
    }

    return $result unless @bets_to_sell;    # nothing to do

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        transaction_data => \@transdata,
        bet_data         => \@bets_to_sell,
        account_data     => {
            client_loginid => $loginid,
            currency_code  => $currency
        },
        db                   => BOM::Database::ClientDB->new({broker_code => $client->broker_code})->db,
        quants_bet_variables => \@quants_bet_variables,
    );

    my $sold = try {
        $fmb_helper->batch_sell_bet;
    }
    catch {
        warn(ref eq 'ARRAY' ? "@$_" : "$_");
        return 0;
    };

    if (not $sold or @bets_to_sell > @$sold) {
        # We missed some, let's figure out which ones they are.
        my %sold_fmbs = map { $_->{fmb}->{id} => 1 } @{$sold // []};
        my %missed;
        foreach my $bet (@bets_to_sell) {
            next if $sold_fmbs{$bet->{id}};    # Was not missed.
            $missed{$bet->{bet_class}}++;
            push @{$result->{failures}},
                {
                fmb_id => $bet->{id},
                reason => _normalize_error("TransactionFailure")};
        }
        foreach my $class (keys %missed) {
            stats_count("transaction.sell.failure", $missed{$class},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error("TransactionFailure")]});

        }
    }

    return $result unless $sold and @$sold;    # nothing has been sold

    my $skip_contract  = @$bets - @$sold;
    my $total_credited = 0;
    my %stats_success;
    for my $t (@$sold) {
        $total_credited += $t->{txn}->{amount};
        $stats_success{$t->{fmb}->{bet_class}}->[0]++;
        $stats_success{$t->{fmb}->{bet_class}}->[1] += $t->{txn}->{amount};
    }
    for my $class (keys %stats_success) {
        stats_count("transaction.sell.success", $stats_success{$class}->[0], {tags => [@tags, "contract_class:$class"]});
    }

    $result->{skip_contract}       = $skip_contract;
    $result->{total_credited}      = $total_credited;
    $result->{number_of_sold_bets} = 0 + @$sold;
    return $result;
}

sub report {
    my $self = shift;
    return
          "Transaction Report:\n"
        . sprintf("%30s: %s\n", 'Client',                 $self->client)
        . sprintf("%30s: %s\n", 'Contract',               $self->contract->code)
        . sprintf("%30s: %s\n", 'Price',                  $self->price)
        . sprintf("%30s: %s\n", 'Payout',                 $self->payout)
        . sprintf("%30s: %s\n", 'Amount Type',            $self->amount_type)
        . sprintf("%30s: %s\n", 'Comment',                $self->comment->[0] || '')
        . sprintf("%30s: %s\n", 'Staff',                  $self->staff)
        . sprintf("%30s: %s",   'Transaction Parameters', Dumper($self->transaction_parameters))
        . sprintf("%30s: %s\n", 'Transaction ID',         $self->transaction_id || -1)
        . sprintf("%30s: %s\n", 'Purchase Date',          $self->purchase_date->datetime_yyyymmdd_hhmmss);
}

sub _get_params_for_expiryqueue {
    my $self = shift;

    my $contract = $self->contract;

    my $hash = {
        purchase_price        => $self->price,
        transaction_reference => $self->transaction_id,
        held_by               => $self->client->loginid,
        contract_id           => $self->contract_id,
        in_currency           => $contract->currency,
        symbol                => $contract->underlying->symbol,
    };

    # These-are all non-exclusive conditions, we don't care if anything is
    # sold to which they all apply.
    $hash->{settlement_epoch} = $contract->date_settlement->epoch;
    # if we were to enable back the intraday path dependent, the barrier saved
    # in expiry queue might be wrong, since barrier is set based on next tick.
    if ($contract->is_path_dependent) {
        # just check one barrier type since they are not allowed to be different.
        if ($contract->two_barriers) {
            if ($contract->high_barrier->barrier_type eq 'absolute') {
                $hash->{up_level}   = $contract->high_barrier->as_absolute;
                $hash->{down_level} = $contract->low_barrier->as_absolute;
            }
        } elsif ($contract->barrier and $contract->barrier->barrier_type eq 'absolute') {
            my $which_level = ($contract->barrier->as_difference > 0) ? 'up_level' : 'down_level';
            $hash->{$which_level} = $contract->barrier->as_absolute;
        }
    }

    $hash->{tick_count} = $contract->tick_count if $contract->tick_expiry;

    return $hash;
}

sub _get_list_for_expiryqueue {
    my $full_list = shift;

    my @eq_list = ();
    foreach my $elm (@$full_list) {
        next if $elm->{code};
        push @eq_list,
            {
            contract_id           => $elm->{fmb}->{id},
            held_by               => $elm->{loginid},
            transaction_reference => $elm->{txn}->{id},
            };
    }

    return \@eq_list;
}

no Moose;

__PACKAGE__->meta->make_immutable;

1;
