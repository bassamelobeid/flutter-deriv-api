package BOM::User;

use strict;
use warnings;

use Try::Tiny;
use Date::Utility;
use List::Util qw(first);
use Carp qw(croak carp);

use BOM::User::Client;
use BOM::MT5::User::Async;
use BOM::Database::UserDB;
use BOM::User::Password;
use BOM::User::AuditLog;
use BOM::User::Static;
use BOM::Platform::Client::Utility;
use LandingCompany::Registry;

use base 'BOM::Database::AutoGenerated::Rose::Users::BinaryUser';
use BOM::Database::AutoGenerated::Rose::Users::Loginid;

sub create {
    my $class = shift;
    return $class->SUPER::new(
        db => BOM::Database::UserDB::rose_db(),
        @_
    );
}

# support either email or id or loginid
# if possible, please use $client->user method to create user. This method is only for the cases that we don't know the client.
sub new {
    my ($class, $args) = @_;
    croak "$class->new called without args" unless $args;
    croak "no email nor id or loginid" unless $args->{email} || $args->{id} || $args->{loginid};

    my $db = BOM::Database::UserDB::rose_db();

    # Lookup the given identity first as an email in BinaryUser then as a loginid in Loginid table.
    # the Rose 'new' interface does data-type checks for us and can raise exceptions.
    return try {
        my $self = BOM::Database::AutoGenerated::Rose::Users::BinaryUser->new(
            $args->{email} ? (email => lc $args->{email}) : (),
            $args->{id}    ? (id    => $args->{id})       : (),
            $args->{loginid}
            ? (
                id => BOM::Database::AutoGenerated::Rose::Users::Loginid->new(
                    loginid => $args->{loginid},
                    db      => $db,
                )->load()->binary_user_id
                )
            : (),
            db => $db,
        )->load(speculative => 1);
        bless $self, $class;
    }
    catch { undef };
}

=head2 create_client

Takes one or more named parameters:

=over 4

=item * C<landing_company> - e.g. `costarica`

=back

=cut

sub create_client {
    my ($self, %args) = @_;
    $args{broker_code} = LandingCompany::Registry::get(delete $args{landing_company} or die 'Need a valid landing company')->broker_codes->[0];
    $args{binary_user_id} = $self->id;
    my $client = BOM::User::Client->register_and_return_new_client(\%args);
    $self->add_loginid({loginid => $client->loginid});
    $self->save;
    return $client;
}

=head2 login

Check user credentials.
Returns hashref, {success => 1} if successfully authenticated user or {error => 'failed reason'} otherwise.

=cut

sub login {
    my ($self, %args) = @_;
    my $password        = $args{password}        || die "requires password argument";
    my $environment     = $args{environment}     || '';
    my $is_social_login = $args{is_social_login} || 0;

    my $error_mapping = BOM::User::Static::get_error_mapping();
    my ($error, $cfl);
    if ($cfl = $self->failed_login and $cfl->fail_count > 5 and $cfl->last_attempt->epoch > time - 300) {
        $error = $error_mapping->{LoginTooManyAttempts};
        BOM::User::AuditLog::log('failed login > 5 times', $self->email);
    } elsif (not $is_social_login and not BOM::User::Password::checkpw($password, $self->password)) {
        my $fail_count = $cfl ? $cfl->fail_count : 0;
        $self->failed_login({
            fail_count   => ++$fail_count,
            last_attempt => Date::Utility->new->datetime_yyyymmdd_hhmmss,
        });
        $self->save;
        $error = $error_mapping->{IncorrectEmailPassword};
        BOM::User::AuditLog::log('incorrect email or password', $self->email);
    }

    my @clients = $self->clients;
    unless (@clients) {
        $error = $error_mapping->{AccountUnavailable};
        BOM::User::AuditLog::log('Account disabled', $self->email);
    }

    $self->add_login_history({
        action      => 'login',
        environment => $environment,
        successful  => ($error) ? 'f' : 't'
    });
    $self->save;

    if ($error) {
        return {error => $error};
    } else {
        $cfl->delete if $cfl;    # delete client failed login
        BOM::User::AuditLog::log('successful login', $self->email);

        # gamstop is applicable for UK residence only
        my $gamstop_client = first { $_->residence eq 'gb' and $_->landing_company->short =~ /^(?:malta|iom)$/ } @clients;
        BOM::Platform::Client::Utility::set_gamstop_self_exclusion($gamstop_client) if $gamstop_client;
    }

    return {success => 1};
}

# Get my enabled client objects, in loginid order but with reals up first.  Use the replica db for speed.
# if called as $user->clients(include_disabled=>1); will include disableds.
sub clients {
    my ($self, %args) = @_;

    my @clients = @{$self->get_clients_in_sorted_order};

    my @parts;
    push @parts, $_->cookie_string foreach (@clients);

    $self->{_cookie_val} = join('+', @parts);

    # todo should be refactor
    @clients = grep { not $_->get_status('disabled') } @clients unless $args{include_disabled};

    return @clients;
}

=head2 clients_for_landing_company

get clients given special landing company short name.
    $user->clients_for_landing_company('costarica');

=cut

sub clients_for_landing_company {
    my $self      = shift;
    my $lc_short  = shift // die 'need landing_company';
    my @login_ids = keys %{$self->bom_loginid_details};
    return map { BOM::User::Client->new({loginid => $_, db_operation => 'replica'}) }
        grep { LandingCompany::Registry->get_by_loginid($_)->short eq $lc_short } @login_ids;
}

=head2 bom_loginid_details

get client non-mt5 login id details 

=cut

sub bom_loginid_details {
    my $self = shift;

    my %hash = map { $_ => {loginid => $_, broker_code => ($_ =~ /(^[a-zA-Z]+)/)} } $self->bom_loginids;
    return \%hash;
}

=head2 bom_loginids

get client non-mt5 login ids

=cut

sub bom_loginids {
    my $self = shift;
    return map { $_->loginid } grep { $_->loginid !~ /^MT\d+$/ } $self->loginid;
}

sub mt5_logins {
    my $self = shift;
    my $filter = shift || 'real|demo';
    my @mt5_logins;

    for my $login (sort map { $_->loginid } grep { $_->loginid =~ /^MT\d+$/ } $self->loginid) {
        push(@mt5_logins, $login)
            if ((
                BOM::MT5::User::Async::get_user(
                    do { $login =~ /(\d+)/; $1 }
                )->get->{group} // ''
            ) =~ /^$filter/
            );
    }

    return @mt5_logins;
}

sub loginid_list_cookie_val {
    my $self = shift;
    $self->{_cookie_val} || $self->clients;
    return $self->{_cookie_val};
}

sub get_last_successful_login_history {
    my $self = shift;

    my $last_login =
        $self->db->dbic->run(
        sub { $_->selectrow_hashref('SELECT environment, history_date FROM users.last_login WHERE binary_user_id = ?', undef, $self->{id}) });

    if ($last_login) {
        return {
            action      => 'login',
            status      => 1,
            environment => $last_login->{environment},
            epoch       => Date::Utility->new($last_login->{history_date})->epoch
        };
    }

    return;
}

=head2 get_clients_in_sorted_order

Return an ARRAY reference that is a list of clients in following order

- real enabled accounts
- virtual accounts
- self excluded accounts
- disabled accounts

=cut

sub get_clients_in_sorted_order {
    my ($self) = @_;
    my $account_lists = $self->accounts_by_category([$self->bom_loginids]);

    return [map { @$_ } @{$account_lists}{qw(enabled virtual self_excluded disabled)}];
}

=head2 accounts_by_category

Given the loginid list, return the accounts grouped by the category in a HASH reference.
The categories are:

- real enabled accounts
- virtual accounts
- self excluded accounts
- disabled accounts

=cut

sub accounts_by_category {
    my ($self, $loginid_list) = @_;

    my (@enabled_accounts, @virtual_accounts, @self_excluded_accounts, @disabled_accounts);
    foreach my $loginid (sort @$loginid_list) {
        my $cl = try {
            BOM::User::Client->new({
                loginid      => $loginid,
                db_operation => 'replica'
            });
        }
        catch {
            # try master if replica is down
            BOM::User::Client->new({loginid => $loginid});
        };

        next unless $cl;

        my $all_status = BOM::User::Client->status_codes(hidden => 1);
        my @do_not_display_status = grep { $all_status->{$_}->{disallow_login} } keys %$all_status;

        # don't include clients that we don't want to show
        next if grep { $cl->get_status($_) } @do_not_display_status;

        # we store the first suitable client to _disabled_real_client/_self_excluded_client/_virtual_client/_first_enabled_real_client.
        # which will be used in get_default_client
        if ($cl->get_status('disabled')) {
            push @disabled_accounts, $cl;
            next;
        }

        if ($cl->get_self_exclusion_until_date) {
            push @self_excluded_accounts, $cl;
            next;
        }

        if ($cl->is_virtual) {
            push @virtual_accounts, $cl;
            next;
        }

        push @enabled_accounts, $cl;
    }

    return {
        enabled       => \@enabled_accounts,
        virtual       => \@virtual_accounts,
        self_excluded => \@self_excluded_accounts,
        disabled      => \@disabled_accounts
    };
}

=head2 get_default_client

Returns default client for particular user
Act as replacement for using "$siblings[0]" or "$clients[0]"

=cut

sub get_default_client {
    my ($self, %args) = @_;

    return $self->{_default_client_include_disabled} if exists($self->{_default_client_include_disabled}) && $args{include_disabled};
    return $self->{_default_client_without_disabled} if exists($self->{_default_client_without_disabled}) && !$args{include_disabled};

    my $client_lists = $self->accounts_by_category([$self->bom_loginids]);
    my %tmp;
    foreach my $k (keys %$client_lists) {
        $tmp{$k} = pop(@{$client_lists->{$k}});
    }
    $self->{_default_client_include_disabled} = $tmp{enabled} // $tmp{disabled} // $tmp{virtual} // $tmp{self_excluded};
    $self->{_default_client_without_disabled} = $tmp{enabled} // $tmp{virtual} // $tmp{self_excluded};
    return $self->{_default_client_include_disabled} if $args{include_disabled};
    return $self->{_default_client_without_disabled};
}

1;
