package BOM::User::Client;
# ABSTRACT: binary.com client handling and business logic

use strict;
use warnings;

our $VERSION = '0.145';

use parent 'BOM::Database::AutoGenerated::Rose::Client';

no indirect;
use Syntax::Keyword::Try;
use Email::Address::UseXS;
use Email::Stuffer;
use Date::Utility;
use List::Util   qw(all first any min max none pairgrep uniq reduce);
use Array::Utils qw(array_minus intersect);
use Locale::Country::Extra;
use Text::Trim             qw(trim);
use BOM::Platform::Context qw(localize request);
use YAML::XS               qw(LoadFile);
use Path::Tiny;
use Format::Util::Numbers            qw(roundcommon financialrounding formatnumber);
use ExchangeRates::CurrencyConverter qw(convert_currency in_usd);
use JSON::MaybeXS;
use Encode;
use DataDog::DogStatsd::Helper qw(stats_inc stats_timing);
use POSIX                      qw(ceil);
use JSON::MaybeUTF8            qw(encode_json_utf8 encode_json_text);

use Rose::DB::Object::Util qw(:all);
use Rose::Object::MakeMethods::Generic scalar => ['self_exclusion_cache'];

use LandingCompany::Registry;

use BOM::Platform::S3Client;
use BOM::Platform::Event::Emitter;
use BOM::Platform::Client::CashierValidation;
use BOM::Platform::Account::Real::default;
use BOM::Platform::Utility;
use BOM::User::Client::PaymentAgent;
use BOM::User::Client::Status;
use BOM::User::Client::AuthenticationDocuments;
use BOM::User::Client::ProofOfOwnership;
use BOM::User::Client::Account;
use BOM::User::FinancialAssessment;
use BOM::User::SocialResponsibility;
use BOM::User::Utility qw(p2p_exchange_rate p2p_rate_rounding);
use BOM::User::Wallet;
use BOM::Database::UserDB;
use BOM::Database::ClientDB;
use BOM::Database::Model::OAuth;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::Payment;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::AutoGenerated::Rose::Client::Manager;
use BOM::Database::AutoGenerated::Rose::SelfExclusion;
use BOM::Config;
use BOM::Config::Redis;
use BOM::Config::CurrencyConfig;
use BOM::Config::Onfido;
use BOM::Config::P2P;
use BOM::Config::AccountType::Registry;
use BOM::User::Client::PaymentNotificationQueue;
use BOM::User::Client::PaymentTransaction::Doughflow;
use BOM::User::IdentityVerification;
use BOM::Platform::Utility qw(error_map);
use BOM::Platform::Token::API;
use BOM::Platform::Token;
use BOM::User::Onfido;
use JSON::MaybeUTF8 qw(:v1);

use Carp         qw(croak confess);
use Scalar::Util qw(weaken);

use Log::Any qw($log);

=head1 NAME

BOM::User::Client

=cut

use constant {
    MT5_REGEX                           => qr/^MT[DR]?(?=\d+$)/,
    VIRTUAL_REGEX                       => qr/^VR/,
    FALSE_PROFILE_INFO_REGEX            => qr/(potential corporate account|fake profile info)/,
    PROFILE_FIELDS_IMMUTABLE_AFTER_AUTH => [
        sort
            qw/account_opening_reason citizen date_of_birth first_name last_name place_of_birth residence salutation secret_answer secret_question tax_residence tax_identification_number /
    ],
    PROFILE_FIELDS_IMMUTABLE_DUPLICATED =>
        [sort qw/first_name last_name date_of_birth address_city address_line_1 address_line_2 address_postcode address_state phone/],
    FA_FIELDS_IMMUTABLE_DUPLICATED => [
        # this list is empty per compliance requirements, but the logic is still in place
        # if you want to add FA fields please do
    ],
    ADDRESS_FIELDS      => [qw/address_city address_line_1 address_line_2 address_postcode address_state /],
    SR_UNWELCOME_REASON => 'Social responsibility thresholds breached - Pending financial assessment',

    IMMUTABLE_FIELDS_AGE_VERIFICATION => [sort qw/first_name last_name date_of_birth/],

    # Redis key for SR keys expire
    SR_30_DAYS_EXP => 86400 * 30,
};

use constant CACHED_FIELDS => qw(
    account _self_exclusion status documents proof_of_ownership _p2p_advertiser_cached
    _account_type_obj client_authentication_document financial_assessment);

# Redis key prefix for counting DoughFlow payouts
use constant {
    DF_PAYOUTS_COUNTER     => "DF_PAYOUTS_COUNT::",
    DF_PAYOUTS_COUNTER_TTL => 60 * 60 * 24 * 7,       # 7 days
};

# this email address should not be added into brand as it is specific to internal system
my $SUBJECT_RE = qr/(New Sign-Up|Update Address)/;

my $META = __PACKAGE__->meta;                         # rose::db::object::manager meta rules. Knows our db structure

my $json = JSON::MaybeXS->new;

sub rnew { return shift->SUPER::new(@_) }

sub new {
    my $class = shift;
    my $args  = shift || die 'BOM::User::Client->new called without args';

    my $loginid = $args->{loginid};

    die "no loginid"                  unless $loginid;
    croak "Invalid loginid: $loginid" unless $loginid =~ qr/^[A-Z]+/;

    my $operation = delete $args->{db_operation};

    my $context = delete $args->{context};
    if ($context) {
        my $client = $context->client_registry->get_client($loginid, $operation // 'write');
        return $client if $client;
    }

    my $self = $class->SUPER::new(%$args);

    $self->set_db($operation) if $operation;

    $self->load(speculative => 1) || return undef;    # must exist in db

    if ($context) {
        $context->client_registry->add_client($self);
        $self->{context} = $context;
        weaken($self->{context});
    }

    return $self;
}

sub get_instance {
    my $args = shift;
    return __PACKAGE__->new($args);
}

#              real db column                                    =>  legacy name
$META->column('address_city')->method_name('get_set' => 'city');
$META->column('address_line_1')->method_name('get_set' => 'address_1');
$META->column('address_line_2')->method_name('get_set' => 'address_2');
$META->column('address_postcode')->method_name('get_set' => 'postcode');
$META->column('address_state')->method_name('get_set' => 'state');
$META->column('client_password')->method_name('get_set' => 'password');

my $date_inflator_ymdhms = sub {
    my $self = shift;
    my $val  = shift // return undef;
    return $val unless ref($val);
    return $val->isa('DateTime') ? ($val->ymd . ' ' . $val->hms) : $val;
};

my $date_inflator_ymd = sub {
    my $self = shift;
    my $val  = shift // return undef;
    return $val unless ref($val);
    return $val->isa('DateTime') ? $val->ymd : $val;
};

$META->column('date_of_birth')->add_trigger(inflate => $date_inflator_ymd);
$META->column('date_of_birth')->add_trigger(deflate => $date_inflator_ymd);
$META->column('date_joined')->add_trigger(inflate => $date_inflator_ymdhms);
$META->column('date_joined')->add_trigger(deflate => $date_inflator_ymdhms);
$META->column('non_pep_declaration_time')->add_trigger(inflate => $date_inflator_ymdhms);
$META->column('non_pep_declaration_time')->add_trigger(deflate => $date_inflator_ymdhms);

my %DEFAULT_VALUES = (
    cashier_setting_password => '',
    latest_environment       => '',
    restricted_ip_address    => '',
);

$META->column($_)->default($DEFAULT_VALUES{$_}) for sort keys %DEFAULT_VALUES;

# END OF METADATA -- do this after all 'meta' calls.
$META->initialize(replace_existing => 1);

sub save {
    my $self = shift;
    # old code can set these numeric columns to ''.  should have been undef.
    for my $col (qw/custom_max_acbal custom_max_daily_turnover custom_max_payout/) {
        my $val = $self->$col // next;
        $self->$col(undef) if $val eq '';    # if we get here, it's defined.
    }

    $self->set_db('write');
    my $r = $self->SUPER::save(cascade => 1);    # Rose
    return $r;
}

sub register_and_return_new_client {
    my ($class, $args) = @_;

    my $broker = $args->{broker_code} || die "can't register a new client without a broker_code";

    my $context = delete $args->{context};

    if ($args->{salutation} and not $args->{gender}) {
        $args->{gender} = (uc $args->{salutation} eq 'MR') ? 'm' : 'f';
    }

    if ($args->{date_of_birth}) {
        $args->{date_of_birth} = Date::Utility->new($args->{date_of_birth})->date_yyyymmdd;
    }

    if ($args->{date_joined}) {
        $args->{date_joined} = Date::Utility->new($args->{date_joined})->datetime_yyyymmdd_hhmmss;
    }

    if ($args->{non_pep_declaration_time}) {
        $args->{non_pep_declaration_time} = Date::Utility->new($args->{non_pep_declaration_time})->datetime_yyyymmdd_hhmmss;
    }

    my $dbic   = $class->rnew(broker => $broker)->db->dbic;
    my $result = $dbic->run(
        fixup => sub {
            return $_->selectrow_hashref("select * from betonmarkets.create_client(?::JSON)", undef, encode_json_text($args));
        });

    my $self = $class->SUPER::new(%$result);
    $self->set_db('write');

    $self->load;

    if ($context) {
        $context->client_registry->add_client($self);
        $self->{context} = $context;
        weaken($self->{context});
    }

    return $self;
}

sub full_name {
    my $self = shift;
    return $self->salutation . ' ' . $self->first_name . ' ' . $self->last_name;
}

sub landing_company {
    my $self = shift;
    return LandingCompany::Registry->by_broker($self->broker);
}

=head2 set_promotion

Description: Sets or Gets the promotion object. Linked to the table betonmarkets.client_promo_code
If the client does not have a promo_code object it will be created otherwise the existing one will be returned.
Takes no Arguments


Returns a L<BOM::Database::AutoGenerated::Rose::ClientPromoCode>

=cut

sub set_promotion {
    my ($self) = @_;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
        $self->client_promo_code(undef);    # empty Rose's read-only version..
    }
    # get the existing one or make a dummy one..
    if (my $obj = $self->client_promo_code) {
        return $obj;
    }
    if (LandingCompany::Registry::get_currency_type($self->currency) eq 'crypto') {
        die "Promo code cannot be added to crypto currency accounts\n";
    }
    my %args = (
        broker         => $self->broker,
        client_loginid => $self->loginid,
        status         => 'NOT_CLAIM',
        mobile         => '',
        apply_date     => Date::Utility->new->db_timestamp,
        db             => $self->db,
    );

    my $obj = BOM::Database::AutoGenerated::Rose::ClientPromoCode->new(%args);
    return $self->client_promo_code($obj);
}

# support legacy calls to these get/set shortcuts from Client to the promo_code record
sub promo_code {
    my ($self, $promo_code) = @_;
    if ($promo_code) {
        my $dbic   = $self->db->dbic;
        my $result = $dbic->run(
            fixup => sub {
                $_->selectrow_hashref('SELECT * FROM betonmarkets.promo_code WHERE code = ?', undef, ($promo_code),);
            });
        die "invalid promocode $promo_code\n" if (!$result);
        return $self->set_promotion->promotion_code($promo_code);
    }
    return ($self->client_promo_code || return)->promotion_code;
}

sub promo_code_status {
    my $self = shift;
    return $self->set_promotion->status(@_) if @_;
    return ($self->client_promo_code || return)->status;
}

sub promo_code_apply_date {
    my $self = shift;
    return $self->set_promotion->apply_date(@_) if @_;
    return ($self->client_promo_code || return)->apply_date;
}

sub promo_code_checked_in_myaffiliates {
    my $self = shift;
    return $self->set_promotion->checked_in_myaffiliates(@_) if @_;
    return ($self->client_promo_code || return)->checked_in_myaffiliates;
}

sub by_promo_code {
    my ($class, %args) = @_;
    my $broker  = $args{broker_code} || die 'by_promo_code needs a broker_code';
    my $db      = $class->rnew(broker => $broker)->db;
    my $clients = BOM::Database::AutoGenerated::Rose::Client::Manager->get_client(
        db           => $db,
        with_objects => ['client_promo_code'],
        query        => [%args],
        sort_by      => 't1.broker_code, t1.loginid'
    );
    # turn BPDPR::Client objects into (much smarter) Client objects
    return map { bless $_, $class } @$clients;
}

sub by_args {
    my ($class, %query) = @_;
    my $broker = $query{broker_code} || die 'by_args needs a broker_code';
    my %opts   = (
        db      => $class->rnew(broker => $broker)->db,
        sort_by => 'broker_code, loginid'
    );
    if (my $limit = delete $query{limit}) {
        $opts{limit} = $limit;
    }
    my $clients = BOM::Database::AutoGenerated::Rose::Client::Manager->get_client(%opts, query => [%query]);
    # turn BPDPR::Client objects into (much smarter) Client objects
    return [map { bless $_, $class } @$clients];
}

sub get_objects_from_sql {
    my ($class, %args) = @_;
    my $broker = delete $args{broker_code} || die 'get_objects_from_sql needs a broker_code';
    $args{db} ||= $class->rnew(broker => $broker)->db;
    my $clients = BOM::Database::AutoGenerated::Rose::Client::Manager->get_objects_from_sql(%args);
    # turn BPDPR::Client objects into (much smarter) Client objects
    return [map { bless $_, $class } @$clients];
}

sub is_virtual { return (shift->broker =~ VIRTUAL_REGEX) ? 1 : 0; }

sub has_funded { return shift->first_funded_date ? 1 : 0 }

sub get_authentication {
    my $self            = shift;
    my $method          = shift;
    my $column          = shift;
    my $authentications = {map { $_->authentication_method_code => $_ } $self->client_authentication_method};
    my $obj             = $authentications->{$method} || return undef;
    return $column ? $obj->$column : $obj;
}

=head2 set_authentication

Set authentication for a client and all allowed siblings.

Allow client to upload documents if the status is needs_action.

Takes the following arguments as named parameters

=over

=item * C<method> - required. Name of an authentication method.

=item * C<authentication_status> - required. The status of authentication method.

=back

Returns the authentication method for a client.

=cut

sub set_authentication {
    my ($self, $method, $authentication_status, $staff) = @_;
    $staff ||= "system";
    my $status = $authentication_status->{status};
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
        $self->client_authentication_method(undef);    # throw out my read-only versions..
    }

    # Set authentication method for a client and all allowed siblings
    my @allowed_lc_to_sync = @{$self->landing_company->allowed_landing_companies_for_authentication_sync};
    my @clients_to_update;
    # Get all siblings for a client except virtual one and itself
    if ($self->user and not $self->is_virtual) {
        @clients_to_update =
            grep { not $_->is_virtual and $_->loginid ne $self->loginid } $self->user->clients;
    }
    # Push the client to the list.
    push(@clients_to_update, $self);
    # Set authentication for client itself
    # Set authentication for allowed landing company
    # Skip if client is already authenticated
    foreach my $cli (@clients_to_update) {
        if (   ($self->landing_company->short eq $cli->landing_company->short)
            or (any { $_ eq $cli->landing_company->short } @allowed_lc_to_sync)
            and not($cli->get_authentication($method) and ($cli->get_authentication($method)->status eq $status)))
        {
            # Remove existing status to make the auth methods mutually exclusive
            $_->delete for @{$cli->client_authentication_method};
            $cli->add_client_authentication_method({
                authentication_method_code => $method,
                status                     => $status
            });
            if ($status eq 'pass') {
                $cli->status->clear_allow_document_upload;
                # We should notify CS to check TIN and MIFIR for MF clients
                # if its status updated from respective MLT or MX
                _notify_cs_about_authenticated_mf($cli->loginid, $self->broker_code)
                    if not $self->landing_company->short eq 'maltainvest' and $cli->landing_company->short eq 'maltainvest';
                # Remove unwelcome from MX once its authenticated from MF
                $cli->status->clear_unwelcome
                    if ($cli->residence eq 'gb'
                    and $cli->landing_company->short eq 'iom'
                    and $cli->status->unwelcome);
            } elsif ($status eq 'needs_action' and not $cli->status->allow_document_upload) {
                $cli->status->upsert('allow_document_upload', $staff, 'MARKED_AS_NEEDS_ACTION');
            }
            $cli->save;
        }
    }

    $self->update_status_after_auth_fa();
    return $self->get_authentication($method);
}

=head2 sync_authentication_from_siblings

Update authentication for a client upon signup based on all allowed siblings.

Allow client to upload documents if the status is needs_action.

=cut

sub sync_authentication_from_siblings {
    my $self = shift;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
        $self->client_authentication_method(undef);    # throw out my read-only versions..
    }
    my (@allowed_lc_to_sync, @siblings, $method, $status);
    # Get all siblings for a client except virtual one and itself
    if ($self->user and not $self->is_virtual) {
        @siblings = grep { not $_->is_virtual and $_->loginid ne $self->loginid } $self->user->clients;
    }
    # Get authentication method and status from allowed sibling
    # Update new created account's authentication
    foreach my $cli (@siblings) {
        @allowed_lc_to_sync = @{$cli->landing_company->allowed_landing_companies_for_authentication_sync};
        if ((any { $_ eq $self->landing_company->short } @allowed_lc_to_sync) and $cli->client_authentication_method) {
            for my $auth_method (qw/ID_DOCUMENT ID_NOTARIZED/) {
                my $auth = $cli->get_authentication($auth_method);
                if ($auth) {
                    $method = $auth->authentication_method_code;
                    $status = $auth->status;
                    $self->add_client_authentication_method({
                        authentication_method_code => $method,
                        status                     => $status
                    });
                    if ($status eq 'pass') {
                        $self->status->clear_allow_document_upload;
                        # We should notify CS to check TIN and MIFIR for MF clients
                        _notify_cs_about_authenticated_mf($self->loginid, $cli->broker_code) if $self->landing_company->short eq 'maltainvest';
                        # Remove unwelcome from MX once its authenticated from MF
                        $self->status->clear_unwelcome
                            if ($self->residence eq 'gb'
                            and $self->landing_company->short eq 'iom'
                            and $self->status->unwelcome);
                    } elsif ($status eq 'needs_action') {
                        $self->status->upsert('allow_document_upload', 'system', 'MARKED_AS_NEEDS_ACTION')
                            if not $cli->status->allow_document_upload;
                    }
                    $self->save;
                    return $self->get_authentication($method);
                }
            }
        }
    }
    return undef;
}

=head2 set_authentication_and_status

gets an input and removes all clients auth statuses, then sets the authentication

it is used in bom-backoffice->f_clientloginid_edit.cgi and bom-events->Authentication.pm

=over 4

=item * C<client_authentication> - client authentication status

=item * C<staff> - the staff who triggered the process

=back

=cut

sub set_authentication_and_status {
    my ($self, $client_authentication, $staff) = @_;
    my $address_verified;

    # Remove existing status to make the auth methods mutually exclusive
    $_->delete for @{$self->client_authentication_method};

    if ($client_authentication eq 'IDV') {
        $self->set_authentication('IDV', {status => 'pass'}, $staff);
        $address_verified = 1;
    }

    if ($client_authentication eq 'IDV_PHOTO') {
        $self->set_authentication('IDV_PHOTO', {status => 'pass'}, $staff);
    }

    if ($client_authentication eq 'ID_NOTARIZED') {
        $self->set_authentication('ID_NOTARIZED', {status => 'pass'}, $staff);
        $address_verified = 1;
    }

    if ($client_authentication eq 'ID_DOCUMENT') {
        $self->set_authentication('ID_DOCUMENT', {status => 'pass'}, $staff);
        BOM::Platform::Event::Emitter::emit('authenticated_with_scans', {loginid => $self->loginid});
        $address_verified = 1;
    }

    if ($client_authentication eq 'ID_ONLINE') {
        $self->set_authentication('ID_ONLINE', {status => 'pass'}, $staff);
        $address_verified = 1;
    }

    if ($client_authentication eq 'NEEDS_ACTION') {
        $self->set_authentication('ID_DOCUMENT', {status => 'needs_action'}, $staff);
        # 'Needs Action' shouldn't replace the locks from the account because we'll lose the request authentication reason
        $self->status->setnx('allow_document_upload', $staff, 'MARKED_AS_NEEDS_ACTION');
    }

    $self->save;
    $self->update_status_after_auth_fa('', $staff);
    # Remove unwelcome status from MX client once it fully authenticated
    $self->status->clear_unwelcome
        if ($self->residence eq 'gb'
        and $self->landing_company->short eq 'iom'
        and $self->fully_authenticated
        and $self->status->unwelcome);

    $self->status->upsert('address_verified', $staff, 'address verified') if $address_verified;
    $self->status->clear_address_verified unless $address_verified;

    return 1;
}

=head2 notify_cs_about_authenticated_mf

Send an email to CS about new authenticated MF based on MLT to check their TIN and MIFIR

=over

=item * C<loginid> - required. MF client loginid that needs check.

=back

Returns B<1>.

=cut

sub _notify_cs_about_authenticated_mf {
    my ($loginid, $broker_code) = @_;

    my $from_email = request()->brand->emails('no-reply');
    my $to_email   = request()->brand->emails('authentications');

    return Email::Stuffer->from($from_email)->to($to_email)->subject('New authenticated MF from ' . $broker_code . ': ' . $loginid)
        ->text_body('A MF client has been marked as authenticated based on  '
            . $broker_code
            . ' client. Please check the financial assessment, Tax Identification Number and MIFIR information. MF client is: '
            . $loginid)->send();

}

=head2 risk_level_aml

Get the risk level of clients, based on:

- AML (Anti-Money Laundering): Applies for clients under all landing companies

=cut

sub risk_level_aml {
    my $self = shift;

    my $risk = $self->aml_risk_classification // '';

    # use `low`, `standard`, `high` as prepending `manual override` string is for internal purpose
    $risk =~ s/manual override - //;

    return $risk;
}

=head2 risk_level_sr

Get the risk level of clients, based on:

- SR (Social Responsibility): Always high for clients that have breached thresholds
and have no financial assessment

=over

=item * C<risk_level_sr_raw> - request raw SR risk level

=back

=cut

sub risk_level_sr {
    my $self = shift;

    my $risk = 'low';

    if ($self->landing_company->social_responsibility_check) {

        if (!$self->financial_assessment && $self->landing_company->social_responsibility_check eq 'required') {
            $risk = 'high'
                if BOM::Config::Redis::redis_events()->get($self->loginid . ':sr_risk_status');
        }

        if ($self->landing_company->social_responsibility_check eq 'manual') {
            $risk = BOM::User::SocialResponsibility->get_sr_risk_status($self->binary_user_id) // 'low';
            # 'low', 'high', 'manual override high', 'problem gambler'
            $risk =~ s/manual override high|problem trader/high/;
        }

    }

    return $risk;
}

=head2 was_locked_for_high_risk

In some cases high risk clients drop do standard/low risk level before authentication and FA submission;
these clients will remain withdrawal_locked without any notification or instructions in the front-end about what's wrong 
(these instructions are exclusively sent for igh-risk clients only).
This moethid identifies such clients in order to flag them properly in B<get_account_status> API response.

This method returns true if:

1- client is not high-risk at the monent

2- client is allowed to upload documents because of high risk

3- FA is not completed or POI is not done yet

=cut

sub was_locked_for_high_risk {
    my $self = shift;

    return
           ($self->risk_level_aml ne 'high')
        && $self->status->withdrawal_locked
        && $self->status->allow_document_upload
        && ($self->status->allow_document_upload->{reason} eq 'BECOME_HIGH_RISK')
        || 0;
}

=head2 is_financial_assessment_complete

Check if the client has filled out the financial assessment information:

- For non-MF, only the the financial information (FI) is required and (risk level is high or it's forced by staff).
- For MF trading experience is required, regardless of rish level.
- For MF, Finacial information is required for standard and high in withdrawals only

=cut

sub is_financial_assessment_complete {
    my $self = shift;

    # only used for MF
    my $is_withdrwals = shift // 0;

    my $lc                   = $self->landing_company->short;
    my $financial_assessment = BOM::User::FinancialAssessment::decode_fa($self->financial_assessment());

    my $is_FI = BOM::User::FinancialAssessment::is_section_complete($financial_assessment, 'financial_information', $lc);

    my $is_fa_required =
           $self->status->financial_assessment_required
        || $self->risk_level_aml() eq 'high'
        || $self->risk_level_sr() eq 'high'
        || $self->was_locked_for_high_risk;

    if ($lc ne 'maltainvest') {
        return 0 if ($is_fa_required && !$is_FI);
        return 1;
    }

    my $is_TE = BOM::User::FinancialAssessment::is_section_complete($financial_assessment, 'trading_experience', $lc);

    # trading experience is always required
    return 0 if (!$is_TE);

    # for withdrwals we are using withdrwawl lock status
    return 0 if ($is_withdrwals && !$is_FI);

    return 1;
}

=head2 is_financial_information_complete

Check if the client has filled out the financial information:

- For MF, the FA is not required for low risk level.

=cut

sub is_financial_information_complete {
    my $self = shift;

    my $lc                   = $self->landing_company->short;
    my $financial_assessment = BOM::User::FinancialAssessment::decode_fa($self->financial_assessment());

    my $is_FI = BOM::User::FinancialAssessment::is_section_complete($financial_assessment, 'financial_information', $lc);

    return 0 unless $is_FI;

    return 1;
}

=head2 get_financial_assessment

returns the asked value of the field of the clien't financial assessment.
if no field parameter is passed, it returns the whole FA object.
if the FA does not exist it returns undef.

=over

=item * C<BOM::User> - required.

=item * C<Financial Assessment> - A value of Financial Assessment JSON data field and can be any of the following:

=over

=item * net_income, employment_industry, source_of_wealth, account_turnover, occupation, employment_status, income_source, estimated_worth, education_level

=back

=back

Returns B<value> of field or the whole B<data field> if field is null.

=cut

sub get_financial_assessment {
    my $self  = shift;
    my $field = shift;

    my $value;

    try {
        $value = $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_array('SELECT * FROM betonmarkets.financial_assessment(?, ?)', undef, $self->loginid, $field);
            });

    } catch ($e) {
        die $log->errorf('An error occurred getting the financial assessment of client %s : %s', $self->loginid, $e);
    }

    return $value;
}

=head2 set_financial_assessment

Sets clien't financial assessment
It will set the the keys provided and will not override the whole JSON object

=over

=item * C<BOM::User> - required.

=item * C<Financial Assessment> - A hash reference of Financial Assessment:

=back

=cut

sub set_financial_assessment {
    my $self = shift;
    my $data = shift;

    try {
        return $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_array('SELECT * FROM betonmarkets.set_financial_assessment(?, ?)', undef, $self->loginid, encode_json_utf8($data));
            });

    } catch ($e) {
        die $log->errorf('An error occurred setting the financial assessment of client %s : %s', $self->loginid, $e);
    }
}

=head2 fully_authenticated

For reference a client is termed fully authenticated with following parameters :

CR - POI + POA
MX - Prove ID / (POI + POA)
MLT - POI + POA
MF - POI + POA + Selfie in Onfido

It takes a hashref of params:

=over 4

=item * C<ignore_idv> - strict check for ID_DOCUMENT ID_NOTARIZED ID_ONLINE, poa-less scenarios are skipped.

=back

Returns C<0> or C<1>.

=cut

sub fully_authenticated {
    my ($self, $args) = @_;

    $args //= {};

    for my $method (qw/ID_DOCUMENT ID_NOTARIZED ID_ONLINE/) {
        my $auth = $self->get_authentication($method);
        return 1 if $auth and $auth->status eq 'pass';
    }

    # Some checks may require strict POA verification

    return 0 if $args->{ignore_idv};

    return $self->poa_authenticated_with_idv;
}

=head2 poa_authenticated_with_idv

Determines if the client was authenticated by IDV+PhotoID and the risk conditions are also met.

Returns C<0> or C<1>.

=cut 

sub poa_authenticated_with_idv {
    my ($self) = @_;

    # idv cannot fully auth high risk clients

    return 0 if $self->is_high_risk;

    # Some LC can get fully auth if IDV_PHOTO

    my $idv_photo = $self->get_authentication('IDV_PHOTO');

    return 1
        if $self->landing_company->fully_authenticated_with_idv_photoid
        and $idv_photo
        and $idv_photo->status eq 'pass';

    # some providers might verify the address of a client

    my $idv = $self->get_authentication('IDV');

    return 1 if $idv and $idv->status eq 'pass';

    return 0;
}

=head2 is_high_risk

Determines if the client is high risk.

We take into consideration both AML and SR, if any of them is `high` we consider the
client as high risk.

=cut

sub is_high_risk {
    my ($self) = @_;

    return 1 if ($self->risk_level_sr  // '') eq 'high';
    return 1 if ($self->risk_level_aml // '') eq 'high';
    return 0;
}

sub authentication_status {
    my ($self) = @_;

    my $idv_photo = $self->get_authentication('IDV_PHOTO');

    return 'idv_photo' if $idv_photo and $idv_photo->status eq 'pass';

    my $idv = $self->get_authentication('IDV');

    return 'idv' if $idv and $idv->status eq 'pass';

    my $online = $self->get_authentication('ID_ONLINE');

    return 'online' if $online and $online->status eq 'pass';

    my $notarized = $self->get_authentication('ID_NOTARIZED');

    return 'notarized' if $notarized and $notarized->status eq 'pass';

    my $id_auth = $self->get_authentication('ID_DOCUMENT');

    return 'no' unless $id_auth;

    my $id_auth_status = $id_auth->status;

    return 'scans' if $id_auth_status eq 'pass';

    return $id_auth_status;
}

sub set_exclusion {
    my $self = shift;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
    }
    # return the existing one..
    if (my $obj = $self->self_exclusion) {
        $self->{_self_exclusion}{val} = $obj;
        return $obj;
    }
    # or make a new one
    $self->self_exclusion(my $obj = BOM::Database::AutoGenerated::Rose::SelfExclusion->new());
    $self->{_self_exclusion}{val} = $obj;
    return $obj;
}

# make this relationship return its smarter version too
sub get_payment_agent {
    my $self = shift;
    my $obj  = $self->payment_agent || return undef;
    my $pa   = bless $obj, 'BOM::User::Client::PaymentAgent';
    return $pa;
}

# return a (new or existing) writeable BOM::User::Client::PaymentAgent
sub set_payment_agent {
    my $self = shift;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
    }
    # return the existing one..
    if (my $obj = $self->get_payment_agent) {
        $obj->db($self->db);
        return $obj;
    }
    my %args = (
        client_loginid => $self->loginid,
        db             => $self->db
    );
    $self->payment_agent(BOM::Database::AutoGenerated::Rose::PaymentAgent->new(%args));
    return $self->get_payment_agent;
}

sub get_self_exclusion {
    my $self = shift;

    $self->{_self_exclusion} //= {val => $self->self_exclusion};

    return $self->{_self_exclusion}{val};
}

=head2 get_self_exclusion_audit

Get the latest details from audit tables about self exclusion for each field.

It returns an arrayref of information for each self exclusion field.

=cut

sub get_self_exclusion_audit {
    my ($self) = @_;

    my $audit = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref("SELECT * from audit.get_self_exclusion_audit(?);", {Slice => {}}, $self->loginid);
        });

    return $audit;
}

=head2 get_deposit_limits

Returns self-exlusion limits for max deposit as a hashref contining these keys:

=over

=item * C<daily> - daily max deposit limit

=item * C<7day> - 7-day max  deposit limit

=item * C<30day> - 30-day max deposit limit

=back

=cut

sub get_deposit_limits {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    return {} unless $excl;

    my %result = map { $excl->{"max_deposit_$_"} ? ($_ => $excl->{"max_deposit_$_"}) : () } qw(daily 7day 30day);

    return \%result;
}

=head2 get_limit_for_account_banace

Get client's balance limit from global configuration and self exclusion.

Return: account balance limit

=cut

sub get_limit_for_account_balance {
    my $self = shift;

    my @maxbalances = ();

    my $fixed_max = $self->fixed_max_balance;
    push @maxbalances, $fixed_max if defined $fixed_max;

    my $self_max_balance = $self->get_self_exclusion ? $self->get_self_exclusion->max_balance : undef;

    if (defined($self_max_balance)) {
        push @maxbalances, $self_max_balance;
    }

    return List::Util::min(@maxbalances) // 0;
}

=head2 fixed_max_balance

Returns the system-wide maximum account balance defined for the client type and currency.

=cut

sub fixed_max_balance {
    my $self = shift;

    # Returns undef if landing company configuration asked for unlimited balance
    return undef if $self->landing_company->unlimited_balance;

    my $max_bal = BOM::Config::client_limits()->{max_balance};
    my $curr    = $self->currency;
    return $self->is_virtual ? $max_bal->{virtual}{$curr} : $max_bal->{real}{$curr};
}

sub get_limit_for_daily_turnover {
    my $self = shift;

    # turnover maxed at 500K of any currency.
    my @limits = (BOM::Config::client_limits()->{maximum_daily_turnover}{$self->currency});
    if ($self->get_self_exclusion && $self->get_self_exclusion->max_turnover) {
        push @limits, $self->get_self_exclusion->max_turnover;
    }

    return List::Util::min(@limits);
}

sub get_limit_for_daily_losses {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_losses) {
        return $excl->max_losses;
    }
    return undef;
}

sub get_limit_for_7day_turnover {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_7day_turnover) {
        return $excl->max_7day_turnover;
    }
    return undef;
}

sub get_limit_for_7day_losses {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_7day_losses) {
        return $excl->max_7day_losses;
    }
    return undef;
}

sub get_limit_for_30day_turnover {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_30day_turnover) {
        return $excl->max_30day_turnover;
    }
    return undef;
}

sub get_limit_for_30day_losses {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_30day_losses) {
        return $excl->max_30day_losses;
    }
    return undef;
}

sub get_limit_for_open_positions {
    my $self = shift;

    my @limits = BOM::Config::client_limits()->{max_open_bets_default};

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_open_bets) {
        push @limits, $excl->max_open_bets;
    }

    return List::Util::min(@limits);
}

# return undef or an exclusion date string
sub get_self_exclusion_until_date {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    return undef unless $excl;

    my $exclude_until = $excl->exclude_until;
    my $timeout_until = $excl->timeout_until;
    my $today         = Date::Utility->new;
    # Don't uplift exclude_until date for clients under Deriv (Europe) Limited,
    # Deriv (MX) Ltd, and Deriv Investments (Europe) Limited upon expiry.
    # This is in compliance with Section 3.5.4 (5e) of the United Kingdom Gambling
    # Commission licence conditions and codes of practice
    # United Kingdom Gambling Commission licence conditions and codes of practice is
    # applicable to clients under Deriv (Europe) Limited & Deriv (MX) Ltd only. Change is also
    # applicable to clients under Deriv Investments (Europe) Limited for standardisation.
    # (http://www.gamblingcommission.gov.uk/PDF/LCCP/Licence-conditions-and-codes-of-practice.pdf)
    if ($self->landing_company->short !~ /^(?:iom|malta|maltainvest)$/) {
        # undef if expired
        undef $exclude_until
            if $exclude_until and Date::Utility->new($exclude_until)->is_before($today);
    }

    undef $timeout_until if $timeout_until and Date::Utility->new($timeout_until)->is_before($today);

    return undef unless $exclude_until || $timeout_until;

    if ($exclude_until && $timeout_until) {
        my $exclude_until_dt = Date::Utility->new($exclude_until);
        my $timeout_until_dt = Date::Utility->new($timeout_until);

        return $exclude_until_dt->date if $exclude_until_dt->epoch < $timeout_until_dt->epoch;
        return $timeout_until_dt->datetime_yyyymmdd_hhmmss_TZ;
    }

    return Date::Utility->new($exclude_until)->date if $exclude_until;
    return Date::Utility->new($timeout_until)->datetime_yyyymmdd_hhmmss_TZ;
}

sub get_limit_for_payout {
    my $self = shift;

    my $max_payout = BOM::Config::client_limits()->{max_payout_open_positions};

    return $max_payout->{$self->currency} // 0;
}

sub get_limit {
    my $self = shift;
    my $args = shift        || die 'get_limit needs args';
    my $for  = $args->{for} || die 'get_limit needs a "for" arg';

    $for = 'get_limit_for_' . $for;
    return $self->$for;
}

sub currency {
    my $self = shift;

    if (my $account = $self->default_account) {
        return $account->currency_code();
    }

    return $self->landing_company->get_default_currency($self->residence);
}

=head2 local_currency

Returns the 3-character currency code matching the client's residence as defined in L<ISO 4217|https://en.wikipedia.org/wiki/ISO_4217>.

=over 4

=item * C<$country> - optional 2-character ISO country code used to override the country
for the currency mapping, for cases where you want to use citizenship or a specific country

=back

=cut

sub local_currency {
    my ($self, $country) = @_;
    $country //= $self->residence;

    return undef unless $country;

    return BOM::Config::CurrencyConfig::local_currency_for_country(country => $country);
}

sub has_deposits {
    my $self = shift;
    my $args = shift;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref("SELECT * from betonmarkets.has_first_deposit(?, ?);", undef, $self->loginid, $args->{exclude});
        })->{has_first_deposit};
}

sub is_first_deposit_pending {
    my $self = shift;

    return 0 if $self->is_virtual;
    # we need to ignore free gift as its payment done manually by marketing
    return 0 if $self->has_deposits({exclude => ['free_gift']});

    return 1;
}

=head2 is_mt5

Returns 1 if this is an MT5 account.
Returns 0 if this isn't an MT5 account

=cut

sub is_mt5 {
    my $self = shift;
    return $self->loginid =~ MT5_REGEX;
}

sub has_mt5_deposits {
    my $self   = shift;
    my $mt5_id = shift;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref("SELECT * from betonmarkets.has_first_mt5_deposit(?);", undef, $mt5_id);
        })->{has_first_mt5_deposit};
}

sub first_funded_currency { return shift->_ffd->{first_funded_currency} }
sub first_funded_amount   { return shift->_ffd->{first_funded_amount} }
sub first_funded_date     { return shift->_ffd->{first_funded_date} }

sub _ffd {    # first_funded_details
    my $self           = shift;
    my $ffd            = {};
    my $payment_mapper = BOM::Database::DataMapper::Payment->new({client_loginid => $self->loginid});
    if (my $ff = $payment_mapper->first_funding) {
        $ffd->{first_funded_date}     = Date::Utility->new($ff->payment_time->epoch);
        $ffd->{first_funded_amount}   = sprintf '%.2f', $ff->amount;
        $ffd->{first_funded_currency} = $ff->account->currency_code();
    }
    return $ffd;
}

# The following 2 subroutines are proxies to
# the real account sub routine and can be removed
# when the calls are refactored.

sub set_default_account {
    my $self     = shift;
    my $currency = shift;
    return $self->account($currency);
}

sub default_account {
    my $self = shift;
    return $self->account();
}

=head2 account

C<< $account = $self->account($currency) >>

If one does not exist it creates an account entry assigns it a currency symbol
and marks it as default.  If there is already a default currency set it makes
no changes.

Takes the following parameters.

=over 4

=item * C<currency> - (optional) An alphanumeric string with 2-20 characters as defined in L<ISO 4217|https://en.wikipedia.org/wiki/ISO_4217> where C<ISO 4217> applicable for some currencies (i.e. fiat). An account will be created based on the given string, if it does not exist.

=back

Returns C<Account> - An Account Object of type BOM::User::Client::Account

=cut

sub account {
    my $self     = shift;
    my $currency = shift;

    my $account = $self->{account};

    if ($account && $account->currency_code()) {
        return $account;
    }

    if ($account && !$currency) {
        return undef;
    }

    $self->{account} = BOM::User::Client::Account->new(
        client_loginid => $self->loginid,
        currency_code  => $currency,
        db             => $self->db,
    );

    #calls to Account new will always return some sort of object because that's how moo works,
    #so to maintain backward compatibility we return undef if no currency_code exists showing
    #an empty account.
    return undef unless $self->{account}->currency_code();

    return $self->{account};
}

=head1 CUSTOMER SERVICE RELATED FUNCTIONS

These are for interfacing with customer service facing applications (like email
queues or CRM applications).

=head2 add_note($subject, $content)

Adds a note for a customer record.  This is supposed to integrate with whatever
CS is doing, and returns 1 on success or 0 on failure.

Currently this is simply an emailer which sends the email to the helpdesk
system.  Since we go through localhost, we die if there is an error.  This
might happen if somehow we are sending invalid SMTP commands or the like.

As the implementation changes the exceptions may change as well, but the basic
guarantee is that if there is a serious system error that prevents this from
working going forward with any input, it should die.

=cut

sub add_note {
    my ($self, $subject, $content) = @_;

    # send to different email based on the subject of the email, as the helpdesk system handles different subject and email differently.
    my $email_to = ($subject =~ /$SUBJECT_RE/) ? 'support_new_account' : 'support';
    $email_to = request()->brand->emails($email_to);
    my $email_from = request()->brand->emails('system_generated');

    # We want to record who this note is for, but many legacy places already include client ID.
    # If you're reading this, please check for those and remove the condition.
    my $loginid = $self->loginid;
    $subject = $loginid . ': ' . $subject unless $subject =~ /\Q$loginid/;
    return Email::Stuffer->from($email_from)->to($email_to)->subject($subject)->text_body($content)->send_or_die;
}

=pod

=head2 get_promocode_dependent_limit

get the limits based on promocode

=cut

sub get_promocode_dependent_limit {
    my ($self) = @_;

    my $payment_mapper = BOM::Database::DataMapper::Payment->new({
        'client_loginid' => $self->loginid,
        'currency_code'  => $self->currency,
    });

    my $total_free_gift_deposits            = $payment_mapper->get_total_free_gift_deposit();
    my $total_free_gift_rescind_withdrawals = $payment_mapper->get_total_free_gift_rescind_withdrawal();

    my $free_gift_deposits = $total_free_gift_deposits - $total_free_gift_rescind_withdrawals;

    my $frozen_free_gift = 0;
    my $turnover_limit   = 0;

    my $cpc = $self->client_promo_code;
    if ($cpc && $cpc->status !~ /^(CANCEL|REJECT)$/) {

        my $pc = $cpc->promotion;
        try {
            $pc->{_json} ||= JSON::MaybeXS->new->decode($pc->promo_code_config);
        } catch {
            $log->debugf('Unable to parse promo code config: %s', $pc->promo_code_config);
        }

        if ($pc->promo_code_type eq 'FREE_BET') {

            my $min_turnover = $pc->{_json}{min_turnover};
            my $amount       = $pc->{_json}{amount};

            my $made_actual_deposit = $payment_mapper->get_total_deposit() - $amount;
            if ($made_actual_deposit) {
                $frozen_free_gift = $free_gift_deposits;
            } else {
                my $account_mapper = BOM::Database::DataMapper::Account->new({
                    'client_loginid' => $self->loginid,
                    'currency_code'  => $self->currency,
                });
                $frozen_free_gift = $account_mapper->get_balance();
            }

            $turnover_limit = 25 * $amount;

            # matched bets
            if (defined($min_turnover) and length($min_turnover) > 0) {
                $frozen_free_gift = 0;
            }

            my $txn_data_mapper = BOM::Database::DataMapper::Transaction->new({
                client_loginid => $self->loginid,
                currency_code  => $self->currency,
            });

            if (roundcommon(0.01, $txn_data_mapper->get_turnover_of_account) >= $turnover_limit) {
                $frozen_free_gift = 0;
            }
        }
    }

    return {
        frozen_free_gift         => $frozen_free_gift,
        free_gift_turnover_limit => $turnover_limit,
    };
}

=pod

=head2 get_withdrawal_limits

get withdraw limits

=cut

sub get_withdrawal_limits {
    my $self = shift;

    my $withdrawal_limits = $self->get_promocode_dependent_limit();

    my $max_withdrawal = 0;
    if ($self->default_account) {
        my $balance = $self->default_account->balance;
        $max_withdrawal = List::Util::max(0, $balance - $withdrawal_limits->{'frozen_free_gift'});
    }

    $withdrawal_limits->{'max_withdrawal'} = $max_withdrawal;

    return $withdrawal_limits;
}

=head2 user

    my $user = $self->user;
returns the user associated with the client : C<BOM::User>

=cut

sub user {
    my $self = shift;

    my $id = $self->binary_user_id;

    my $user;
    # Use binary_user_id to get the user
    $user = BOM::User->new(
        id      => $id,
        context => $self->{context}) if $id;
    # Fall back to loginid if binary_user_id does not work
    $user //= BOM::User->new(
        loginid => $self->loginid,
        context => $self->{context});
    # Fall back to email if loginid does not work
    # in case that the user object is created but the client has not been registered into it.
    $user //= BOM::User->new(
        email   => $self->email,
        context => $self->{context});

    return $user;
}

=head2 is_available

return false if client is disabled or is duplicated account

=cut

sub is_available {
    my $self = shift;
    foreach my $status (qw(disabled duplicate_account)) {
        return 0 if $self->status->$status();
    }
    return 1;
}

=head2 real_account_siblings_information

Returns information about real siblings of current client, including loginid, landing company name, currency and balance, taking following named args:

=over 4

=item * C<include_disabled> - wether or not include disabled sibling accounts

=item * C<include_self> - if true, the current client will be included in the result; otherwise it will be excluded (the default bahavior).

=item * C<exclude_disabled_no_currency> - if true, disabled siblings with no currency will be excluded; otherwise (default) they will be included.

=item * C<landing_company> - if it's not empty, only siblings of the given landing company will be returned;
    otherwise (default) there won't be any filter applied on landing companiesd.

=item * include_wallet - include wallet accounts (default 1).

=back

=cut

sub real_account_siblings_information {
    my ($self, %args) = @_;

    return $self->get_siblings_information(%args, include_virtual => 0);
}

=head2 get_siblings_information

Gets a list of siblings as a hash ref with keys: loginid, currency, balance, account_type (binary, wallet, ...), demo_account and disabled.
It filters siblings with following args:

=over

=item * include_self - include the current object in the result (default 1).

=item * include_disabled - include disabled sublings (default 1).

=item * include_virtual - include virtual accounts (default 1).

=item * include_wallet - include wallet accounts (default 1).

=item *  exclude_disabled_no_currency - exclude disabled siblings with no currency (default 0).

=item * include_duplicated - return duplicated siblings as well (default 0)

=item * C<landing_company> - if it's not empty, only siblings of the given landing companh will be returned;
    otherwise (default) there won't be any filter applied on landing companiesd.

=back

Returns B<value> of field or the whole B<data field> if field is null.

=cut

sub get_siblings_information {
    my ($self, %args) = @_;
    my $include_self                 = $args{include_self}     // 1;
    my $include_disabled             = $args{include_disabled} // 1;
    my $include_virtual              = $args{include_virtual}  // 1;
    my $include_wallet               = $args{include_wallet}   // 1;
    my $exclude_disabled_no_currency = $args{exclude_disabled_no_currency};
    my $include_duplicated           = $args{include_duplicated};
    my $landing_company              = $args{landing_company};

    my $user = $self->user;
    # return empty if we are not able to find user, this should not
    # happen but added as additional check
    return {} unless $user;

    my @clients = $user->clients(
        include_disabled   => $include_disabled,
        include_duplicated => $include_duplicated,
        db_operation       => $self->get_db,
    );

    unless ($include_virtual) {
        @clients = grep { not $_->is_virtual } @clients;
    }

    unless ($include_wallet) {
        # filter out wallet accounts
        @clients = grep { not $_->is_wallet } @clients;
    }

    if ($landing_company) {
        @clients = grep { $_->landing_company->short eq $landing_company } @clients;
    }

    if ($exclude_disabled_no_currency) {
        # filter out disabled & no currency clients
        @clients = grep { not($_->status->disabled && !$_->default_account) } @clients;
    }

    my $siblings = {};
    foreach my $cl (@clients) {
        my $acc     = $cl->default_account;
        my $balance = $acc ? formatnumber('amount', $acc->currency_code(), $acc->balance) : "0.00";

        $siblings->{$cl->loginid} = {
            loginid              => $cl->loginid,
            landing_company_name => $cl->landing_company->short,
            currency             => $acc ? $acc->currency_code() : '',
            balance              => $balance,
            account_type         => $cl->get_account_type->name,
            category             => $cl->get_account_type->category->name,
            demo_account         => $cl->is_virtual,
            disabled             => $cl->status->disabled ? 1 : 0,
            $cl->status->duplicate_account ? (duplicate => 1) : ()}
            unless (!$include_self && ($cl->loginid eq $self->loginid));
    }

    return $siblings;
}

=head2 is_tnc_approval_required

Returns true if client needs to accept terms & conditions for the current brand and landing company.

=cut

sub is_tnc_approval_required {
    my $self = shift;

    return 0 if $self->is_virtual;
    return 0 unless $self->landing_company->tnc_required;
    my $version = $self->user->current_tnc_version or return 0;
    return $version ne $self->user->latest_tnc_version;
}

=head2 accepted_tnc_version

Returns latest terms & conditions version accepted by user for current brand.
Always empty for virtual landing company.

=cut

sub accepted_tnc_version {
    my $self = shift;

    return '' if $self->is_virtual;
    return $self->user->latest_tnc_version;
}

=head2 is_payout_freezing_funds_enabled

returns true is freezing funds for payout is enabled considering both system and client landing company settings, false otherwise

=cut

sub is_payout_freezing_funds_enabled {
    my $self = shift;

    return (
        # is payout freezing funds enabled for this user's landing company?
        $self->landing_company->payout_freezing_funds
            # is payout freezing funds enabled system-wide, i.e. not suspended?
            && !BOM::Config::Runtime->instance->app_config->system->suspend->payout_freezing_funds
    );
}

sub user_id {
    my $self = shift;
    return $self->binary_user_id // $self->user->{id};
}

sub status {
    my $self = shift;
    if (not $self->{status}) {
        $self->{status} = BOM::User::Client::Status->new({
            client_loginid => $self->loginid,
            dbic           => $self->db->dbic
        });
    }

    return $self->{status};
}

sub documents {
    my $self = shift;

    return $self->{documents} //= do {
        $self->{documents} = BOM::User::Client::AuthenticationDocuments->new({
            client => $self,
        });
    };
}

sub proof_of_ownership {
    my $self = shift;

    return $self->{proof_of_ownership} //= BOM::User::Client::ProofOfOwnership->new({client => $self});
}

=head2 proof_of_income

Returns proof_of_income

=cut

sub proof_of_income {
    my $self = shift;

    return $self->{proof_of_income} //= '';
}

=head2 is_pa_and_authenticated

Returns status of payment agent

=cut

sub is_pa_and_authenticated {
    my $self = shift;
    return 0 unless my $pa = $self->get_payment_agent();

    my $status = $pa->status // '';
    return $status eq 'authorized' ? 1 : 0;
}

sub is_same_user_as {
    my ($self, $other_client) = @_;

    return 0 unless $self;

    return 0 unless $other_client;

    return $self->binary_user_id == $other_client->binary_user_id ? 1 : 0;
}

=head2 get_mt5_details

returns hashref contains information we need for MT5 clients

=cut

sub get_mt5_details {
    my $self = shift;
    return {
        name    => $self->first_name . ' ' . $self->last_name,
        email   => $self->email,
        address => $self->address_1,
        phone   => $self->phone,
        state   => $self->state,
        city    => $self->city,
        zipCode => $self->postcode,
        country => Locale::Country::Extra->new()->country_from_code($self->residence),
    };
}

=head2 missing_requirements

Returns a list of missing entries of fields of a given requirement (defaults to signup requirement).

=cut

sub missing_requirements {
    my $self        = shift;
    my $requirement = shift // "signup";

    my $requirements = $self->landing_company->requirements->{$requirement};
    my @missing;

    for my $detail (@$requirements) {
        push(@missing, $detail) unless $self->$detail;
    }

    return @missing;
}

=head2 is_region_eu

return 1 or 0 according to client's landing company or the residence for VRT client.

=cut

sub is_region_eu {
    my ($self) = @_;

    if ($self->is_virtual) {

        my $countries_instance = request()->brand->countries_instance;
        my $company            = $countries_instance->real_company_for_country($self->residence);

        return LandingCompany::Registry->by_name($company)->is_eu;
    } else {
        return $self->landing_company->is_eu;
    }

}

=head2 get_open_contracts

Returns the list of open contracts for a given client

=cut

sub get_open_contracts {
    my $self = shift;

    return BOM::Database::ClientDB->new({
            client_loginid => $self->loginid,
            operation      => 'replica',
        })->getall_arrayref('select * from bet.get_open_bets_of_account(?,?,?)', [$self->loginid, $self->currency, 'false']);
}

=head2 increment_social_responsibility_values

Pass in an hashref and increment the social responsibility values in redis

=cut

sub increment_social_responsibility_values {
    my ($self, $sr_hashref) = @_;
    my $loginid = $self->loginid;

    my $event_name = $loginid . ':sr_check:';

    my $redis = BOM::Config::Redis::redis_events();

    # We need to emit an event for each SR threshold breached, unless Compliance
    # is already monitoring the client for this specific threshold

    foreach my $attribute (keys %$sr_hashref) {
        my $field_name = $event_name . $attribute;
        my $value      = $sr_hashref->{$attribute};

        $redis->multi();

        $redis->set(
            $field_name,
            '0',
            'EX' => SR_30_DAYS_EXP,
            'NX'
        );

        $redis->incrbyfloat($field_name, $value);

        $redis->exec();

        BOM::Platform::Event::Emitter::emit(
            'social_responsibility_check',
            {
                loginid   => $loginid,
                attribute => $attribute
            }) unless ($redis->get($field_name . ":email"));
    }

    return undef;
}

=head2 is_verification_required

Check if client needs account verifcation
(both proof of identity and proof of address)

=begin comment

These are the current regulations for when do we
need to ask client to submit proof of identity (POI)
and proof of address (POA)

    Labuan
      POI: Upon signup
      POA: Upon signup
    Vanuatu
      POI: Upon signup
      POA: Upon signup
    CR
      POI: High risk, withdrawals above 8k
      POA: High risk, withdrawals above 8k
    MLT
      POI: Upon first successful deposit
      POA: Upon first successful deposit

Currently both requirements are same so currently the sub has no
separate logic for them.

=end comment

=cut

sub is_verification_required {
    my ($self, %args) = @_;

    return 0 if $self->is_virtual;

    return 0 if $self->landing_company->skip_authentication;

    return 0 if $self->fully_authenticated and $self->status->age_verification;

    my $country_config = request()->brand->countries_instance->countries_list->{$self->residence};
    if ($args{check_authentication_status}) {
        return 1 if ($self->authentication_status // '') eq 'needs_action';
        return 1 if ($country_config->{require_poi} and not $self->get_authentication('ID_ONLINE'));
    }

    # applicable for all landing companies
    return 1 if ($args{risk_sr}  // '') eq 'high';
    return 1 if ($args{risk_aml} // '') eq 'high';
    my $has_deposits = $self->has_deposits();
    return 1
        if ($self->landing_company->short =~ /^(?:malta|iom)$/
        and not $country_config->{skip_deposit_verification}
        and $has_deposits);
    return 1 if $self->landing_company->first_deposit_auth_check_required and $has_deposits;
    return 1
        if ($country_config->{require_verification_when_not_age_verified}
        and not $self->status->age_verification);

    # we need to check if mt5 group is for
    # labuan - regulated one, if yes then it needs authentication
    return 1
        if ($args{has_mt5_regulated_account} // $self->user->has_mt5_regulated_account())
        and ($self->landing_company->first_deposit_auth_check_required and $has_deposits);
    return 1 if ($args{has_mt5_regulated_account} && !$self->landing_company->first_deposit_auth_check_required);

    return 0;
}

=head2 is_document_expiry_check_required

Check if we need to validate for expired documents.

=cut

sub is_document_expiry_check_required {
    my $self = shift;

    return 1 if $self->user->has_mt5_regulated_account(use_mt5_conf => 1);

    return 1 if $self->landing_company->documents_expiration_check_required();

    return 1 if ($self->aml_risk_classification // '') eq 'high';

    return 1 if $self->get_payment_agent;

    return 1 if $self->risk_level_sr() eq 'high';

    return 0;
}

=head2 is_document_expiry_check_required_mt5

Check if we need to validate for expired documents

In addition to is_document_expiry_check_required it
checks if user has mt5 regulated account

Separate sub is needed as don't want to block normal
cashier for client if they have mt5 regulated accounts

=cut

sub is_document_expiry_check_required_mt5 {
    my ($self, %args) = @_;

    return 1 if $self->is_document_expiry_check_required();

    return 1 if $args{has_mt5_regulated_account} // $self->user->has_mt5_regulated_account(use_mt5_conf => 1);

    return 0;
}

=head2 increment_qualifying_payments

Pass in a hashref and increment the qualifying payment check values, which
is either deposit or withdrawals.

If no key is present, a new key is set with an expiry of 30 days (Regulation as at 14th August, 2019)
Otherwise, increment existing key

=cut

sub increment_qualifying_payments {
    my ($self, $args) = @_;
    my $loginid = $self->loginid;

    my $redis     = BOM::Config::Redis::redis_events();
    my $redis_key = $loginid . '_' . $args->{action} . '_qualifying_payment_check';

    my $payment_check_limits = BOM::Config::payment_limits()->{qualifying_payment_check_limits}->{$self->landing_company->short};

    if ($redis->exists($redis_key)) {
        # abs() is used, as withdrawal transactions have negative amount
        $redis->incrbyfloat($redis_key => abs($args->{amount}));
    } else {
        $redis->set(
            $redis_key => $args->{amount},
            EX         => 86400 * $payment_check_limits->{for_days});
    }

    my $event_name = $loginid . '_qualifying_payment_check';
    BOM::Platform::Event::Emitter::emit('qualifying_payment_check', {loginid => $loginid}) if $redis->setnx($event_name, 1);

    return undef;
}

=pod

=head2 format_input_details

format the input fields for new_account and set_settings and backoffice

=over 4

=item * $args

Hashref of the input fields

=back

Return {
    error   => C<error_code>
}

=cut

sub format_input_details {
    my ($self, $args) = @_;

    my %format = (
        first_name => sub { trim(shift) },
        last_name  => sub { trim(shift) },
        phone      => sub {
            my $phone = trim(shift) or return '';

            if ($phone =~ qr/^[-.,\s+()]{0,3}(?:\d[-.,\s+()]{0,3}){9,35}$/) {
                # avoid repeated numbers like `111111111111`
                return $phone if $phone !~ qr/^(.)\1*$/;
            }

            die "InvalidPhone\n";
        },
        date_of_birth => sub {
            eval { Date::Utility->new(shift)->date } // die "InvalidDateOfBirth\n";
        },
        address_state => sub {
            my $state     = shift;
            my $residence = $args->{residence};

            return undef unless $residence;

            my $match = BOM::Platform::Locale::validate_state($state, $residence) or die "InvalidState\n";

            return $match->{value};
        });

    try {
        $args->{$_} = $format{$_}->($args->{$_}) for grep { $args->{$_} && exists $format{$_} } keys %$args;
        return undef;
    } catch ($err) {
        chomp($err);
        return {error => $err || 'UnknownError'};
    }
}

=pod

=head2 validate_common_account_details

common client details validation for new_account and set_settings and backoffice

=over 4

=item * C<args> - Hashref of the input fields

=item * C<rule_engine> (optional) - a rule engine object. If rule engine is empty, the whole checks should be done here;
   otherwise, only C<args> will be validated and business rules will be delegated to the rule engine
   (TODO: will be deprecated as soon as rule engine is integrated into all account opening RPC calls).

=back

Return {
    error   => C<error_code>
    details => C<detail info>
}

=cut

sub validate_common_account_details {
    my ($self, $args, $rule_engine) = @_;

    my $residence       = $self->residence;
    my @required_fields = $self->required_fields;

    my $error_details;
    try {
        # Validate required fields, they cannot be changed to empty
        for my $key (sort keys $args->%*) {
            if (any { $_ eq $key } @required_fields) {
                unless (trim($args->{$key})) {
                    $error_details = {field => $key};    # return field that has error
                    die "InputValidationFailed\n";
                }
            }
        }

        if ($args->{date_of_birth}) {
            $self->_validate_dob($args->{date_of_birth}, $residence, $rule_engine);
        }

        ## The secret question can start out as an empty string, but cannot be changed to empty
        die "Secret question cannot be set to empty\n"
            if (defined $args->{secret_question} && !$args->{secret_question} && length($self->secret_question));

        ## Likewise, it is possible for the secret_answer to be blank
        die "Secret answer cannot be set to empty\n"
            if (defined $args->{secret_answer} && !$args->{secret_answer} && length($self->secret_answer));

        ## Question must always come with an answer and vice versa
        die "NeedBothSecret\n" if !$args->{secret_question} ^ !$args->{secret_answer};

        die "InvalidPlaceOfBirth\n" if ($args->{place_of_birth} and not Locale::Country::code2country($args->{place_of_birth}));

        my $brand = request()->brand;

        die "InvalidCitizenship\n"
            if ($args->{'citizen'} && !defined $brand->countries_instance->countries->country_from_code($args->{'citizen'}));

        # The follwing block contains business logic that should have been covered by rule engine (if there's any)
        unless ($rule_engine) {
            my $postcode = $args->{address_postcode} // $self->address_postcode;
            ## If this is non-virtual United Kingdom account, it must have a postcode
            die "PostcodeRequired\n"
                if (request()->brand->countries_instance->countries_list->{$self->residence}->{require_address_postcode}
                and not $self->is_virtual
                and not($postcode));

            ## If this is a United Kingdom account, the postcode should not belong to Jersey
            my $forbidden_postcode_pattern = request()->brand->countries_instance->countries_list->{$self->residence}->{forbidden_postcode_pattern};
            die "ForbiddenPostcode\n"
                if (defined $forbidden_postcode_pattern && $postcode =~ /$forbidden_postcode_pattern/);

            # If not broker code is passed rely on current client landing company.
            # This is remarkably useful for new account calls.
            my $lc =
                (defined $args->{broker_code})
                ? LandingCompany::Registry->by_broker($args->{broker_code})
                : $self->landing_company;

            if ($lc->short =~ /^(?:iom|malta|maltainvest)$/) {
                die "PoBoxInAddress\n"
                    if (($args->{address_line_1} || '') =~ /p[\.\s]+o[\.\s]+box/i
                    or ($args->{address_line_2} || '') =~ /p[\.\s]+o[\.\s]+box/i);
            }
        }

        die "No promotion code was provided\n" if (trim($args->{promo_code_status}) and not(trim($args->{promo_code}) // $self->promo_code));

        $self->_validate_non_pep_time($args->{non_pep_declaration_time}) if $args->{non_pep_declaration_time};

        return undef;
    } catch ($err) {
        return {
            error   => trim($err) || 'UnknownError',
            details => $error_details,
        }
    }
}

=pod

=head2 _validate_dob

Validates date of birth and possibly checks the minumum age, taking following arguments:

=over 4

=item * C<dob> - date of birth as a string or epoch

=item * C<residence> - country of residence

=item * C<rule_engine> (optional) - a rule engine object. If rule engine is empty, the whole checks should be done here;
   otherwise, minimum age won't be checked (TODO: will be deprecated as soon as rule engine is integrated into all account opening RPC calls).

=back

=cut

sub _validate_dob {
    my ($self, $dob, $residence, $rule_engine) = @_;

    my $dob_date = eval { Date::Utility->new($dob) };
    die "InvalidDateOfBirth\n" unless $dob_date;

    return undef if $rule_engine;

    my $countries_instance = request()->brand->countries_instance;

    # Get the minimum age from the client's residence
    my $min_age = $countries_instance && $countries_instance->minimum_age_for_country($residence);
    die "InvalidResidence\n" unless $min_age;

    my $minimum_date = Date::Utility->new->minus_time_interval($min_age . 'y');
    die "BelowMinimumAge\n" if $dob_date->is_after($minimum_date);

    return undef;
}

sub _validate_non_pep_time {
    my ($self, $non_pep_time) = @_;

    my $non_pep_date = eval { Date::Utility->new($non_pep_time) };
    die "InvalidNonPepTime\n" unless $non_pep_date;

    die "TooLateNonPepTime\n" if $non_pep_date->epoch > time;

    return undef;
}

=pod

=head2 required_fields

Returns a list of all requirements (signup, withdrawal, etc) for each landing company.

=cut

sub required_fields {
    my $self = shift;

    return @{BOM::Platform::Utility::hash_to_array($self->landing_company->requirements)};
}

=pod

=head2 benched

Returns a boolean checking if the duplicated account has been replaced or not.

=cut

sub benched {
    my $self = shift;

    if ($self->status->duplicate_account) {
        # without date joined it might be impossible to tell...
        my $date_joined = $self->date_joined ? Date::Utility->new($self->date_joined)->epoch : return 0;

        # without currency it might be impossible to tell...
        my $currency_type = $self->currency ? (BOM::Config::CurrencyConfig::is_valid_crypto_currency($self->currency) ? 'crypto' : 'fiat') : return 0;

        return any { $currency_type eq $_->{currency_type} && $_->{broker_code} eq $self->broker_code && $_->{date_joined} > $date_joined } map {
            # without either date joined or currency it might be impossible to tell...
            $_->date_joined && $_->currency
                ? +{
                broker_code   => $_->broker_code,
                currency_type => BOM::Config::CurrencyConfig::is_valid_crypto_currency($_->currency) ? 'crypto' : 'fiat',
                date_joined   => Date::Utility->new($_->date_joined)->epoch
                }
                : ()
        } $self->user->clients(include_duplicated => 1);
    }

    return 0;
}

=pod

=head2 immutable_fields

Returns a list of profile fields that cannot be changed regarding client's status and landing company settings (unless they are null).

=cut

sub immutable_fields {
    my $self = shift;

    if ($self->is_virtual) {
        my @virtual_immutable_fields = qw/residence/;

        my $duplicated = $self->duplicate_sibling_from_vr;

        # note: we check for is_virtual only to address the potential infinite recursion concern
        # `duplicate_sibling_from_vr` should never return VR account!!
        push @virtual_immutable_fields, $duplicated->immutable_fields if $duplicated && !$duplicated->is_virtual;

        return uniq @virtual_immutable_fields;
    }

    my @immutable = grep { $self->$_ } PROFILE_FIELDS_IMMUTABLE_AFTER_AUTH->@*;

    if (!$self->status->personal_details_locked) {
        # Allow first and last name edition when poi name mismatch (should not be locked though)
        if ($self->status->poi_name_mismatch) {
            @immutable = grep { $_ !~ qr/(first_name|last_name)/ } @immutable;
        }
        # Allow dob edition when poi dob mismatch (should not be locked though)
        if ($self->status->poi_dob_mismatch) {
            @immutable = grep { $_ !~ qr/(date_of_birth)/ } @immutable;
        }
        # Allow address edition when address mismatch (should not be locked though)
        if ($self->status->poa_address_mismatch) {
            @immutable = grep { $_ !~ qr/(address_city|address_line_1|address_line_2|address_postcode|address_state)/ } @immutable;
        }
    }

    # make a duplicate account very immutable
    if ($self->status->duplicate_account) {
        my $dup_reason = $self->status->reason('duplicate_account') // '';

        # check for specific currency change reason
        # also if the client got replaced, there is no point in provoking side effects

        if ($dup_reason =~ /Duplicate account - currency change/ && !$self->benched) {
            my $financial_assessment = $self->financial_assessment() // '';

            $financial_assessment = BOM::User::FinancialAssessment::decode_fa($financial_assessment) if $financial_assessment;

            push @immutable,
                grep { $financial_assessment && $financial_assessment->{$_} && $self->landing_company->short eq 'maltainvest' }
                FA_FIELDS_IMMUTABLE_DUPLICATED->@*;

            return uniq(@immutable, PROFILE_FIELDS_IMMUTABLE_DUPLICATED->@*);
        }

        # dont care about any other reason buy currency change
        # the account should be considered dead at this point, provoking no side effects at all

        return ();
    }

    # we will push here the fields that should be immutable no matter what
    my @locked_fields = ();
    my $auth;

    # Add address fields to immutable array if address verified
    if ($self->status->address_verified) {
        unless ($self->get_poa_status eq 'expired') {
            push @locked_fields, ADDRESS_FIELDS->@*;
            $auth = 1;
        }
    }

    # Add address fields to immutable array if fully authenticated
    if ($self->fully_authenticated) {
        unless ($self->get_poa_status eq 'expired') {
            push @locked_fields, ADDRESS_FIELDS->@*;
            $auth = 1;
        }
    }

    # Add first name, last name and DOB to immutable if poi verified
    if ($self->status->age_verification) {
        push @locked_fields, IMMUTABLE_FIELDS_AGE_VERIFICATION->@*;
        $auth = 1;
    }

    my @siblings = $self->user ? $self->user->clients(include_duplicated => 1) : ($self);

    # we will push here all the fields that should be spared from immutability
    my @changeable = ();

    for my $sibling (@siblings) {
        next if $sibling->is_virtual;

        # we will grab immutable fields from duplicated accounts as they are
        if ($sibling->status->duplicate_account) {
            # note this would be an infinite recursive call for a non `duplicate_account`
            # make damn sure is the case :)
            @locked_fields = uniq(@locked_fields, $sibling->immutable_fields);

            next;
        }

        my $company_settings = $sibling->landing_company->changeable_fields;

        # if the the locked status is on, we might want to ensure the included fields are immutable
        my $immutable_if_locked = $company_settings->{personal_details_not_locked} // [];
        @locked_fields = uniq(@locked_fields, @$immutable_if_locked) if $sibling->status->personal_details_locked;

        next if $auth;

        my $changeable_fields_in_company = $company_settings->{only_before_auth} // [];
        # we will simply stack the changeable fields that would be spared from immutability
        @changeable = uniq(@changeable, @$changeable_fields_in_company);
    }

    # remove locked fields from the changeable list
    @changeable = array_minus(@changeable, @locked_fields);

    # combine locked and immutable
    @immutable = uniq(@immutable, @locked_fields);

    return array_minus(@immutable, @changeable);
}

=pod

=head2 check_duplicate_account

check if the input fields match any exists account

=over 4

=item * $args

Hashref of the input fields

=back

Return undef if there is not need to check for duplicate account or if there is no duplicate account found for the given user information

Return {
    error   => C<error_code>
    details => C<dup_account_details>
}

=cut

sub check_duplicate_account {
    my ($self, $args) = @_;

    # Get target broker code either from $args or client itself
    my $target_broker = $args->{broker_code} // $self->broker_code;

    # If client is going to update his virtual account there is no need to check for duplicate account
    return undef if $target_broker =~ VIRTUAL_REGEX;

    my $checks = ['first_name', 'last_name', 'date_of_birth'];

    if (any { $args->{$_} and defined $self->$_ and $args->{$_} ne $self->$_ } @$checks) {
        my $dup_details = {
            email          => $self->email,
            exclude_status => ['duplicate_account']};
        $dup_details->{$_} = $args->{$_} || $self->$_ for @$checks;

        my $countries = request()->brand->countries_instance;

        # check for duplicates in current and all uprgradeable landing companies
        my @real_companies =
            uniq grep { $_ } ($countries->gaming_company_for_country($self->residence), $countries->financial_company_for_country($self->residence));
        my @broker_codes = map { LandingCompany::Registry->by_name($_)->broker_codes->@* } @real_companies;

        for my $broker_code (@broker_codes) {
            my @dup_account_details = BOM::Database::ClientDB->new({broker_code => $broker_code})->get_duplicate_client($dup_details);
            return {
                error   => 'DuplicateAccount',
                details => \@dup_account_details
            } if scalar @dup_account_details;
        }
    }
    return undef;
}

=head1 METHODS - P2P cashier

=cut

use constant {
    # For some currency pairs we need to have limit so big for example: VND/BTC
    # Also this limit may need to be adjusted in future.
    P2P_RATE_LOWER_LIMIT => 0.000001,    # We need it because 0.000001 < 0.1**6 is true
    P2P_RATE_UPPER_LIMIT => 10**9,

    P2P_MAXIMUM_ACTIVE_ADVERTS     => 10,
    P2P_COUNTERYPARTY_TYPE_MAPPING => {
        buy  => 'sell',
        sell => 'buy',
    },

    P2P_ORDER_DISPUTED_AT               => 'P2P::ORDER::DISPUTED_AT',
    P2P_ORDER_EXPIRES_AT                => 'P2P::ORDER::EXPIRES_AT',
    P2P_ORDER_TIMEDOUT_AT               => 'P2P::ORDER::TIMEDOUT_AT',
    P2P_ORDER_REVIEWABLE_START_AT       => 'P2P::ORDER::REVIEWABLE_START_AT',
    P2P_ORDER_PARTIES                   => 'P2P::ORDER::PARTIES',                 # as soon as order created the party will be added to this set
    P2P_ADVERTISER_BLOCK_ENDS_AT        => 'P2P::ADVERTISER::BLOCK_ENDS_AT',
    P2P_STATS_REDIS_PREFIX              => 'P2P::ADVERTISER_STATS',
    P2P_STATS_TTL_IN_DAYS               => 120,                                   # days after which to prune redis stats
    P2P_ARCHIVE_DATES_KEY               => 'P2P::AD_ARCHIVAL_DATES',
    P2P_USERS_ONLINE_KEY                => 'P2P::USERS_ONLINE',
    P2P_ONLINE_PERIOD                   => 90,
    P2P_ORDER_LAST_SEEN_STATUS          => 'P2P::ORDER::LAST_SEEN_STATUS',
    P2P_TOKEN_MIN_EXPIRY                => 2 * 60 * 60,                           # 2 hours. Sendbird token min expiry
    P2P_VERIFICATION_REQUEST_INTERVAL   => 60,                                    # min seconds between order verification requests
    P2P_VERIFICATION_TOKEN_EXPIRY       => 10 * 60,                               # tokens expire after 10 min
    P2P_VERIFICATION_MAX_ATTEMPTS       => 3,                                     # number of unsucsessful attempts before lockout
    P2P_VERIFICATION_LOCKOUT_TTL        => 30 * 60,                               # 30 min lockout after too many unsucsessful attempts
    P2P_VERIFICATION_ATTEMPT_KEY        => 'P2P::ORDER::VERIFICATION_ATTEMPT',    # sorted set to track verification attempts
    P2P_VERIFICATION_HISTORY_KEY        => 'P2P::ORDER::VERIFICATION_HISTORY',    # list of verification events for backoffice
    P2P_VERIFICATION_EVENT_KEY          => 'P2P::ORDER::VERIFICATION_EVENT',      # sorted set of verification events that occur in the future
    P2P_ADVERTISER_BAND_UPGRADE_PENDING =>
        'P2P::ADVERTISER_BAND_UPGRADE_PENDING',    #if advertiser eligible for band upgrade, store the next available band limits and stats here
    P2P_ADVERTISER_BAND_UPGRADE_COMPLETED =>
        'P2P::ADVERTISER_BAND_UPGRADE_COMPLETED',    #if upgrade success, delete entry from ADVERTISER_BAND_UPGRADE_PENDING and store data here

    # Statuses here should match the DB function p2p.is_status_final.
    P2P_ORDER_STATUS => {
        active => [qw(pending buyer-confirmed timed-out disputed)],
        final  => [qw(completed cancelled refunded dispute-refunded dispute-completed)],
    },

    P2P_ORDER_EXPIRE_OPTIONS => {map { $_ => 1 } qw(900 1800 2700 3600 5400 7200)},

    P2P_DB_ERR_MAP => {
        PP001 => "AdvertNotFound",
        PP002 => "OrderMaximumExceeded",
        PP003 => "OrderMinimumNotMet",
        PP004 => "ClientDailyOrderLimitExceeded",
        PP005 => "OrderCreateFailAmount",
        PP006 => "OrderCreateFailAmount",
        PP007 => "OrderCreateFailAmount",
        PP008 => "OrderCreateFailAmount",
        PP009 => "InvalidAdvertOwn",
        PP010 => "OrderCreateFailAmountAdvertiser",
        PP011 => "OpenOrdersDeleteAdvert",
        PP012 => "PaymentMethodRemoveActiveOrdersDB",
        PP013 => "DuplicatePaymentMethod",
        PP014 => "OrderConfirmCompleted",
        PP015 => "OrderConfirmCompleted",
        PP016 => "OrderRefundInvalid",
        PP017 => "OrderConfirmCompleted",
        PP018 => "OrderConfirmCompleted",
        PP018 => "OrderConfirmCompleted",
        PP019 => 'OrderNotFound',
        PP020 => 'AlreadyInProgress',
        PP021 => "OrderRefundInvalid",
        PP022 => 'OrderNotConfirmedPending',
        PP023 => 'OrderConfirmCompleted',
        PP024 => 'OrderReviewExists',
        PP025 => 'AdvertiserExist'

    },
};

=head2 p2p_settings

Returns general P2P settings. If subscribe:1, will add subscription_info which contains client's residence
which will be used to create subsciption channel in websocket layer and deleted as it's not part of response

Takes the following named parameters:

=over 4

=item * C<subscribe> - flag to indicate if this call includes subscription (optional)

=back

Returns, a C<hashref> containing the P2P settings.

=cut

sub p2p_settings {
    my ($self, %param) = @_;
    my $residence = $self->residence;
    die +{error_code => 'RestrictedCountry'} unless BOM::Config::P2P::advert_config()->{$residence};
    my $result = BOM::User::Utility::get_p2p_settings(country => $residence);
    $result->{subscription_info} = {country => $residence} if $param{subscribe};
    return $result;
}

=head2 p2p_advertiser_create

Attempts to register client as an advertiser.
Returns the advertiser info or dies with error code.

=cut

sub p2p_advertiser_create {
    my ($self, %param) = @_;
    my $name = trim($param{name});

    die +{error_code => 'AlreadyRegistered'} if $self->_p2p_advertiser_cached;

    die +{error_code => 'AdvertiserNameRequired'} unless $name;
    die +{error_code => 'AdvertiserNameTaken'} if $self->_p2p_advertisers(unique_name => $name)->[0];

    my $lc_withdrawal_limit   = BOM::Config::payment_limits()->{withdrawal_limits}{$self->landing_company->short}{lifetime_limit};
    my $p2p_create_order_chat = BOM::Config::Runtime->instance->app_config->payments->p2p->create_order_chat;

    my ($advertiser, $token, $expiry);
    unless ($p2p_create_order_chat) {
        my ($id) = $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_array("SELECT nextval('p2p.advertiser_serial')");
            });
        my $sb_api     = BOM::User::Utility::sendbird_api();
        my $sb_user_id = join '_', 'p2puser', $self->broker_code, $id, time;
        my $sb_user;
        try {
            $sb_user = $sb_api->create_user(
                user_id             => $sb_user_id,
                nickname            => $name,
                profile_url         => '',
                issue_session_token => 'true'
            );
        } catch {
            die +{error_code => 'AdvertiserCreateChatError'};
        }
        # sb api returns milliseconds timestamps
        ($token, $expiry) = ($sb_user->session_tokens->[0]{session_token}, int($sb_user->session_tokens->[0]{expires_at} / 1000));

        die +{error_code => 'AlreadyRegistered'} if $self->_p2p_advertiser_cached;

        $advertiser = $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_hashref(
                    'SELECT * FROM p2p.advertiser_create(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                    undef,             $id,    $self->loginid, $name, @param{qw/default_advert_description payment_info contact_info/},
                    $sb_user->user_id, $token, $expiry,        $lc_withdrawal_limit
                );
            });
    } else {
        $advertiser = $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_hashref(
                    'SELECT * FROM p2p.advertiser_create_v2(?, ?, ?, ?, ?, ?)',
                    undef, $self->loginid, $name, @param{qw/default_advert_description payment_info contact_info/},
                    $lc_withdrawal_limit
                );
            });
    }

    unless ($self->status->age_verification or $self->status->allow_document_upload) {
        $self->status->upsert('allow_document_upload', 'system', 'P2P_ADVERTISER_CREATED');
    }

    BOM::Config::Redis->redis_p2p_write->zadd(P2P_USERS_ONLINE_KEY, 'NX', time, join('::', $self->loginid, $self->residence));

    $self->_p2p_convert_advertiser_limits($advertiser);
    my $details = $self->_advertiser_details($advertiser);

    BOM::Platform::Event::Emitter::emit(
        p2p_advertiser_created => {
            client_loginid => $self->loginid,
            $details->%*
        });

    return $details;
}

=head2 p2p_advertiser_info

Returns advertiser info of param{id} otherwise current client.

=cut

sub p2p_advertiser_info {
    my ($self, %param) = @_;

    my $advertiser;
    if (exists $param{id}) {
        $advertiser = $self->_p2p_advertisers(id => $param{id})->[0];
    } else {
        $advertiser = $self->_p2p_advertiser_cached;
    }

    return unless $advertiser;
    my $details = $self->_advertiser_details($advertiser);

    $details->{client_loginid} = $advertiser->{client_loginid} if $param{subscribe};    # will be removed in websocket

    return $details;
}

=head2 p2p_advertiser_list

returns advertiser partners

=cut

sub p2p_advertiser_list {
    my ($self, %param) = @_;
    my $advertiser_info = $self->_p2p_advertiser_cached;

    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;

    $param{id}             = $advertiser_info->{id};
    $param{client_loginid} = $advertiser_info->{client_loginid};

    my $list = [];
    if ($param{trade_partners}) {
        $list = $self->_p2p_advertiser_trade_partners(%param);
    }

    return [map { $self->_advertiser_details($_) } $list->@*];
}

=head2 _p2p_advertiser_trade_partners

All the trade partners from DB

=cut

sub _p2p_advertiser_trade_partners {
    my ($self, %param) = @_;

    $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(
                'SELECT * FROM p2p.advertiser_partner_list(?, ?, ?, ?, ?, ?, ?, ?)',
                {Slice => {}},
                @param{qw/id advertiser_name is_blocked is_favourite is_recommended limit offset sort_by /});
        }) // [];
}

=head2 p2p_advertiser_blocked

Returns true if the advertiser is blocked.

=cut

sub p2p_is_advertiser_blocked {
    my $self       = shift;
    my $advertiser = $self->_p2p_advertiser_cached;
    return $advertiser && !$advertiser->{is_enabled};
}

=head2 p2p_advertiser_update

Updates the client advertiser info with fields in %param.
Returns latest advertiser info.

=cut

sub p2p_advertiser_update {
    my ($self, %param) = @_;

    my $advertiser_info = $self->p2p_advertiser_info;
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;
    die +{error_code => 'AdvertiserNotApproved'}   unless $advertiser_info->{is_approved} or defined $param{is_approved};

    # Return the current information of the advertiser if nothing changed
    return $advertiser_info
        unless grep { exists $advertiser_info->{$_} and $param{$_} ne $advertiser_info->{$_} } keys %param
        or exists $param{show_name}
        or $param{upgrade_limits};

    if (exists $param{name}) {
        $param{name} = trim($param{name});
        die +{error_code => 'AdvertiserNameRequired'} unless $param{name};
        die +{error_code => 'AdvertiserNameTaken'}
            if $param{name} ne $advertiser_info->{name} and $self->_p2p_advertisers(name => $param{name})->[0];
    }

    die +{error_code => 'AdvertiserCannotListAds'} if $param{is_listed} and not $advertiser_info->{is_approved} and not $param{is_approved};
    $param{is_listed} = 0 if defined $param{is_approved} and not $param{is_approved};

    my $redis = BOM::Config::Redis->redis_p2p_write();
    my $band_upgrade;

    if ($param{upgrade_limits}) {
        $band_upgrade = $redis->hget(P2P_ADVERTISER_BAND_UPGRADE_PENDING, $advertiser_info->{id})
            or die +{error_code => 'AdvertiserNotEligibleForLimitUpgrade'};

        try {
            $band_upgrade = decode_json_utf8($band_upgrade);
            $param{trade_band} = lc($band_upgrade->{target_trade_band});
        } catch ($e) {
            $log->warnf(
                'Invalid JSON stored for advertiser id: %s with data: %s at REDIS HASH KEY: %s. Error: %s',
                $advertiser_info->{id},
                $band_upgrade, P2P_ADVERTISER_BAND_UPGRADE_PENDING, $e
            );
            die +{error_code => 'P2PLimitUpgradeFailed'};
        }
    }

    my $update = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref(
                'SELECT * FROM p2p.advertiser_update_v2(?, ?, ?, ?, ?, ?, ?, NULL, NULL, NULL, ?, NULL, NULL, ?, NULL)',
                undef,
                $advertiser_info->{id},
                @param{qw/is_approved is_listed name default_advert_description payment_info contact_info trade_band show_name/});
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_advertiser_updated => {
            client_loginid => $self->loginid,
        },
    );

    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $advertiser_info->{id},
        });

    # double check if band upgrade was successfull
    if ($param{trade_band}) {
        $redis->hdel(P2P_ADVERTISER_BAND_UPGRADE_PENDING, $advertiser_info->{id});

        # save data for internal email
        $band_upgrade->@{qw(old_sell_limit old_buy_limit country upgrade_date)} =
            ($advertiser_info->@{qw/daily_sell_limit daily_buy_limit/}, $self->residence, time);
        $band_upgrade->{old_block_trade} = exists $advertiser_info->{block_trade} ? 1 : 0;

        $redis->hset(P2P_ADVERTISER_BAND_UPGRADE_COMPLETED, $advertiser_info->{id}, encode_json_utf8($band_upgrade))
            if $band_upgrade->{email_alert_required};

        BOM::Platform::Event::Emitter::emit(
            p2p_limit_changed => {
                loginid           => $self->loginid,
                advertiser_id     => $advertiser_info->{id},
                new_sell_limit    => formatnumber('amount', $band_upgrade->{account_currency}, $band_upgrade->{target_max_daily_sell}),
                new_buy_limit     => formatnumber('amount', $band_upgrade->{account_currency}, $band_upgrade->{target_max_daily_buy}),
                block_trade       => $band_upgrade->{target_block_trade},
                account_currency  => $band_upgrade->{account_currency},
                change            => 1,
                automatic_approve => 0,
            });
    }

    $self->_p2p_convert_advertiser_limits($update);
    my $response = $self->_advertiser_details($update);
    return $response;
}

=head2 p2p_advertiser_relations

Updates and returns favourite and blocked advertisers

=cut

sub p2p_advertiser_relations {
    my ($self, %param) = @_;

    my $advertiser_info = $self->_p2p_advertiser_cached;
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;

    my @relation_ids = map { ($_ // [])->@* } @param{qw(add_favourites add_blocked remove_favourites remove_blocked)};

    if (@relation_ids) {
        die +{error_code => 'AdvertiserNotApprovedForBlock'} if ($param{add_blocked} // [])->@* and not $advertiser_info->{is_approved};

        my $bar_error = $self->_p2p_get_advertiser_bar_error($advertiser_info);
        die $bar_error if $bar_error;

        die +{error_code => 'AdvertiserRelationSelf'} if any { $_ == $advertiser_info->{id} } @relation_ids;

        my %relations = $self->db->dbic->run(
            fixup => sub {
                $_->selectall_hashref('SELECT * FROM p2p.advertiser_id_check(?)', 'id', undef, \@relation_ids);
            })->%*;

        die +{error_code => 'InvalidAdvertiserID'} unless all { $relations{$_} } @relation_ids;

        $self->db->dbic->run(
            fixup => sub {
                $_->do(
                    'SELECT p2p.advertiser_relation_update(?, ?, ?, ?, ?)',
                    undef,
                    $advertiser_info->{id},
                    @param{qw/add_favourites add_blocked remove_favourites remove_blocked/});
            });

        # is_favourite/is_blocked can change on subscribed advertisers and ads
        for my $id (uniq @relation_ids) {
            BOM::Platform::Event::Emitter::emit(
                p2p_advertiser_updated => {
                    client_loginid => $relations{$id}->{loginid},
                });

            BOM::Platform::Event::Emitter::emit(
                p2p_adverts_updated => {
                    advertiser_id => $id,
                });
        }
    }

    return $self->_p2p_advertiser_relation_lists;
}

=head2 p2p_advertiser_adverts

Returns a list of adverts belonging to current client

=cut

sub p2p_advertiser_adverts {
    my ($self, %param) = @_;

    my $advertiser_info = $self->_p2p_advertiser_cached;
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;

    my $list = $self->_p2p_adverts(
        %param,
        advertiser_id => $advertiser_info->{id},
        country       => $self->residence
    );
    return $self->_advert_details($list);
}

=head2 p2p_advert_create

Creates an advert with %param with client as advertiser.
Returns new advert or dies with error code.

=cut

sub p2p_advert_create {
    my ($self, %param) = @_;

    my $advertiser_info = $self->_p2p_advertiser_cached;
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;
    die +{error_code => 'AdvertiserNotApproved'}   unless $advertiser_info->{is_approved};

    my $bar_error = $self->_p2p_get_advertiser_bar_error($advertiser_info);
    die $bar_error if $bar_error;

    die +{error_code => 'AdvertPaymentMethodParam'}
        if trim($param{payment_method})
        and (($param{payment_method_ids} and $param{payment_method_ids}->@*) or ($param{payment_method_names} and $param{payment_method_names}->@*));

    if (defined($param{order_expiry_period})) {
        if ($param{order_expiry_period} !~ /^[0-9]+$/ || !P2P_ORDER_EXPIRE_OPTIONS->{$param{order_expiry_period}}) {
            die +{error_code => 'InvalidOrderExpiryPeriod'};
        }
    }
    $param{country}          = $self->residence;
    $param{account_currency} = $self->currency;
    ($param{local_currency} //= $self->local_currency) or die +{error_code => 'NoLocalCurrency'};
    $param{advertiser_id}  = $advertiser_info->{id};
    $param{is_active}      = 1;                            # we will validate this as an active ad
    $param{local_currency} = uc($param{local_currency});

    $self->_validate_cross_border_availability if $param{local_currency} ne uc($self->local_currency);
    $self->_validate_block_trade_availability  if $param{block_trade};
    $self->_validate_advert(%param);

    my $market_rate = p2p_exchange_rate($param{local_currency})->{quote};
    die +{error_code => 'AdvertFloatRateNotAllowed'} if $param{rate_type} eq 'float' and not $market_rate;

    my ($id) = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_array(
                'SELECT id FROM p2p.advert_create(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                undef,
                @param{
                    qw/advertiser_id type account_currency local_currency country amount rate min_order_amount max_order_amount description payment_method payment_info contact_info payment_method_ids payment_method_names rate_type block_trade order_expiry_period/
                });
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $advertiser_info->{id},
        });

    # to get all the fields
    my $advert = $self->_p2p_adverts(
        id          => $id,
        market_rate => $market_rate
    )->[0];

    $advert->{payment_method_details} =
        $self->_p2p_advertiser_payment_method_details($self->_p2p_advertiser_payment_methods(advert_id => $id));

    my $response = $self->_advert_details([$advert])->[0];

    BOM::Platform::Event::Emitter::emit(
        p2p_advert_created => {
            loginid             => $self->loginid,
            created_time        => Date::Utility->new($response->{created_time})->db_timestamp,
            advert_id           => $response->{id},
            type                => $response->{type},
            account_currency    => $response->{account_currency},
            local_currency      => $response->{local_currency},
            country             => $response->{country},
            amount              => $response->{amount_display},
            rate                => $response->{rate_display},
            rate_type           => $response->{rate_type},
            min_order_amount    => $response->{min_order_amount_display},
            max_order_amount    => $response->{max_order_amount_display},
            is_visible          => $response->{is_visible},
            order_expiry_period => $response->{order_expiry_period},
        });

    # this is an inverted stat - worse rate = higher score
    my $rate_score;
    if ($param{rate_type} eq 'float') {
        my $diff = $param{type} eq 'sell' ? $param{rate} : -$param{rate};
        $rate_score = $diff / 100;    # api gets float rate as percentage
    } elsif ($market_rate) {
        my $diff = $param{type} eq 'sell' ? $param{rate} - $market_rate : $market_rate - $param{rate};
        $rate_score = $diff / $market_rate;
    }
    $self->_p2p_record_stat(
        loginid => $self->loginid,
        stat    => 'ADVERT_RATES',
        payload => [$id, $rate_score]) if defined $rate_score;

    delete $response->{days_until_archive};    # guard against almost impossible race condition
    return $response;
}

=head2 p2p_advert_info

Get a single advert by id.

=cut

sub p2p_advert_info {
    my ($self, %param) = @_;

    my ($list, $advertiser_id, $account_id);

    if ($param{id}) {
        $param{client_loginid} = $self->loginid;
        $list = $self->_p2p_adverts(%param);
        return undef unless @$list;

        if ($self->loginid eq $list->[0]{advertiser_loginid}) {
            $list->[0]{payment_method_details} =
                $self->_p2p_advertiser_payment_method_details($self->_p2p_advertiser_payment_methods(advert_id => $param{id}));
        } else {
            # remove invalid pms for other viewers
            $list->[0] = $self->filter_ad_payment_methods($list->[0]);
        }

    } elsif ($param{subscribe}) {
        # at this point, advertiser is subscribing to all their ads
        my $advertiser_info = $self->_p2p_advertiser_cached or die +{error_code => 'AdvertiserNotRegistered'};
        $list = $self->_p2p_adverts(
            advertiser_id => $advertiser_info->{id},
            country       => $self->residence
        );
    }

    my $details = $self->_advert_details($list);

    if ($param{subscribe}) {
        if (@$list and $list->[0]{advertiser_loginid} ne $self->loginid) {
            my $owner_client = BOM::User::Client->new({loginid => $list->[0]{advertiser_loginid}, context => $self->{context}});
            $account_id    = $owner_client->account->id;
            $advertiser_id = $list->[0]{advertiser_id};
        }
        $account_id    //= $self->account->id;
        $advertiser_id //= $self->_p2p_advertiser_cached->{id};    # done this way to handle non-advertisers

        BOM::User::Utility::p2p_on_advert_view($advertiser_id, {$self->loginid => {($param{id} // 'ALL') => $details}});

        $details = [] unless $param{id};                           # this call can only return a single ad

        # fields to be removed in websocket
        $details->[0]{advertiser_id}         = $advertiser_id;
        $details->[0]{advertiser_account_id} = $account_id;
    }

    return $details->[0];
}

=head2 p2p_advert_list

Get adverts for client view.
Inactive adverts, unlisted or unapproved advertisers, and max < min are excluded.

=cut

sub p2p_advert_list {
    my ($self, %param) = @_;

    if ($param{block_trade} //= 0) {
        die +{error_code => 'BlockTradeDisabled'} unless BOM::Config::Runtime->instance->app_config->payments->p2p->block_trade->enabled;
    }

    if ($param{counterparty_type}) {
        $param{type} = P2P_COUNTERYPARTY_TYPE_MAPPING->{$param{counterparty_type}};
    }

    my @countries = $self->residence;
    if ($param{local_currency}) {
        $param{local_currency} = uc($param{local_currency});
        my $config = $BOM::Config::CurrencyConfig::ALL_CURRENCIES{uc $param{local_currency}} or die +{error_code => 'InvalidLocalCurrency'};
        push @countries, $config->{countries}->@*;
        $self->_validate_cross_border_availability if $param{local_currency} ne uc($self->local_currency);
    } else {
        $param{country} = $self->residence;
    }

    my %country_payment_methods = map { $_ => [keys $self->p2p_payment_methods($_)->%*] } @countries;

    my $list = $self->_p2p_adverts(
        %param,
        is_active               => 1,
        can_order               => 1,
        advertiser_is_approved  => 1,
        advertiser_is_listed    => 1,
        client_loginid          => $self->loginid,
        account_currency        => $self->currency,
        hide_blocked            => 1,
        country_payment_methods => $json->encode(\%country_payment_methods),
    );

    return $self->_advert_details($list, $param{amount});
}

=head2 p2p_advert_update

Updates the advert of $param{id} with fields in %param.
Client must be advert owner.
Cannot delete if there are open orders.
Returns latest advert info or dies with error code.

=cut

sub p2p_advert_update {
    my ($self, %param) = @_;

    my $id     = $param{id} or die +{error_code => 'AdvertNotFound'};
    my $advert = $self->_p2p_adverts(
        id      => $param{id},
        country => $self->residence
    )->[0];
    die +{error_code => 'AdvertNotFound'} unless $advert;
    die +{error_code => 'PermissionDenied'} if $advert->{advertiser_loginid} ne $self->loginid;

    if (defined($param{order_expiry_period})) {
        if ($param{order_expiry_period} !~ /^[0-9]+$/ || !P2P_ORDER_EXPIRE_OPTIONS->{$param{order_expiry_period}}) {
            die +{error_code => 'InvalidOrderExpiryPeriod'};
        }
    }

    $advert->{remaining_amount} = delete $advert->{remaining};    # named differently in api vs db function

    my %changed_fields = map { (exists $advert->{$_} and ($advert->{$_} // '') ne $param{$_}) ? ($_ => 1) : () } keys %param;

    # return current advert details if nothing changed
    return $self->p2p_advert_info(id => $id)
        if not $param{delete}
        and not $param{payment_method_ids}
        and not $param{payment_method_names}
        and not %changed_fields;

    # upgrade of legacy ads
    $param{payment_method} = ''
        if $advert->{type} eq 'sell'
        and $advert->{payment_method}
        and ($param{payment_method_ids} and $param{payment_method_ids}->@*);
    $param{payment_method} = ''
        if $advert->{type} eq 'buy'
        and $advert->{payment_method}
        and ($param{payment_method_names} and $param{payment_method_names}->@*);

    delete $advert->{payment_method_names} if $advert->{type} eq 'sell';    # the db creates this field for sell ads, but we don't want to validate it

    $param{old} = $advert;
    $self->_validate_advert(%$advert, %param) unless $param{delete};

    if ($param{is_active} and not $advert->{is_active}) {
        # reset archive date, cron will recreate it
        my $redis = BOM::Config::Redis->redis_p2p_write();
        $redis->hdel(P2P_ARCHIVE_DATES_KEY, $id);
    }

    my $updated_advert = $self->db->dbic->run(
        fixup => sub {
            my $dbh = shift;
            return $dbh->selectrow_hashref(
                'SELECT * FROM p2p.advert_update_v2(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                undef, $id,
                @param{
                    qw/is_active delete description payment_method payment_info contact_info payment_method_ids payment_method_names local_currency remaining_amount rate min_order_amount max_order_amount rate_type order_expiry_period/
                });
        });
    $self->_p2p_db_error_handler($updated_advert);

    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $advert->{advertiser_id},
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_advert_orders_updated => {
            advert_id      => $param{id},
            client_loginid => $self->loginid
        }) if any { $changed_fields{$_} } qw/description payment_method_ids payment_method_names/;

    if ($param{delete}) {
        return {
            id      => $id,
            deleted => 1
        };
    } else {
        # to get all the fields
        return $self->p2p_advert_info(id => $id);
    }
}

=head2 p2p_order_create

Creates an order for advert $param{advert_id} with %param for client.
Advert must be active. Advertiser must be active and authenticated.
Only one active order per advert per client is allowed.
Returns new order or dies with error code.
This will move funds from advertiser to escrow.

=cut

sub p2p_order_create {
    my ($self, %param) = @_;

    my ($advert_id, $amount, $payment_info, $contact_info, $source, $rule_engine) =
        @param{qw/advert_id amount payment_info contact_info source rule_engine/};

    die 'Rule engine object is missing' unless $rule_engine;

    my $client_info = $self->_p2p_advertiser_cached;
    die +{error_code => 'AdvertiserNotFoundForOrder'}    unless $client_info;
    die +{error_code => 'AdvertiserNotApprovedForOrder'} unless $client_info->{is_approved};

    my $bar_error = $self->_p2p_get_advertiser_bar_error($client_info);
    die $bar_error if $bar_error;

    my $p2p_config               = BOM::Config::Runtime->instance->app_config->payments->p2p;
    my $limit_per_day_per_client = $p2p_config->limits->count_per_day_per_client;

    my ($day_order_count) = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_array('SELECT * FROM p2p.client_orders_created(?)', undef, $self->loginid);
        });

    die +{
        error_code     => 'ClientDailyOrderLimitExceeded',
        message_params => [$limit_per_day_per_client]}
        if ($day_order_count // 0) >= $limit_per_day_per_client;

    my $advert = $self->_p2p_adverts(
        id                     => $advert_id,
        is_active              => 1,
        can_order              => 1,
        advertiser_is_approved => 1,
        advertiser_is_listed   => 1,
        account_currency       => $self->currency,
        client_loginid         => $self->loginid,
    )->[0];

    die +{error_code => 'AdvertNotFound'} unless $advert and $advert_id;

    $self->_validate_cross_border_availability if lc($advert->{country}) ne lc($self->residence);
    $self->_validate_block_trade_availability  if $advert->{block_trade};

    my $legacy_ad = !($advert->{payment_method_names} and $advert->{payment_method_names}->@*);

    $advert = $self->filter_ad_payment_methods($advert);
    die +{error_code => 'AdvertNotFound'} unless $legacy_ad or $advert->{payment_method_names}->@*;

    die +{error_code => 'InvalidAdvertOwn'}      if $advert->{advertiser_loginid} eq $self->loginid;
    die +{error_code => 'AdvertiserBlocked'}     if $advert->{advertiser_blocked};
    die +{error_code => 'InvalidAdvertForOrder'} if $advert->{client_blocked};

    my $advert_type = $advert->{type};

    my $advertiser_info = $self->_p2p_advertisers(id => $advert->{advertiser_id})->[0];

    $amount = financialrounding('amount', $self->currency, $amount);

    my $limit_remaining = financialrounding('amount', $self->currency,
        $advertiser_info->{'daily_' . $advert_type . '_limit'} - $advertiser_info->{'daily_' . $advert_type});
    die +{
        error_code     => 'OrderMaximumTempExceeded',
        message_params => [$limit_remaining, $self->currency]} if $amount > $limit_remaining;

    die +{error_code => 'OrderCreateFailRateRequired'} if $advert->{rate_type} eq 'float' and not defined($param{rate});

    die +{error_code => 'OrderCreateFailRateChanged'}
        if defined $param{rate} and p2p_rate_rounding($param{rate}) != p2p_rate_rounding($advert->{effective_rate});

    my $advertiser = BOM::User::Client->new({loginid => $advertiser_info->{client_loginid}, context => $self->{context}});
    my ($order_type, $amount_advertiser, $amount_client);

    if ($advert_type eq 'buy') {

        $order_type        = 'sell';
        $amount_advertiser = $amount;
        $amount_client     = -$amount;
        my @payment_method_ids = ($param{payment_method_ids} // [])->@*;

        die +{error_code => 'OrderCreateFailClientBalance'} if $amount > $self->p2p_balance;
        die +{error_code => 'OrderPaymentInfoRequired'} unless trim($param{payment_info}) or @payment_method_ids;
        die +{error_code => 'OrderContactInfoRequired'} if !trim($param{contact_info});

        if (!$legacy_ad) {
            my $methods = $self->_p2p_advertiser_payment_methods(advertiser_id => $client_info->{id});
            die +{error_code => 'InvalidPaymentMethods'} unless all { exists $methods->{$_} } @payment_method_ids;
            my @order_methods = map { $methods->{$_}{method} } grep { $methods->{$_}{is_enabled} } @payment_method_ids;
            die +{error_code => 'ActivePaymentMethodRequired'} unless @order_methods;

            my $invalid_method = first {
                my $m = $_;
                none { $m eq $_ } $advert->{payment_method_names}->@*
            } @order_methods;

            if ($invalid_method) {
                my $method_defs = $self->p2p_payment_methods();
                die +{
                    error_code     => 'PaymentMethodNotInAd',
                    message_params => [$method_defs->{$invalid_method} ? $method_defs->{$invalid_method}{display_name} : $invalid_method]};
            }
        }

    } elsif ($advert_type eq 'sell') {

        $order_type        = 'buy';
        $amount_advertiser = -$amount;
        $amount_client     = $amount;

        die +{error_code => 'OrderCreateFailAmountAdvertiser'} if $amount > $advertiser->p2p_balance;
        die +{error_code => 'OrderPaymentContactInfoNotAllowed'}
            if $payment_info
            or $contact_info
            or ($param{payment_method_ids} && $param{payment_method_ids}->@*);

        ($payment_info, $contact_info) = $advert->@{qw/payment_info contact_info/};

    } else {
        die 'Invalid advert type ' . ($advert_type // 'undef') . ' for advert ' . $advert->{id};
    }

    try {
        $self->validate_payment(
            amount       => $amount_client,
            currency     => $advert->{account_currency},
            payment_type => 'p2p',
            rule_engine  => $rule_engine,
        );
    } catch ($e) {
        my $message = ref $e ? $e->{message_to_client} : localize('Please try later.');
        # temporary logging to allow us to see the full string
        $log->warnf('validate_payment in p2p_order_create returned a scalar! %s', $e) unless ref $e;
        die +{
            error_code     => 'OrderCreateFailClient',
            message_params => [$message],
        };
    }

    try {
        $advertiser->validate_payment(
            amount       => $amount_advertiser,
            currency     => $advert->{account_currency},
            payment_type => 'p2p',
            rule_engine  => $rule_engine,
        );
    } catch {
        die +{
            error_code => 'OrderCreateFailAmountAdvertiser',
        };
    }

    # For client inverted advert type needs to be checked, for example in a sell advert, client is buyer, so we need to check their daily_buy_limit
    my $client_limit_remaining = $client_info->{'daily_' . $order_type . '_limit'} - $client_info->{'daily_' . $order_type};
    $client_limit_remaining = financialrounding('amount', $client_info->{account_currency}, $client_limit_remaining);
    die +{
        error_code     => 'OrderMaximumTempExceeded',
        message_params => [$client_limit_remaining, $client_info->{account_currency}]}
        if $amount > $client_limit_remaining;

    my $escrow = $self->p2p_escrow($advert->{account_currency}) // die +{error_code => 'EscrowNotFound'};

    my $open_orders = $self->_p2p_orders(
        advert_id => $advert_id,
        loginid   => $self->loginid,
        status    => P2P_ORDER_STATUS->{active},
    );

    die +{error_code => 'OrderAlreadyExists'} if @{$open_orders};

    my $txn_time                          = Date::Utility->new->datetime;
    my $reversible_limit                  = BOM::Config::Runtime->instance->app_config->payments->reversible_balance_limits->p2p / 100;
    my $reversible_lookback               = BOM::Config::Runtime->instance->app_config->payments->reversible_deposits_lookback;
    my $fiat_deposit_restricted_countries = BOM::Config::Runtime->instance->app_config->payments->p2p->fiat_deposit_restricted_countries;
    my $fiat_deposit_restricted_lookback  = BOM::Config::Runtime->instance->app_config->payments->p2p->fiat_deposit_restricted_lookback;
    my $market_rate                       = p2p_exchange_rate($advert->{local_currency})->{quote};
    my $expiry                            = $advert->{order_expiry_period} //= $p2p_config->order_timeout;

    my $order = $self->db->dbic->run(
        fixup => sub {
            my $dbh = shift;

            return $dbh->selectrow_hashref(
                'SELECT * FROM p2p.order_create_v2(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NULL, ?, ?, ?, ?, ?, ?, ?)', undef,
                $advert_id,                                                                                      $self->loginid,
                $escrow->loginid,                                                                                $amount,
                $expiry,                                                                                         $payment_info,
                $contact_info,                                                                                   $source,
                $self->loginid,                                                                                  $limit_per_day_per_client,
                $txn_time,                                                                                       $reversible_limit,
                $reversible_lookback,                                                                            $param{payment_method_ids},
                $param{rate},                                                                                    $market_rate,
                $fiat_deposit_restricted_countries,                                                              $fiat_deposit_restricted_lookback
            );
        });

    $self->_p2p_db_error_handler($order);
    $self->_p2p_record_order_partners($order);

    my $redis = BOM::Config::Redis->redis_p2p_write();

    # used in p2p daemon to expire orders
    $redis->zadd(P2P_ORDER_EXPIRES_AT, Date::Utility->new($order->{expire_time})->epoch, join('|', $order->{id}, $self->loginid));

    # reset ad archive date, cron will recreate it
    $redis->hdel(P2P_ARCHIVE_DATES_KEY, $advert_id);

    BOM::Platform::Event::Emitter::emit(
        p2p_order_created => {
            client_loginid => $self->loginid,
            order_id       => $order->{id},
        });

    my $p2p_create_order_chat = BOM::Config::Runtime->instance->app_config->payments->p2p->create_order_chat;
    if ($p2p_create_order_chat) {
        BOM::Platform::Event::Emitter::emit(
            p2p_order_chat_create => {
                client_loginid => $self->loginid,
                order_id       => $order->{id},
            });
    }

    for my $order_loginid ($order->{client_loginid}, $order->{advertiser_loginid}) {
        BOM::Platform::Event::Emitter::emit(
            p2p_advertiser_updated => {
                client_loginid => $order_loginid,
            },
        );
    }

    # only update the buyer's ads, the seller's event is fired via the transaction
    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $order->{type} eq 'buy' ? $order->{client_id} : $order->{advertiser_id},
        });
    $order->{payment_method_details} = $self->_p2p_order_payment_method_details($order);
    $self->_set_last_seen_status(
        order_id => $order->{id},
        loginid  => $order->{client_loginid},
        status   => $order->{status});
    my $order_info = $self->_order_details([$order])->[0];
    $order_info->{subscription_info} = {    # will be removed in websocket (we need this for building channel name)
        advertiser_id => $client_info->{id},
        order_id      => $order->{id}} if $param{subscribe};

    return $order_info;
}

=head2 p2p_order_info

Return a single order of $param{id}

=cut

sub p2p_order_info {
    my ($self, %param) = @_;

    my $id              = $param{id}                    // return;
    my $advertiser_info = $self->_p2p_advertiser_cached // die +{error_code => 'AdvertiserNotFound'};

    # ensure client can only see their orders
    my $order = $self->_p2p_orders(
        id      => $id,
        loginid => $self->loginid
    )->[0] // return;

    $order->{payment_method_details} = $self->_p2p_order_payment_method_details($order);
    unless ($self->_is_order_status_final($order->{status})) {
        $self->_set_last_seen_status(
            order_id => $id,
            loginid  => $self->loginid,
            status   => $order->{status});
    }
    my $order_info = $self->_order_details([$order])->[0];
    $order_info->{subscription_info} = {    # will be removed in websocket (we need this for building channel name)
        advertiser_id => $advertiser_info->{id},
        order_id      => $id
    } if $param{subscribe};

    return $order_info;
}

=head2 p2p_order_list

Get orders filtered by %param.

=cut

sub p2p_order_list {
    my ($self, %param) = @_;

    $param{loginid} = $self->loginid;
    my $advertiser_info = $self->_p2p_advertiser_cached // die +{error_code => 'AdvertiserNotFound'};

    my $list        = $self->_p2p_orders(%param);
    my $orders_info = {list => $self->_order_details($list)};

    $orders_info->{subscription_info} = {    # will be removed in websocket (we need this for building channel name)
        advertiser_id => $advertiser_info->{id},
        advert_id     => $param{advert_id},
        active        => $param{active}} if $param{subscribe};

    return $orders_info;
}

=head2 p2p_order_confirm

Confirms the order of $param{id} and returns updated order.
Client = client, type = buy: order is buyer-confirmed
Client = client, type = sell: order is completed
Client = advertiser, type = buy: order is completed
Client = advertiser, type = sell: order is buyer-confirmed
Otherwise dies with error code.

=cut

sub p2p_order_confirm {
    my ($self, %param) = @_;

    my $id    = $param{id} // die +{error_code => 'OrderNotFound'};
    my $order = $self->_p2p_orders(
        id      => $id,
        loginid => $self->loginid
    )->[0] // die +{error_code => 'OrderNotFound'};
    my $role = $self->_order_ownership_type($order) or die +{error_code => 'PermissionDenied'};

    my $confirm_type = {
        sell_client     => 'sell',
        sell_advertiser => 'buy',
        buy_client      => 'buy',
        buy_advertiser  => 'sell',
    }->{$order->{type} . '_' . $role};

    my $db_confirm_func = 'p2p.order_confirm_' . $role . '_v2';
    my $new_status;

    if ($confirm_type eq 'sell') {

        die +{error_code => 'OrderNotConfirmedPending'} if $order->{status} eq 'pending';
        die +{error_code => 'OrderConfirmCompleted'}    if $order->{status} !~ /^(buyer-confirmed|timed-out|disputed)$/;
        my $escrow = $self->p2p_escrow($order->{account_currency}) // die +{error_code => 'EscrowNotFound'};

        $self->_p2p_order_confirm_verification($order, %param);

        return {
            id      => $id,
            dry_run => 1
        } if $param{dry_run};

        my $txn_time = Date::Utility->new->datetime;
        my $result   = $self->db->dbic->txn(
            fixup => sub {
                my $confirm_result = $_->selectrow_hashref("SELECT * FROM $db_confirm_func(?)", undef, $order->{id});    ## SQL safe($db_confirm_func)
                return $confirm_result if $confirm_result->{error_code};
                return $_->selectrow_hashref('SELECT * FROM p2p.order_complete_v2(?, ?, ?, ?, ?, FALSE, FALSE)',
                    undef, $order->{id}, $escrow->loginid, $param{source}, $self->loginid, $txn_time);
            });

        $self->_p2p_db_error_handler($result);
        $self->_p2p_order_completed($order);    # these functions do not consider status
        $self->_p2p_order_finalized($order);

        $new_status = $result->{status};

    } elsif ($confirm_type eq 'buy') {

        die +{error_code => 'OrderAlreadyConfirmedBuyer'}    if $order->{status} eq 'buyer-confirmed';
        die +{error_code => 'OrderAlreadyConfirmedTimedout'} if $order->{status} eq 'timed-out';
        die +{error_code => 'OrderUnderDispute'}             if $order->{status} eq 'disputed';
        die +{error_code => 'OrderConfirmCompleted'}         if $order->{status} ne 'pending';

        return {
            id      => $id,
            dry_run => 1
        } if $param{dry_run};

        my $result = $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_hashref("SELECT * FROM $db_confirm_func(?)", undef, $order->{id});    ## SQL safe($db_confirm_func)
            });

        $self->_p2p_db_error_handler($result);
        $self->_p2p_order_buy_confirmed($order);                                                    # this function does not consider status
        $new_status = $result->{status};
        $self->_set_last_seen_status(
            order_id => $id,
            loginid  => $self->loginid,
            status   => $new_status
        );
    }

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $id,
            order_event    => 'confirmed',
        });

    return {
        id     => $id,
        status => $new_status
    };
}

=head2 p2p_order_cancel

Cancels the order of $param{id}.
Order must belong to the buyer.
Order must be in pending status.
This will move funds from escrow to seller.

=cut

sub p2p_order_cancel {
    my ($self, %param) = @_;
    my $id    = $param{id} // die +{error_code => 'OrderNotFound'};
    my $order = $self->_p2p_orders(id => $id)->[0];
    die +{error_code => 'OrderNotFound'} unless $order;
    die +{error_code => 'OrderNoEditExpired'}    if $order->{is_expired};
    die +{error_code => 'OrderAlreadyCancelled'} if $order->{status} eq 'cancelled';

    my $ownership_type = $self->_order_ownership_type($order);

    die +{error_code => 'PermissionDenied'}
        unless ($ownership_type eq 'client' and $order->{type} eq 'buy')
        or ($ownership_type eq 'advertiser' and $order->{type} eq 'sell');
    die +{error_code => 'PermissionDenied'} unless $order->{status} eq 'pending';

    my $escrow      = $self->p2p_escrow($order->{account_currency}) // die +{error_code => 'EscrowNotFound'};
    my $is_refunded = 0;                                                                                        # order will have cancelled status
    my $is_manual   = 0;                                                                                        # this is not a manual cancellation

    my $elapsed      = time - Date::Utility->new($order->{created_time})->epoch;
    my $grace_period = BOM::Config::Runtime->instance->app_config->payments->p2p->cancellation_grace_period * 60;    # config period is minutes
    my $buyer_fault  = $elapsed < $grace_period ? 0 : 1;    # negatively affect the buyer's completion rate when after grace period

    my $txn_time = Date::Utility->new->datetime;

    my $db_result = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_refund_v2(?, ?, ?, ?, ?, ?, ? ,?, ?)',
                undef, $id, $escrow->loginid, $param{source}, $self->loginid, $is_refunded, $txn_time, $is_manual, $buyer_fault, $order->{advert_id});
        });

    $self->_p2p_db_error_handler($db_result);

    $self->_p2p_order_cancelled({%$order, %$db_result});
    $self->_p2p_order_finalized($order);

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $id,
            order_event    => 'cancelled',
        });

    for my $order_loginid ($order->@{qw/client_loginid advertiser_loginid/}) {
        BOM::Platform::Event::Emitter::emit(
            p2p_advertiser_updated => {
                client_loginid => $order_loginid,
            },
        );
    }

    # only update the buyer's ads, the seller's event is fired via the transaction
    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $order->{type} eq 'buy' ? $order->{client_id} : $order->{advertiser_id},
        });

    return $db_result;
}

=head2 p2p_order_review

Creates a review for order of $param{id}.

=cut

sub p2p_order_review {
    my ($self, %param) = @_;

    my $id    = $param{order_id} // die +{error_code => 'OrderNotFound'};
    my $order = $self->_p2p_orders(
        id      => $id,
        loginid => $self->loginid,    # ensure order belongs to client
    )->[0] // die +{error_code => 'OrderNotFound'};

    die +{error_code => 'OrderReviewNotComplete'} if $order->{status} =~ /^(pending|buyer-confirmed|timed-out)$/;
    die +{error_code => 'OrderReviewStatusInvalid'} unless $order->{status} eq 'completed' and $order->{completion_time};

    my $reviewee_role = $self->loginid eq $order->{client_loginid} ? 'advertiser' : 'client';
    die +{error_code => 'OrderReviewExists'} if $order->{$reviewee_role . '_review_rating'};

    my $review_hours = BOM::Config::Runtime->instance->app_config->payments->p2p->review_period;
    die +{
        error_code     => 'OrderReviewPeriodExpired',
        message_params => [$review_hours],
        }
        if (time - Date::Utility->new($order->{completion_time})->epoch) > ($review_hours * 60 * 60);

    my ($reviewee, $reviewer) = $reviewee_role eq 'client' ? $order->@{qw(client_id advertiser_id)} : $order->@{qw(advertiser_id client_id)};

    my $review = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_review_v2(?, ?, ?, ?, ?)',
                undef, $id, $reviewee, $reviewer, @param{qw(rating recommended)});
        });

    $self->_p2p_db_error_handler($review);

    $review->{created_time} = Date::Utility->new($review->{created_time})->epoch;

    BOM::Platform::Event::Emitter::emit(
        p2p_advertiser_updated => {
            client_loginid => $reviewee_role eq 'advertiser' ? $order->{advertiser_loginid} : $order->{client_loginid},
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $reviewee,
        });

    # only the reviewer's order will have changed
    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $id,
            order_event    => 'review_created',
            self_only      => 1,
        });

    # reviewer no longer needs notification about review period expiry
    BOM::Config::Redis->redis_p2p_write->zrem(P2P_ORDER_REVIEWABLE_START_AT, $id . '|' . $self->loginid);

    return $review;
}

=head2 p2p_chat_create

Creates a sendbird chat channel for an order, and users if required.
Both clients of the order must be P2P advertisers.

=cut

sub p2p_chat_create {    #This function and feature create_order_chat will be remove after successful realease,
                         #We are keeping just for backward compatibility
    my ($self, %param) = @_;

    return $self->p2p_create_order_chat(%param);
}

=head2 p2p_create_order_chat

This method  is called by event p2p_order_chat_create in bom-events and p2p_chat_create in this module.
Creates a sendbird chat channel for an order, and users if required.
Both clients of the order must be P2P advertisers.

=cut

sub p2p_create_order_chat {
    my ($self, %param) = @_;
    my $order_id = $param{order_id}                         // die +{error_code => 'OrderNotFound'};
    my $order    = $self->_p2p_orders(id => $order_id)->[0] // die +{error_code => 'OrderNotFound'};
    my $counterparty_loginid;

    if ($order->{advertiser_loginid} eq $self->loginid) {
        $counterparty_loginid = $order->{client_loginid};
    } elsif ($order->{client_loginid} eq $self->loginid) {
        $counterparty_loginid = $order->{advertiser_loginid};
    } else {
        die +{error_code => 'PermissionDenied'};
    }

    die +{error_code => 'OrderChatAlreadyCreated'} if $order->{chat_channel_url};
    die +{error_code => 'AdvertiserNotFoundForChat'}        unless $self->_p2p_advertiser_cached;
    die +{error_code => 'CounterpartyNotAdvertiserForChat'} unless $self->_p2p_advertisers(loginid => $counterparty_loginid)->[0];

    my $sb_api = BOM::User::Utility::sendbird_api();

    my $sb_advertiser_user_id = $order->{advertiser_chat_user_id};
    my $sb_client_user_id     = $order->{client_chat_user_id};
    foreach (0 .. 1) {
        my $sb_user_id;
        if ($_ and not $order->{advertiser_chat_user_id}) {
            $sb_advertiser_user_id = $sb_user_id = join '_', 'p2puser', $self->broker_code, $order->{advertiser_id}, time;
        } elsif (not $order->{client_chat_user_id}) {
            $sb_client_user_id = $sb_user_id = join '_', 'p2puser', $self->broker_code, $order->{client_id}, time;
        }
        if ($sb_user_id) {
            my $sb_user;
            my $nickname      = $_ ? $order->{advertiser_name} : $order->{client_name};
            my $advertiser_id = $_ ? $order->{advertiser_id}   : $order->{client_id};

            try {
                $sb_user = $sb_api->create_user(
                    user_id             => $sb_user_id,
                    nickname            => $nickname,
                    profile_url         => '',
                    issue_session_token => 'true'
                );
            } catch {
                die +{error_code => 'AdvertiserCreateChatError'};
            }

            my ($sb_user_token, $sb_user_expiry) =
                ($sb_user->session_tokens->[0]{session_token}, int($sb_user->session_tokens->[0]{expires_at} / 1000));
            $self->db->dbic->run(
                fixup => sub {
                    $_->do('SELECT * FROM p2p.advertiser_update_v2(?, NULL, NULL, NULL, NULL, NULL, NULL, ?, ?, ?, NULL, NULL, NULL, NULL, NULL)',
                        undef, $advertiser_id, $sb_user_id, $sb_user_token, $sb_user_expiry);
                });

            BOM::Platform::Event::Emitter::emit(
                p2p_advertiser_updated => {
                    client_loginid => $_ ? $order->{advertiser_loginid} : $order->{client_loginid},
                });
        }
    }

    my $sb_channel = join '_', ('p2porder', $self->broker_code, $order_id, time);
    my $sb_chat;

    try {
        $sb_chat = $sb_api->create_group_chat(
            channel_url => $sb_channel,
            user_ids    => [$sb_advertiser_user_id, $sb_client_user_id],
            name        => 'Chat about order ' . $order_id,
        );
    } catch {
        die +{error_code => 'CreateChatError'};
    }

    $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_update(?, ?, ?)', undef, $order_id, undef, $sb_chat->channel_url);
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $order_id,
            order_event    => 'chat_created',
        });

    return {
        channel_url => $sb_chat->channel_url,
        order_id    => $order_id,
    };
}

=head2 p2p_chat_token

Returns sendbird session token.
Creates one if it doesn't exist or has expired.

=cut

sub p2p_chat_token {
    my ($self)          = @_;
    my $advertiser_info = $self->_p2p_advertiser_cached // die +{error_code => 'AdvertiserNotFoundForChatToken'};
    my $sendbird_api    = BOM::User::Utility::sendbird_api();

    my ($token, $expiry) = $advertiser_info->@{qw(chat_token chat_token_expiry)};
    if ($token and $expiry and ($expiry - time) >= P2P_TOKEN_MIN_EXPIRY) {
        return {
            token       => $token,
            expiry_time => $expiry,
            app_id      => $sendbird_api->app_id,
        };
    } elsif ($advertiser_info->{chat_user_id}) {
        try {
            my $sb_user = WebService::SendBird::User->new(
                user_id    => $advertiser_info->{chat_user_id},
                api_client => $sendbird_api
            );
            ($token, $expiry) = $sb_user->issue_session_token()->@{qw(session_token expires_at)};
        } catch {
            die +{error_code => 'ChatTokenError'};
        }
    } else {
        try {
            $advertiser_info->{chat_user_id} = join('_', 'p2puser', $self->broker_code, $advertiser_info->{id}, time);
            my $sb_user = $sendbird_api->create_user(
                user_id             => $advertiser_info->{chat_user_id},
                nickname            => $advertiser_info->{name},
                profile_url         => '',
                issue_session_token => 'true'
            );
            ($token, $expiry) = ($sb_user->session_tokens->[0]{session_token}, int($sb_user->session_tokens->[0]{expires_at} / 1000));
        } catch ($e) {
            die +{error_code => 'ChatTokenError'};
        }
    }

    $expiry = int($expiry / 1000);    # sb api returns milliseconds timestamps

    $self->db->dbic->run(
        fixup => sub {
            $_->do(
                'SELECT * FROM p2p.advertiser_update_v2(?, NULL, NULL, NULL, NULL, NULL, NULL, ?, ?, ?, NULL, NULL, NULL, NULL, NULL)',
                undef,
                $advertiser_info->{id},
                $advertiser_info->{chat_user_id},
                $token, $expiry
            );
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_advertiser_updated => {
            client_loginid => $self->loginid,
        },
    );

    return {
        token       => $token,
        expiry_time => $expiry,
        app_id      => $sendbird_api->app_id,
    };
}

=head2 p2p_escrow

Gets the configured escrow account for provided currency and current landing company.

=cut

sub p2p_escrow {
    my ($self, $currency) = @_;

    my @escrow_list = BOM::Config::Runtime->instance->app_config->payments->p2p->escrow->@*;

    foreach my $loginid (@escrow_list) {
        try {
            my $escrow = BOM::User::Client->new({loginid => $loginid, context => $self->{context}});

            return $escrow if $escrow && $escrow->broker eq $self->broker_code && $escrow->currency eq $currency;
        } catch {
            next;    # TODO: ideally, we should never have an error here, we should maybe log it?
        }
    }

    return undef;
}

=head2 p2p_create_order_dispute

Flags the order of $param{id} as disputed.
Client should be either buyer or seller for this order.
Only applies to the following states: C<timed-out>, C<pending>, C<buyer-confirmed>.
Although for C<pending> and C<buyer-confirmed> it should be already expired.
If successful, a redis hash is set to keep the dispute time.

It takes the following named arguments:

=over 4

=item * C<id> - the p2p order id being disputed

=item * C<dispute_reason> - the dispute reason (predefined at websocket layer, although DB field is TEXT)

=item * C<skip_livechat> - (optional) if specified and true, we won't fill the ZSET handled by P2P daemon and therefore no ticket will be raised about the dispute

=back

Returns the content of the order as parsed by C<_order_details>.

=cut

sub p2p_create_order_dispute {
    my ($self, %param) = @_;

    my $id             = $param{id} // die +{error_code => 'OrderNotFound'};
    my $dispute_reason = $param{dispute_reason};
    my $skip_livechat  = $param{skip_livechat};
    my $order          = $self->_p2p_orders(id => $id)->[0];
    die +{error_code => 'OrderNotFound'} unless $order;

    my $side = $self->_order_ownership_type($order);
    die +{error_code => 'OrderNotFound'} unless $side;

    # Some reasons may apply only to buyer/seller
    my $buyer = 1;
    $buyer = 0 if $side eq 'advertiser' and $order->{type} eq 'buy';
    $buyer = 0 if $side eq 'client'     and $order->{type} eq 'sell';
    die +{error_code => 'InvalidReasonForBuyer'}  if $buyer     and any { $dispute_reason eq $_ } qw/buyer_not_paid buyer_third_party_payment_method/;
    die +{error_code => 'InvalidReasonForSeller'} if not $buyer and $dispute_reason eq 'seller_not_released';

    # We allow buyer-confirmed due to FE relying on expire_time to show complain button.
    die +{error_code => 'OrderUnderDispute'}           if $order->{status} eq 'disputed';
    die +{error_code => 'InvalidFinalStateForDispute'} if $self->_is_order_status_final($order->{status});
    die +{error_code => 'InvalidStateForDispute'} unless grep { $order->{status} eq $_ } qw/timed-out buyer-confirmed/;
    # Confirm the order is expired
    die +{error_code => 'InvalidStateForDispute'} unless $order->{is_expired};

    my $updated_order = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.create_order_dispute(?, ?, ?)', undef, $id, $dispute_reason, $self->loginid);
        });
    unless ($skip_livechat) {
        my $p2p_redis = BOM::Config::Redis->redis_p2p_write();
        $p2p_redis->zadd(P2P_ORDER_DISPUTED_AT, Date::Utility->new()->epoch, join('|', $order->{id}, $self->broker_code));
    }

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $id,
            order_event    => 'dispute',
        });

    $self->_set_last_seen_status(
        order_id => $id,
        loginid  => $self->loginid,
        status   => $updated_order->{status});

    return $self->_order_details([$updated_order])->[0];
}

=head2 p2p_resolve_order_dispute

Resolves an order dispute, called from backoffice.

Takes the following named arguments:

=over 4

=item * C<id> - the p2p order id under dispute.

=item * C<action> - refund or complete

=item * C<staff> - backoffice staff name

=item * C<fraud> - is this being resolved as the result of fraud

=back

=cut

sub p2p_resolve_order_dispute {
    my ($self, %param) = @_;
    my ($id, $action, $staff, $fraud) = @param{qw/id action staff fraud/};

    my $order = $self->_p2p_orders(id => $id)->[0];
    die "Order not found\n"                                                 unless $order;
    die "Order is in $order->{status} status and cannot be resolved now.\n" unless $order->{status} eq 'disputed';

    my $escrow   = $self->p2p_escrow($order->{account_currency}) // die 'No escrow account defined for ' . $order->{account_currency} . "\n";
    my $txn_time = Date::Utility->new->datetime;
    my $redis    = BOM::Config::Redis->redis_p2p_write();
    my ($buyer, $seller) = $self->_p2p_order_parties($order);
    my $amount    = $order->{amount};
    my $is_manual = 1;
    my $advertiser_for_update;

    if ($action eq 'refund') {
        # resolve in favor of seller
        my $buyer_fault = 1;    # this will negatively affect the buyer's completion rate
        $self->db->dbic->run(
            fixup => sub {
                $_->do('SELECT p2p.order_refund_v2(?, ?, ?, ?, ?, ?, ?, ?, ?)',
                    undef, $id, $escrow->loginid, 4, $staff, 't', $txn_time, $is_manual, $buyer_fault, $order->{advert_id});
            });

        if ($fraud) {
            # buyer fraud
            $self->_p2p_order_fraud('buy', $order);
        }
        $self->_p2p_record_stat(
            loginid => $buyer,
            stat    => 'BUY_COMPLETION',
            payload => [$id, 0]);
        $advertiser_for_update = $order->{type} eq 'buy' ? $order->{client_id} : $order->{advertiser_id};

    } elsif ($action eq 'complete') {
        # resolve in favor of buyer
        my $completed_order = $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_hashref('SELECT p2p.order_complete_v2(?, ?, ?, ?, ?, ?, ?)',
                    undef, $id, $escrow->loginid, 4, $staff, $txn_time, $is_manual, $fraud);
            });
        $self->_p2p_db_error_handler($completed_order);
        $self->_p2p_record_stat(
            loginid => $buyer,
            stat    => 'BUY_COMPLETION',
            payload => [$id, 1]);
        $self->_p2p_record_stat(
            loginid => $buyer,
            stat    => 'BUY_COMPLETED',
            payload => [$id, $amount]);
        $redis->hincrby(P2P_STATS_REDIS_PREFIX . '::TOTAL_COMPLETED', $buyer, 1);
        $redis->hincrbyfloat(P2P_STATS_REDIS_PREFIX . '::TOTAL_TURNOVER', $buyer, $amount);

        if ($fraud) {
            # seller fraud
            $self->_p2p_record_stat(
                loginid => $seller,
                stat    => 'SELL_COMPLETION',
                payload => [$id, 0]);
            $self->_p2p_order_fraud('sell', $order);
        } else {
            $self->_p2p_record_stat(
                loginid => $seller,
                stat    => 'SELL_COMPLETION',
                payload => [$id, 1]);
            $self->_p2p_record_stat(
                loginid => $seller,
                stat    => 'SELL_COMPLETED',
                payload => [$id, $amount]);
            $redis->hincrby(P2P_STATS_REDIS_PREFIX . '::TOTAL_COMPLETED', $seller, 1);
            $redis->hincrbyfloat(P2P_STATS_REDIS_PREFIX . '::TOTAL_TURNOVER', $seller, $amount);
            $self->_p2p_record_partners($order);
        }

        $advertiser_for_update = $order->{type} eq 'sell' ? $order->{client_id} : $order->{advertiser_id};

    } else {
        die "Invalid action: $action\n";
    }

    # clean up
    $redis->hdel(P2P_STATS_REDIS_PREFIX . '::BUY_CONFIRM_TIMES', $id);

    $self->_p2p_order_finalized($order);

    my $order_event = join('_', 'dispute', $fraud ? 'fraud' : (), $action);

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $id,
            order_event    => $order_event,
        });

    for my $order_loginid ($buyer, $seller) {
        BOM::Platform::Event::Emitter::emit(
            p2p_advertiser_updated => {
                client_loginid => $order_loginid,
            },
        );
    }

    # only update the party who did not have a transaction
    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $advertiser_for_update,
        });

    return undef;
}

=head1 Non-RPC P2P methods

The methods below are not called by RPC and, therefore, they are not needed to die in the 'P2P way'.

=head2 p2p_expire_order

Hanedles order expiry events, called by p2p_daemon via bom-events.
Deletes redis keys used by p2p_daemon if order was proceseed or already completed.
It is safe to be called multiple times.

It takes the following named arguments:

=over 4

=item * C<id> - the p2p order id that has expired

=item * C<source> - app id

=item * C<staff> - loginid or backoffice username

=back

Returns new status if it changed.

=cut

sub p2p_expire_order {
    my ($self, %param) = @_;
    my $order_id = $param{id} // die 'No id provided to p2p_expire_order';
    my $order    = $self->_p2p_orders(id => $order_id)->[0];

    die 'Invalid order provided to p2p_expire_order' unless $order;

    my $escrow   = $self->p2p_escrow($order->{account_currency}) // die 'No escrow account for ' . $order->{account_currency};
    my $txn_time = Date::Utility->new->datetime;

    my $days_for_release = BOM::Config::Runtime->instance->app_config->payments->p2p->refund_timeout;
    my $grace_period     = BOM::Config::Runtime->instance->app_config->payments->p2p->cancellation_grace_period * 60;    # config period is minutes
    my $p2p_redis        = BOM::Config::Redis->redis_p2p_write();
    my $redis_payload    = join('|', $order_id, $self->loginid);
    my $elapsed          = time - Date::Utility->new($order->{created_time})->epoch;
    my $buyer_fault      = $elapsed < $grace_period ? 0 : 1;    # negatively affect the buyer's completion rate when after grace period

    my ($old_status, $new_status, $expiry) = $self->db->dbic->txn(
        fixup => sub {
            $_->selectrow_array('SELECT * FROM p2p.order_expire(?, ?, ?, ?, ?, ?, ?, ?)',
                undef, $order_id, $escrow->loginid, $param{source}, $param{staff}, $txn_time, $days_for_release, $order->{advert_id}, $buyer_fault);

        });

    $new_status //= '';

    my $order_complete     = ($self->_is_order_status_final($old_status) or $old_status eq 'disputed');
    my $hit_expire_refund  = ($old_status eq 'pending'         and $new_status eq 'refunded');
    my $hit_timeout        = ($old_status eq 'buyer-confirmed' and $new_status eq 'timed-out');
    my $hit_timeout_refund = ($old_status eq 'timed-out'       and $new_status eq 'refunded');

    my ($buyer, $seller) = $self->_p2p_order_parties($order);

    # order hit timed out
    if ($hit_timeout) {
        $p2p_redis->zadd(P2P_ORDER_TIMEDOUT_AT, Date::Utility->new($expiry)->epoch, $redis_payload);
    }

    # order hit expiry time, or was already done, or already timed-out
    if ($hit_expire_refund or $hit_timeout or $order_complete or $old_status eq 'timed-out') {
        $p2p_redis->zrem(P2P_ORDER_EXPIRES_AT, $redis_payload);
    }

    # order hit time out expiry, or was already done (includes refunded)
    if ($hit_timeout_refund or $order_complete) {
        $p2p_redis->zrem(P2P_ORDER_TIMEDOUT_AT, $redis_payload);
    }

    if ($hit_expire_refund or $hit_timeout) {
        stats_inc('p2p.order.expired');

        BOM::Platform::Event::Emitter::emit(
            p2p_order_updated => {
                client_loginid => $self->loginid,
                order_id       => $order_id,
                order_event    => 'expired',
            });
    }

    if ($hit_expire_refund) {
        # this counts as a manual cancel
        $self->_p2p_order_cancelled($order);
    }

    if ($hit_timeout_refund) {
        # degrade the buyer's completion rate but don't count as cancel
        $self->_p2p_record_stat(
            loginid => $buyer,
            stat    => 'BUY_COMPLETION',
            payload => [$order_id, 0]);

        stats_inc('p2p.order.timeout_refund');

        BOM::Platform::Event::Emitter::emit(
            p2p_order_updated => {
                client_loginid => $self->loginid,
                order_id       => $order_id,
                order_event    => 'timeout_refund',
            });
    }

    if ($hit_expire_refund or $hit_timeout_refund) {
        # order was refunded, need to update both advertisers
        for my $order_loginid ($buyer, $seller) {
            BOM::Platform::Event::Emitter::emit(
                p2p_advertiser_updated => {
                    client_loginid => $order_loginid,
                },
            );
        }

        # only update the buyer's ads, the seller's event is triggered by the transaction
        BOM::Platform::Event::Emitter::emit(
            p2p_adverts_updated => {
                advertiser_id => $order->{type} eq 'buy' ? $order->{client_id} : $order->{advertiser_id},
            });

        $self->_p2p_order_finalized($order);
    }

    return $new_status;
}

=head1 Private P2P methods

=head2 _get_last_seen_status
Sample hash key: 4|CR90000053 (order_id|login_id)
Returns last seen status for specified client based on hash key in redis
Last seen status here means the latest order status seen by client while the order is active 

=cut

sub _get_last_seen_status {
    my ($self, %param) = @_;
    my $redis     = BOM::Config::Redis->redis_p2p();
    my $order_key = $param{order_id} . "|" . $param{loginid};
    return $redis->hget(P2P_ORDER_LAST_SEEN_STATUS, $order_key);
}

=head2 _set_last_seen_status

Sample hash key: 4|CR90000053 (order_id|login_id)
Sets last seen status for specified client based on hash key (order_id|login_id) in redis
This subroutine invoked only if there is an update to an active order of client and that update is seen by client 

=cut

sub _set_last_seen_status {
    my ($self, %param) = @_;
    my $p2p_redis = BOM::Config::Redis->redis_p2p_write();
    my $order_key = $param{order_id} . "|" . $param{loginid};
    $p2p_redis->hset(P2P_ORDER_LAST_SEEN_STATUS, $order_key, $param{status});
}

=head2 _validate_cross_border_availability

Check if client's residence is restricted from cross border ad feature
If yes, advertiser not allowed to create ads, view ads or create order against ads that is not from his local currency

=cut

sub _validate_cross_border_availability {
    my $self                                      = shift;
    my $p2p_config                                = BOM::Config::Runtime->instance->app_config->payments->p2p;
    my $restricted_countries_for_cross_border_ads = $p2p_config->cross_border_ads_restricted_countries // [];
    die +{error_code => 'CrossBorderNotAllowed'}
        if any { lc($_) eq $self->residence } $restricted_countries_for_cross_border_ads->@*;
    return 1;
}

=head2 _validate_block_trade_availability

Check if client is allowed to do block trade and block trading is globally enabled.

=cut

sub _validate_block_trade_availability {
    my $self = shift;

    die +{error_code => 'BlockTradeNotAllowed'}
        if any { !defined $self->_p2p_advertiser_cached->{$_} } qw(block_trade_min_order_amount block_trade_max_order_amount);
    die +{error_code => 'BlockTradeDisabled'} unless BOM::Config::Runtime->instance->app_config->payments->p2p->block_trade->enabled;
}

=head2 _p2p_advertisers

Returns a list of advertisers filtered by id and/or loginid.

=cut

sub _p2p_advertisers {
    my ($self, %param) = @_;

    # don't call $self->_p2p_advertiser_cached or we will have deep recursion
    my $self_id = $self->{_p2p_advertiser_cached} ? $self->{_p2p_advertiser_cached}{id} : undef;

    my $advertisers = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(
                'SELECT * FROM p2p.advertiser_list_v2(?, ?, ?, ?, ?)',
                {Slice => {}},
                @param{qw/id loginid name unique_name/}, $self_id
            );
        });

    $self->_p2p_convert_advertiser_limits($_) for @$advertisers;
    return $advertisers;
}

=head2 _p2p_advertiser_cached

Cache of p2p_advertiser record for the current client.
We often need to get it more than once for a single RPC call.
In tests you will need to delete this every time you update an advertiser and call another RPC method.

=cut

sub _p2p_advertiser_cached {
    my $self = shift;
    return $self->{_p2p_advertiser_cached} //= $self->_p2p_advertisers(loginid => $self->loginid)->[0];
}

=head2 _p2p_convert_advertiser_limits

Converts limits to advertier's account currency. Values are changed in-place.

=cut

sub _p2p_convert_advertiser_limits {
    my ($self, $advertiser) = @_;

    for my $amt (qw/daily_buy_limit daily_sell_limit min_order_amount max_order_amount min_balance/) {
        next unless defined $advertiser->{$amt};
        $advertiser->{$amt} = convert_currency($advertiser->{$amt}, $advertiser->{limit_currency}, $advertiser->{account_currency});
    }

    return $advertiser;
}

=head2 _p2p_adverts

Gets adverts from DB. Most params are passed directly to db function p2p.advert_list().

To note:

=over 4

=item * C<payment_method> is an arrayref of payment method names.

=back

=cut

sub _p2p_adverts {
    my ($self, %param) = @_;

    my ($limit, $offset) = @param{qw/limit offset/};
    die +{error_code => 'InvalidListLimit'}  if defined $limit  && $limit <= 0;
    die +{error_code => 'InvalidListOffset'} if defined $offset && $offset < 0;

    $param{max_order} = convert_currency(BOM::Config::Runtime->instance->app_config->payments->p2p->limits->maximum_order, 'USD', $self->currency);
    $param{reversible_limit}                  = BOM::Config::Runtime->instance->app_config->payments->reversible_balance_limits->p2p / 100;
    $param{reversible_lookback}               = BOM::Config::Runtime->instance->app_config->payments->reversible_deposits_lookback;
    $param{fiat_deposit_restricted_countries} = BOM::Config::Runtime->instance->app_config->payments->p2p->fiat_deposit_restricted_countries;
    $param{fiat_deposit_restricted_lookback}  = BOM::Config::Runtime->instance->app_config->payments->p2p->fiat_deposit_restricted_lookback;
    $param{advertiser_name} =~ s/([%_])/\\$1/g         if $param{advertiser_name};
    $param{local_currency} = uc $param{local_currency} if $param{local_currency};

    unless ($param{market_rate}) {
        my @currencies;
        if ($param{local_currency}) {
            @currencies = ($param{local_currency});
        } else {
            my @countries = $param{country} ? ($param{country}) : keys BOM::Config::P2P::available_countries()->%*;
            for my $country (@countries) {
                push @currencies,
                    BOM::Config::CurrencyConfig::local_currency_for_country(
                    country        => $country,
                    include_legacy => 1
                    );
            }
        }
        my %market_rate_map = map { $_ => p2p_exchange_rate($_)->{quote} } @currencies;
        $param{market_rate_map} = $json->encode(\%market_rate_map);
    }

    for my $field (qw/id advert_id limit offset/) {
        $param{$field} += 0 if defined $param{$field};
    }

    $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(
                'SELECT * FROM p2p.advert_list(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                {Slice => {}},
                @param{
                    qw/id account_currency advertiser_id is_active type country can_order max_order advertiser_is_listed advertiser_is_approved
                        client_loginid limit offset show_deleted sort_by advertiser_name reversible_limit reversible_lookback payment_method
                        use_client_limits favourites_only hide_blocked market_rate rate_type local_currency market_rate_map country_payment_methods
                        fiat_deposit_restricted_countries fiat_deposit_restricted_lookback block_trade/
                });
        }) // [];
}

=head2 _p2p_orders

Gets orders from DB.
$param{loginid} will match on advert advertiser loginid or order client loginid.
$param{status} if provided must by an arrayref.

=cut

sub _p2p_orders {
    my ($self, %param) = @_;

    $param{status} = $param{active} ? P2P_ORDER_STATUS->{active} : P2P_ORDER_STATUS->{final}
        if exists $param{active};

    croak 'Invalid status format'
        if defined $param{status}
        && ref $param{status} ne 'ARRAY';

    my ($limit, $offset) = @param{qw/limit offset/};
    die +{error_code => 'InvalidListLimit'}  if defined $limit  && $limit <= 0;
    die +{error_code => 'InvalidListOffset'} if defined $offset && $offset < 0;

    for my $field (qw/id advert_id limit offset/) {
        $param{$field} += 0 if defined $param{$field};
    }

    my ($date_from, $date_to) = @param{qw/date_from date_to/};
    if ($date_from and $date_from = eval { Date::Utility->new($param{date_from}) } // die +{error_code => 'InvalidDateFormat'}) {
        $param{start_time} = $date_from->datetime_yyyymmdd_hhmmss;
    }

    if ($date_to and $date_to = eval { Date::Utility->new($param{date_to}) } // die +{error_code => 'InvalidDateFormat'}) {
        $param{end_time} = $date_to->datetime_yyyymmdd_hhmmss;
        ## If we were passed in a date (but not an epoch or full timestamp)
        ## add in one day, so that 2018-04-07 grabs the entire day by doing
        ## a "date_to < 2018-04-08 00:00:000'
        $date_to->plus_time_interval('1d') unless $date_to->second + 0;
        $param{end_time} = $date_to->db_timestamp;
    }

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(
                'SELECT * FROM p2p.order_list(?, ?, ?, ?, ?, ?, ?, ?)',
                {Slice => {}},
                @param{qw/id advert_id loginid status start_time end_time limit offset/});
        }) // [];
}

=head2 _validate_advert

Validation for advert create and update.
Simply calls all the advert validation methods.

=cut

sub _validate_advert {
    my ($self, %param) = @_;

    $self->_validate_advert_amount(%param);
    $self->_validate_advert_rates(%param);
    $self->_validate_advert_min_max(%param);
    $self->_validate_advert_duplicates(%param);
    $self->_validate_advert_payment_method_type(%param);
    $self->_validate_advert_payment_method_ids(%param);
    $self->_validate_advert_payment_method_names(%param);
    $self->_validate_advert_payment_contact_info(%param);
}

=head2 _validate_advert_amount

Validation of advert amount field.

=cut

sub _validate_advert_amount {
    my ($self, %param) = @_;

    my $limit_key = $param{block_trade} ? 'block_trade' : 'limits';
    my $global_max_ad =
        convert_currency(BOM::Config::Runtime->instance->app_config->payments->p2p->$limit_key->maximum_advert, 'USD', $param{account_currency});

    if ($param{remaining_amount}) {
        # calculate amount for validation purposes, but it will be reculated in the db to avoid race conditions
        my $orders = $self->_p2p_orders(
            advert_id => $param{id},
            status    => [qw/pending buyer-confirmed timed-out disputed completed dispute-completed/],
        );

        my $used_amount = reduce { $a + $b->{amount} } 0, @$orders;
        my $new_amount  = $param{remaining_amount} + $used_amount;

        if ($new_amount > $global_max_ad) {
            die +{
                error_code     => 'MaximumExceededNewAmount',
                message_params => [
                    financialrounding('amount', $param{account_currency}, $global_max_ad),
                    financialrounding('amount', $param{account_currency}, $used_amount),
                    financialrounding('amount', $param{account_currency}, $new_amount),
                    $param{account_currency}
                ],
            };
        }
    }

    if (not $param{id} and $param{amount} > $global_max_ad) {
        die +{
            error_code     => 'MaximumExceeded',
            message_params => [financialrounding('amount', $param{account_currency}, $global_max_ad), $param{account_currency}],
        };
    }
}

=head2 _validate_advert_rates

Validation of advert rate and rate_type fields.

=cut

sub _validate_advert_rates {
    my ($self, %param) = @_;

    my $advert_config  = BOM::Config::P2P::advert_config()->{$param{country}} or die +{error_code => 'RestrictedCountry'};
    my $type_changed   = $param{rate_type} ne ($param{old}->{rate_type} // '');
    my $active_changed = ($param{is_active} and $param{is_active} != ($param{old}->{is_active} // 0));

    if ($param{rate_type} eq 'float') {
        die +{error_code => 'AdvertFloatRateNotAllowed'}
            if ($type_changed and $advert_config->{float_ads} ne 'enabled')
            or ($active_changed and $advert_config->{float_ads} eq 'disabled');

        # too much precision
        if (my ($decimals) = $param{rate} =~ /\.(\d+)$/) {
            die +{error_code => 'FloatRatePrecision'} if length($decimals) > 2;
        }

        die +{error_code => 'FloatRatePrecision'} if $param{rate} =~ /e-/;

        # within currency specific range
        my $range = BOM::Config::P2P::currency_float_range($param{local_currency}) / 2;
        if (abs($param{rate}) > $range) {
            die +{
                error_code     => 'FloatRateTooBig',
                message_params => [sprintf('%.02f', $range)],
            };
        }
    } else {    # fixed rate
        die +{error_code => 'AdvertFixedRateNotAllowed'}
            if ($type_changed and $advert_config->{fixed_ads} ne 'enabled')
            or ($active_changed and $advert_config->{fixed_ads} eq 'disabled');

        # rate min
        if ($param{rate} < P2P_RATE_LOWER_LIMIT) {
            die +{
                error_code     => 'RateTooSmall',
                message_params => [sprintf('%.06f', P2P_RATE_LOWER_LIMIT)],
            };
        }

        # rate max
        if ($param{rate} > P2P_RATE_UPPER_LIMIT) {
            die +{
                error_code     => 'RateTooBig',
                message_params => [sprintf('%.02f', P2P_RATE_UPPER_LIMIT)],
            };
        }
    }
}

=head2 _validate_advert_min_max

Validation of advert min and max order fields.

=cut

sub _validate_advert_min_max {
    my ($self, %param) = @_;

    my ($band_min_order, $band_max_order, $global_max_order);

    if ($param{block_trade}) {
        ($band_min_order, $band_max_order) = $self->_p2p_advertiser_cached->@{qw(block_trade_min_order_amount block_trade_max_order_amount)};
    } else {
        ($band_min_order, $band_max_order) = $self->_p2p_advertiser_cached->@{qw(min_order_amount max_order_amount)};
        $global_max_order =
            convert_currency(BOM::Config::Runtime->instance->app_config->payments->p2p->limits->maximum_order, 'USD', $param{account_currency});
    }

    # min_order_amount limit
    if (defined $band_min_order and $param{min_order_amount} < $band_min_order) {
        die +{
            error_code     => 'BelowPerOrderLimit',
            message_params => [financialrounding('amount', $param{account_currency}, $band_min_order), $param{account_currency}],
        };
    }

    # actual min order would round to zero
    if ($param{rate_type} eq 'fixed') {
        my $min_price = $param{rate} * $param{min_order_amount};

        if (financialrounding('amount', $param{local_currency}, $min_price) == 0) {
            die +{
                error_code     => 'MinPriceTooSmall',
                message_params => [0]};
        }
    }

    # max_order_amount limit
    my $max_order = min grep { defined $_ } ($global_max_order, $band_max_order);
    if ($max_order and $param{max_order_amount} > $max_order) {
        die +{
            error_code     => 'MaxPerOrderExceeded',
            message_params => [financialrounding('amount', $param{account_currency}, $max_order), $param{account_currency}],
        };
    }

    die +{error_code => 'InvalidMinMaxAmount'} if $param{min_order_amount} > $param{max_order_amount};
}

=head2 _validate_advert_payment_contact_info

Validation of advert payment_info and contact_info fields.

=cut

sub _validate_advert_payment_contact_info {
    my ($self, %param) = @_;

    return unless $param{type} eq 'sell';
    die +{error_code => 'AdvertContactInfoRequired'} if not trim($param{contact_info});
    die +{error_code => 'AdvertPaymentInfoRequired'}
        if not trim($param{payment_info})
        and not($param{payment_method_ids} and $param{payment_method_ids}->@*);
}

=head2 _validate_advert_duplicates

Checks for duplicates and limits on numbers of similar ads.

=cut

sub _validate_advert_duplicates {
    my ($self, %param) = @_;

    return unless $param{is_active};

    my @active_ads = $self->_p2p_adverts(
        advertiser_id => $param{advertiser_id},
        is_active     => 1,
        country       => $self->residence,
        block_trade   => $param{block_trade} // 0,
    )->@*;

    # exclude ads that ran out of money - this should be removed when FE can enable/disable ads
    @active_ads = grep { $_->{remaining} >= $_->{min_order_amount} } @active_ads;

    # exclude ad being edited
    @active_ads = grep { not $param{id} or $_->{id} != $param{id} } @active_ads;

    # maximum active ads (all)
    die +{error_code => 'AdvertMaxExceeded'} if @active_ads >= P2P_MAXIMUM_ACTIVE_ADVERTS;

    my @active_ads_same_type =
        grep { $_->{type} eq $param{type} and $_->{local_currency} eq $param{local_currency} and $_->{account_currency} eq $param{account_currency} }
        @active_ads;

    # maximum acive ads of same type
    my $same_type_limit = BOM::Config::Runtime->instance->app_config->payments->p2p->limits->maximum_ads_per_type;
    if (@active_ads_same_type >= $same_type_limit) {
        die +{
            error_code     => 'AdvertMaxExceededSameType',
            message_params => [$same_type_limit],
        };
    }

    # duplicate rate, type and currency pair
    if (defined $param{rate}) {
        die +{error_code => 'DuplicateAdvert'}
            if any { p2p_rate_rounding($_->{rate}) == p2p_rate_rounding($param{rate}) and $_->{rate_type} eq $param{rate_type} }
            @active_ads_same_type;
    }

    # cannot have an ad with overlapping min/max amounts and same type + currencies
    die +{error_code => 'AdvertSameLimits'} if any {
               ($param{min_order_amount} >= $_->{min_order_amount} and $param{min_order_amount} <= $_->{max_order_amount})
            or ($param{max_order_amount} >= $_->{min_order_amount} and $param{max_order_amount} <= $_->{max_order_amount})
            or ($param{max_order_amount} >= $_->{max_order_amount} and $param{min_order_amount} <= $_->{min_order_amount})
    } @active_ads_same_type;
}

=head2 _validate_advert_payment_method_type

Checks if active ads have valid payment methods.

=cut

sub _validate_advert_payment_method_type {
    my ($self, %param) = @_;

    return unless $param{is_active};

    if ($param{type} eq 'sell') {
        die +{error_code => 'AdvertPaymentMethodRequired'}
            unless trim($param{payment_method})
            or ($param{payment_method_ids} and $param{payment_method_ids}->@*);
    } elsif ($param{type} eq 'buy') {
        die +{error_code => 'AdvertPaymentMethodRequired'}
            unless trim($param{payment_method})
            or ($param{payment_method_names} and $param{payment_method_names}->@*);
    }
}

=head2 _validate_advert_payment_method_ids

Validation of advert payment_method_ids field.

=cut

sub _validate_advert_payment_method_ids {
    my ($self, %param) = @_;

    return unless $param{payment_method_ids};

    if ($param{type} eq 'buy') {
        die +{error_code => 'AdvertPaymentMethodsNotAllowed'} if $param{payment_method_ids}->@*;
        return;
    }

    my $methods = $self->_p2p_advertiser_payment_methods(advertiser_id => $param{advertiser_id});
    my @method_names =
        map { $methods->{$_}{method} } grep { exists $methods->{$_} and $methods->{$_}{is_enabled} } $param{payment_method_ids}->@*;

    die +{error_code => 'InvalidPaymentMethods'}       if any { !$methods->{$_} } $param{payment_method_ids}->@*;
    die +{error_code => 'ActivePaymentMethodRequired'} if $param{is_active} and not @method_names and not trim($param{payment_method});

    # No pm name that was available when an active order was created may be removed from the ad
    if ($param{active_orders}) {
        my $orders = $self->_p2p_orders(
            advert_id => $param{id},
            status    => P2P_ORDER_STATUS->{active});

        my @used_methods = map { ($_->{advert_payment_method_names} // [])->@* } @$orders;
        if (my ($removed_method) = array_minus(@used_methods, @method_names)) {
            my $method_defs = $self->p2p_payment_methods();

            my @payment_methods_display_name_array;
            foreach (@used_methods) {
                push(@payment_methods_display_name_array, $method_defs->{$_}{display_name});
            }

            my $payment_methods_display_name_joined = join(', ', sort @payment_methods_display_name_array);

            die +{
                error_code     => 'PaymentMethodRemoveActiveOrders',
                message_params => [$payment_methods_display_name_joined]};
        }
    }
}

=head2 _validate_advert_payment_method_names

Validation of advert _validate_advert_payment_method_names field.

=cut

sub _validate_advert_payment_method_names {
    my ($self, %param) = @_;

    return unless $param{payment_method_names} and $param{payment_method_names}->@*;

    die +{error_code => 'PaymentMethodsDisabled'}
        unless BOM::Config::Runtime->instance->app_config->payments->p2p->payment_methods_enabled;

    die +{error_code => 'AdvertPaymentMethodNamesNotAllowed'} if $param{type} eq 'sell';

    my $method_defs = $self->p2p_payment_methods($self->residence);

    if (my $invalid_method = first { not exists $method_defs->{$_} } $param{payment_method_names}->@*) {
        die +{
            error_code     => 'InvalidPaymentMethod',
            message_params => [$invalid_method]};
    }
}

=head2 _p2p_advertiser_payment_methods

Gets advertiser payment methods from DB.
Returns hashref keyed by id.

=cut

sub _p2p_advertiser_payment_methods {
    my ($self, %param) = @_;
    my $result = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_hashref(
                'SELECT id, is_enabled, method, params, used_by_adverts, used_by_orders FROM p2p.advertiser_payment_method_list(?, ?, ?, ?)',
                'id',
                {Slice => {}},
                @param{qw/advertiser_id advert_id order_id is_enabled/});
        }) // {};

    for my $item (values %$result) {
        delete $item->{id};
        $item->{fields} = $json->decode(delete $item->{params});
    }
    return $result;
}

=head2 _p2p_advertiser_payment_method_details

Format advertiser payment methods for websocket response.

=cut

sub _p2p_advertiser_payment_method_details {
    my ($self, $methods) = @_;
    my $defs = $self->p2p_payment_methods();

    for my $id (keys %$methods) {
        my $method_def = $defs->{$methods->{$id}{method}};
        $methods->{$id}{$_} = $method_def->{$_}   for qw/display_name type/;
        $methods->{$id}{$_} = $methods->{$id}{$_} for qw/used_by_adverts used_by_orders/;
        for my $field (keys $method_def->{fields}->%*) {
            $methods->{$id}{fields}{$field} = {
                $method_def->{fields}{$field}->%*,
                value => $methods->{$id}{fields}{$field} // '',
            };
        }
    }
    return $methods;
}

=head2 _p2p_order_payment_method_details

Gets the active payment methods for a given order.
Completed orders are ignored.

=cut

sub _p2p_order_payment_method_details {
    my ($self, $order) = @_;

    return if $self->_is_order_status_final($order->{status});

    my $methods =
        $order->{type} eq 'buy'
        ? $self->_p2p_advertiser_payment_methods(
        advert_id  => $order->{advert_id},
        is_enabled => 1
        )
        : $self->_p2p_advertiser_payment_methods(
        order_id   => $order->{id},
        is_enabled => 1
        );

    return unless %$methods;

    my @client_pms     = keys $self->p2p_payment_methods($order->{client_country})->%*;
    my @advertiser_pms = keys $self->p2p_payment_methods($order->{advertiser_country})->%*;
    my @valid_pms      = intersect(@client_pms, @advertiser_pms);
    my @invalid_ids    = grep {
        my $method = $methods->{$_}{method};
        none { $_ eq $method } @valid_pms
    } keys %$methods;
    delete $methods->@{@invalid_ids};

    return $self->_p2p_advertiser_payment_method_details($methods);
}

=head2 _order_ownership_type

Returns whether client is the buyer or seller of the order.

=cut

sub _order_ownership_type {
    my ($self, $order_info) = @_;

    return 'client' if $order_info->{client_loginid} eq $self->loginid;

    return 'advertiser' if $order_info->{advertiser_loginid} eq $self->loginid;

    return '';
}

=head2 _p2p_order_confirm_verification

Handles email verification if required by the country.

=cut

sub _p2p_order_confirm_verification {
    my ($self, $order, %param) = @_;

    my $p2p_config    = BOM::Config::Runtime->instance->app_config->payments->p2p;
    my @countries     = $p2p_config->transaction_verification_countries->@*;
    my $all_countries = $p2p_config->transaction_verification_countries_all;

    return if (not $all_countries) and none { $self->residence eq $_ } @countries;
    return if $all_countries       and any { $self->residence eq $_ } @countries;

    my $order_id      = $order->{id};
    my $redis         = BOM::Config::Redis->redis_p2p_write;
    my $attempts_key  = P2P_VERIFICATION_ATTEMPT_KEY . "::$order_id";
    my $history_key   = P2P_VERIFICATION_HISTORY_KEY . "::$order_id";
    my $event_postfix = '|' . $order_id . '|' . $self->loginid;         # note here we use seller loginid, but other places use order client_loginid

    # after 3 failures, lockout for 30 min
    if ($redis->zrangebyscore($attempts_key, '-Inf', time)->@* >= P2P_VERIFICATION_MAX_ATTEMPTS) {
        $redis->zadd(P2P_VERIFICATION_EVENT_KEY, time + P2P_VERIFICATION_LOCKOUT_TTL, "LOCKOUT$event_postfix");
        $redis->zrem(P2P_VERIFICATION_EVENT_KEY, "REQUEST_BLOCK$event_postfix", "TOKEN_VALID$event_postfix");

        $redis->del($attempts_key);
        $redis->rpush($history_key, time . '|30 minute lockout for too many failures');

        # revert order expiry and timeout
        my $cli_redis_item  = $order_id . '|' . $order->{client_loginid};         # these items have order client_loginid not seller loginid
        my $original_expiry = Date::Utility->new($order->{expire_time})->epoch;

        if (my $order_expiry = $redis->zscore(P2P_ORDER_EXPIRES_AT, $cli_redis_item)) {
            $redis->zadd(P2P_ORDER_EXPIRES_AT, $original_expiry, $cli_redis_item) if $order_expiry > $original_expiry;
        }

        if (my $order_timedout_at = $redis->zscore(P2P_ORDER_TIMEDOUT_AT, $cli_redis_item)) {
            $redis->zadd(P2P_ORDER_TIMEDOUT_AT, $original_expiry, $cli_redis_item) if $order_timedout_at > $original_expiry;
        }

        BOM::Platform::Event::Emitter::emit(
            p2p_order_updated => {
                client_loginid => $self->loginid,
                order_id       => $order_id,
            });
    }

    my $lockout_expiry = $redis->zscore(P2P_VERIFICATION_EVENT_KEY, "LOCKOUT$event_postfix") // 0;
    if ($lockout_expiry > time) {
        die +{
            error_code     => 'ExcessiveVerificationFailures',
            message_params => [ceil(($lockout_expiry - time) / 60)],
        };
    }

    if (my $code = $param{verification_code}) {
        my $token = BOM::Platform::Token->new({token => $code});

        unless ($token->token and $token->{created_for} eq 'p2p_order_confirm' and $token->email eq $self->email) {
            $redis->zrem($attempts_key, $code);           # don't count expired code twice
            $redis->zadd($attempts_key, time, rand());    # record a failed attempt at current time
            $redis->rpush($history_key, time . '|Invalid/expired token provided');
            die +{error_code => 'InvalidVerificationToken'};
        }

        if ($param{dry_run}) {
            $redis->rpush($history_key, time . '|Successful dry run');
        } else {
            $token->delete_token;
        }

    } else {
        # max 1 request per minute
        my $request_expiry = $redis->zscore(P2P_VERIFICATION_EVENT_KEY, "REQUEST_BLOCK$event_postfix") // 0;
        if ($request_expiry > time) {
            $redis->rpushx($history_key, time . '|Too frequent requests for verification email');
            die +{
                error_code     => 'ExcessiveVerificationRequests',
                message_params => [$request_expiry - time],
            };
        }

        $redis->zadd(P2P_VERIFICATION_EVENT_KEY, time + P2P_VERIFICATION_REQUEST_INTERVAL, "REQUEST_BLOCK$event_postfix");

        my $code = BOM::Platform::Token->new({
                email       => $self->email,
                created_for => 'p2p_order_confirm',
                expires_in  => P2P_VERIFICATION_TOKEN_EXPIRY,
            })->token;

        my $token_expiry = time + P2P_VERIFICATION_TOKEN_EXPIRY;
        $redis->zadd($attempts_key, $token_expiry, $code);    # record a failed attempt for future, on token expiry

        $redis->zadd(P2P_VERIFICATION_EVENT_KEY, $token_expiry, "TOKEN_VALID$event_postfix");

        # extend order expiry and timeout to match token expiry
        my $cli_redis_item = $order_id . '|' . $order->{client_loginid};    # these items have order client_loginid not seller loginid

        if (my $order_expiry = $redis->zscore(P2P_ORDER_EXPIRES_AT, $cli_redis_item)) {    #todo: simplify when redis version supports GT flag
            $redis->zadd(P2P_ORDER_EXPIRES_AT, $token_expiry, $cli_redis_item) if $token_expiry > $order_expiry;
        }

        if (my $order_timedout_at = $redis->zscore(P2P_ORDER_TIMEDOUT_AT, $cli_redis_item)) {
            my $adjusted_expiry = $token_expiry - ($p2p_config->refund_timeout * 24 * 60 * 60);    # setting is days
            $redis->zadd(P2P_ORDER_TIMEDOUT_AT, $adjusted_expiry, $cli_redis_item) if $adjusted_expiry > $order_timedout_at;
        }

        my $url = BOM::Database::Model::OAuth->new->get_verification_uri_by_app_id($param{source});
        $url .= "/p2p?action=p2p_order_confirm&order_id=$order_id&code=$code&lang=" . request->language if $url;

        BOM::Platform::Event::Emitter::emit(
            p2p_order_confirm_verify => {
                loginid          => $self->loginid,
                verification_url => $url,
                code             => $code,
                order_id         => $order_id,
                order_amount     => $order->{amount},
                order_currency   => $order->{account_currency},
                buyer_name       => $order->{advert_type} eq 'buy' ? $order->{advertiser_name} : $order->{client_name},
                live_chat_url    => request->brand->live_chat_url({
                        app_id   => request->app_id,
                        language => request->language
                    }
                ),
                password_reset_url => request->brand->password_reset_url({
                        source   => request->app_id,
                        language => request->language
                    }
                ),
            });

        BOM::Platform::Event::Emitter::emit(
            p2p_order_updated => {
                client_loginid => $self->loginid,
                order_id       => $order_id,
            });

        $redis->rpush($history_key, time . '|Requested email');

        die +{error_code => 'OrderEmailVerificationRequired'};
    }

    return;
}

=head2 _advertiser_details

Prepares advertiser fields for client display.
Takes and returns single advertiser.

=cut

sub _advertiser_details {
    my ($self, $advertiser) = @_;

    my $stats_days = 30;                              # days for stats, per websocket fields description
    my $loginid    = $advertiser->{client_loginid};
    my %stats      = $self->_p2p_advertiser_stats($advertiser->{client_loginid}, $stats_days * 24)->%*;

    my $details = {
        id                         => $advertiser->{id},
        name                       => $advertiser->{name},
        created_time               => Date::Utility->new($advertiser->{created_time})->epoch,
        is_approved                => $advertiser->{is_approved},
        is_listed                  => $advertiser->{is_listed},
        default_advert_description => $advertiser->{default_advert_description} // '',
        buy_completion_rate        => $stats{buy_completion_rate},
        buy_orders_count           => $stats{buy_completed_count},
        buy_orders_amount          => $stats{buy_completed_amount},
        sell_completion_rate       => $stats{sell_completion_rate},
        sell_orders_count          => $stats{sell_completed_count},
        sell_orders_amount         => $stats{sell_completed_amount},
        total_completion_rate      => defined $advertiser->{completion_rate} ? sprintf("%.1f", $advertiser->{completion_rate} * 100) : undef,
        total_orders_count         => $stats{total_orders_count},
        total_turnover             => $stats{total_turnover},
        buy_time_avg               => $stats{buy_time_avg},
        release_time_avg           => $stats{release_time_avg},
        cancel_time_avg            => $stats{cancel_time_avg},
        partner_count              => $stats{partner_count},
        advert_rates               => $stats{advert_rates},
        rating_average             => defined $advertiser->{rating_average} ? sprintf('%.2f', $advertiser->{rating_average}) : undef,
        rating_count               => $advertiser->{rating_count} // 0,
        recommended_average        => defined $advertiser->{recommended_average} ? sprintf('%.1f', $advertiser->{recommended_average} * 100) : undef,
        recommended_count          => defined $advertiser->{recommended_average} ? $advertiser->{recommended_count}                          : undef,
        $self->_p2p_advertiser_online_status($advertiser->{client_loginid}, $advertiser->{country} // $self->residence),
    };

    if ($advertiser->{show_name}) {
        $details->{first_name} = $advertiser->{first_name};
        $details->{last_name}  = $advertiser->{last_name};
    }

    # only advertiser themself can see these fields
    if ($self->loginid eq $loginid) {
        $details->{payment_info}      = $advertiser->{payment_info} // '';
        $details->{contact_info}      = $advertiser->{contact_info} // '';
        $details->{chat_user_id}      = $advertiser->{chat_user_id};
        $details->{chat_token}        = $advertiser->{chat_token} // '';
        $details->{show_name}         = $advertiser->{show_name};
        $details->{balance_available} = $self->p2p_balance;
        $details->{withdrawal_limit} =
            defined $advertiser->{withdrawal_limit}
            ? financialrounding('amount', $advertiser->{account_currency}, $advertiser->{withdrawal_limit})
            : undef;
        $details->{basic_verification} = $self->status->age_verification ? 1 : 0;
        $details->{full_verification}  = $self->fully_authenticated      ? 1 : 0;
        $details->{cancels_remaining}  = $self->_p2p_advertiser_cancellations->{remaining};
        $details->{blocked_by_count}   = $advertiser->{blocked_by_count}
            // 0;    # only p2p.advertiser_create does not return it, but there it must be zero

        for my $amt (qw/daily_buy daily_sell/) {
            # advertiser_create does not return these fields, but they must be zero
            $details->{$amt} = financialrounding('amount', $advertiser->{account_currency}, $advertiser->{$amt} // 0);
        }

        for my $limit (qw/daily_buy_limit daily_sell_limit min_order_amount max_order_amount min_balance/) {
            $details->{$limit} = financialrounding('amount', $advertiser->{account_currency}, $advertiser->{$limit})
                if defined $advertiser->{$limit};
        }

        $details->{block_trade} = {
            min_order_amount => financialrounding('amount', $advertiser->{account_currency}, $advertiser->{block_trade_min_order_amount}),
            max_order_amount => financialrounding('amount', $advertiser->{account_currency}, $advertiser->{block_trade_max_order_amount}),
            }
            if all { defined $advertiser->{$_} } qw(block_trade_min_order_amount block_trade_max_order_amount);

        if ($advertiser->{blocked_until}) {
            my $block_time = Date::Utility->new($advertiser->{blocked_until});
            $details->{blocked_until} = $block_time->epoch if Date::Utility->new->is_before($block_time);
        }

        # if ad rates are not in the default setting, FE needs to know if advertiser has active ads of each type
        my $advert_config = BOM::Config::P2P::advert_config()->{$self->residence};
        if ($advert_config and ($advert_config->{fixed_ads} ne 'enabled' or $advert_config->{float_ads} ne 'disabled')) {
            my $ads = $self->_p2p_adverts(
                advertiser_id => $advertiser->{id},
                is_active     => 1,
                country       => $self->residence,
            );
            for my $type ('fixed', 'float') {
                my $count = scalar grep { $_->{rate_type} eq $type } @$ads;
                $details->{'active_' . $type . '_ads'} = $count if $count > 0;
            }
        }

        if ($advertiser->{is_approved} and not($details->{blocked_until})) {
            my $redis = BOM::Config::Redis->redis_p2p();
            if (my $upgrade = $redis->hget(P2P_ADVERTISER_BAND_UPGRADE_PENDING, $advertiser->{id})) {
                try {
                    $upgrade = decode_json_utf8($upgrade);

                    $details->{upgradable_daily_limits} = {
                        max_daily_sell => financialrounding('amount', $advertiser->{account_currency}, $upgrade->{target_max_daily_sell}),
                        max_daily_buy  => financialrounding('amount', $advertiser->{account_currency}, $upgrade->{target_max_daily_buy}),
                        block_trade    => $upgrade->{target_block_trade},
                    };

                } catch ($e) {
                    $log->warnf("Invalid JSON stored for advertiser id %s with data '%s' in redis hash key %s: %s",
                        $advertiser->{id}, $upgrade, P2P_ADVERTISER_BAND_UPGRADE_PENDING, $e);
                }
            }
        }

    } else {
        $details->{basic_verification} = $advertiser->{basic_verification};
        $details->{full_verification}  = $advertiser->{full_verification};
        $details->{is_blocked}         = $advertiser->{blocked};
        $details->{is_favourite}       = $advertiser->{favourite};
        $details->{is_recommended}     = $advertiser->{recommended};
    }

    return $details;
}

=head2 _advert_details

Prepares advert fields for client display.
Takes and returns an arrayref of advert.

=cut

sub _advert_details {
    my ($self, $list, $amount) = @_;
    my (@results, $payment_method_defs);

    my $redis      = BOM::Config::Redis->redis_p2p();
    my $start_ts   = Date::Utility->new->minus_time_interval('720h')->epoch;      # for 30 day completed order count
    my $p2p_config = BOM::Config::Runtime->instance->app_config->payments->p2p;

    for my $advert (@$list) {

        my $result = {
            account_currency  => $advert->{account_currency},
            country           => $advert->{country},
            created_time      => Date::Utility->new($advert->{created_time})->epoch,
            description       => $advert->{description} // '',
            id                => $advert->{id},
            is_active         => $advert->{is_active},
            local_currency    => $advert->{local_currency},
            payment_method    => $advert->{payment_method},
            type              => $advert->{type},
            counterparty_type => P2P_COUNTERYPARTY_TYPE_MAPPING->{$advert->{type}},
            price             => $advert->{effective_rate} ? p2p_rate_rounding($advert->{effective_rate}) * ($amount // 1) : undef,
            price_display     => $advert->{effective_rate}
            ? financialrounding('amount', $advert->{local_currency}, p2p_rate_rounding($advert->{effective_rate}) * ($amount // 1))
            : undef,
            rate         => $advert->{rate},
            rate_type    => $advert->{rate_type},
            rate_display => $advert->{rate_type} eq 'float' ? sprintf('%+.2f', $advert->{rate})
            : p2p_rate_rounding($advert->{rate}, display => 1),
            effective_rate                 => p2p_rate_rounding($advert->{effective_rate}),
            effective_rate_display         => p2p_rate_rounding($advert->{effective_rate}, display => 1),
            order_expiry_period            => $advert->{order_expiry_period} // $p2p_config->order_timeout,
            min_order_amount_limit         => $advert->{min_order_amount},
            min_order_amount_limit_display => financialrounding('amount', $advert->{account_currency}, $advert->{min_order_amount}),
            max_order_amount_limit         => $advert->{max_order_amount_actual},
            max_order_amount_limit_display => financialrounding('amount', $advert->{account_currency}, $advert->{max_order_amount_actual}),
            block_trade                    => $advert->{block_trade},
            # to match p2p_advert_list params, plus checking if advertiser blocked
            is_visible => (
                        $advert->{is_active}
                    and $advert->{can_order}
                    and $advert->{advertiser_is_approved}
                    and $advert->{advertiser_is_listed}
                    and not $advert->{advertiser_blocked}
                    and not $advert->{is_deleted}
                ) ? 1
            : 0,
            advertiser_details => {
                id                    => $advert->{advertiser_id},
                name                  => $advert->{advertiser_name},
                total_completion_rate => defined $advert->{advertiser_completion} ? sprintf("%.1f", $advert->{advertiser_completion} * 100)
                : undef,
                $advert->{advertiser_show_name}
                ? (
                    first_name => $advert->{advertiser_first_name},
                    last_name  => $advert->{advertiser_last_name},
                    )
                : (),
                ($self->loginid ne $advert->{advertiser_loginid})
                ? (
                    is_favourite   => $advert->{advertiser_favourite},
                    is_blocked     => $advert->{advertiser_blocked},
                    is_recommended => $advert->{advertiser_recommended},
                    )
                : (),
                completed_orders_count =>
                    $redis->zcount(join('::', P2P_STATS_REDIS_PREFIX, $advert->{advertiser_loginid}, 'BUY_COMPLETED'),  $start_ts, '+inf') +
                    $redis->zcount(join('::', P2P_STATS_REDIS_PREFIX, $advert->{advertiser_loginid}, 'SELL_COMPLETED'), $start_ts, '+inf'),
                rating_average      => defined $advert->{advertiser_rating_average} ? sprintf('%.2f', $advert->{advertiser_rating_average}) : undef,
                rating_count        => $advert->{advertiser_rating_count} // 0,
                recommended_average => defined $advert->{advertiser_recommended_average}
                ? sprintf('%.1f', $advert->{advertiser_recommended_average} * 100)
                : undef,
                # calculate the number of positive recommendations
                recommended_count => defined $advert->{advertiser_recommended_average} ? $advert->{advertiser_recommended_count} : undef,
                $self->_p2p_advertiser_online_status($advert->{advertiser_loginid}, $advert->{advertiser_country}),
            },
        };

        if ($advert->{is_active} and $self->loginid eq $advert->{advertiser_loginid}) {
            if (my $archive_date = $redis->hget(P2P_ARCHIVE_DATES_KEY, $advert->{id})) {
                my $days = Date::Utility->new($archive_date)->days_between(Date::Utility->new);
                $result->{days_until_archive} = $days < 0 ? 0 : $days;
            }
        }

        my $payment_method_names = $advert->{available_payment_method_names};
        $payment_method_names = $advert->{payment_method_names} unless @$payment_method_names;

        if ($payment_method_names and @$payment_method_names) {
            $payment_method_defs //= $self->p2p_payment_methods();
            $result->{payment_method_names} = [
                sort map { $payment_method_defs->{$_}{display_name} }
                grep     { exists $payment_method_defs->{$_} } @$payment_method_names
            ];
        }

        if ($self->loginid eq $advert->{advertiser_loginid}) {
            # only the advert owner can see these fields
            $result->{payment_info}             = $advert->{payment_info} // '';
            $result->{contact_info}             = $advert->{contact_info} // '';
            $result->{amount}                   = financialrounding('amount', $advert->{account_currency}, $advert->{amount});
            $result->{amount_display}           = formatnumber('amount', $advert->{account_currency}, $advert->{amount});
            $result->{min_order_amount}         = financialrounding('amount', $advert->{account_currency}, $advert->{min_order_amount});
            $result->{min_order_amount_display} = formatnumber('amount', $advert->{account_currency}, $advert->{min_order_amount});
            $result->{max_order_amount}         = financialrounding('amount', $advert->{account_currency}, $advert->{max_order_amount});
            $result->{max_order_amount_display} = formatnumber('amount', $advert->{account_currency}, $advert->{max_order_amount});
            $result->{remaining_amount}         = financialrounding('amount', $advert->{account_currency}, $advert->{remaining});
            $result->{remaining_amount_display} = formatnumber('amount', $advert->{account_currency}, $advert->{remaining});
            $result->{active_orders}            = $advert->{active_orders};
            $result->{payment_method_details}   = $advert->{payment_method_details}
                if $advert->{payment_method_details} and $advert->{payment_method_details}->%*;

            if (not $result->{is_visible}) {
                my @reasons;
                push @reasons, 'advert_inactive'  if not $advert->{is_active};
                push @reasons, 'advert_max_limit' if $advert->{max_order_exceeded};
                # advert_min_limit should only be returned for the exact reason of band minimum
                push @reasons, 'advert_min_limit'
                    if ($advert->{advertiser_band_min_balance} // 0) > $advert->{min_order_amount}
                    and $advert->{max_order_amount_actual} < $advert->{advertiser_band_min_balance}
                    and $advert->{max_order_amount_actual} > $advert->{min_order_amount};
                push @reasons, 'advert_remaining'      if $advert->{remaining} < $advert->{min_order_amount};
                push @reasons, 'advertiser_ads_paused' if not $advert->{advertiser_is_listed};
                push @reasons, 'advertiser_approval'   if not $advert->{advertiser_is_approved};
                push @reasons, 'advertiser_balance'
                    if $advert->{type} eq 'sell' and $advert->{advertiser_available_balance} < $advert->{min_order_amount};
                push @reasons, 'advertiser_daily_limit'
                    if defined($advert->{advertiser_available_limit})
                    and $advert->{advertiser_available_limit} < $advert->{min_order_amount};
                push @reasons, 'advertiser_temp_ban'               if $advert->{advertiser_temp_ban};
                push @reasons, 'advertiser_block_trade_ineligible' if $advert->{block_trade} and not $advert->{advertiser_can_block_trade};
                $result->{visibility_status} = \@reasons;
            }
        }

        push @results, $result;
    }

    return \@results;
}

=head2 _order_details

Prepares order fields for client display.
Takes and returns an arrayref of orders.

=cut

sub _order_details {
    my ($self, $list) = @_;
    my (@results, $payment_method_defs, $review_hours);

    my $redis = BOM::Config::Redis->redis_p2p();

    for my $order (@$list) {
        my $role = $self->_order_ownership_type($order);

        my $result = +{
            account_currency   => $order->{account_currency},
            created_time       => Date::Utility->new($order->{created_time})->epoch,
            payment_info       => $order->{payment_info} // '',
            contact_info       => $order->{contact_info} // '',
            expiry_time        => Date::Utility->new($order->{expire_time})->epoch,
            id                 => $order->{id},
            is_incoming        => $role eq 'advertiser' ? 1 : 0,
            local_currency     => $order->{local_currency},
            amount             => $order->{amount},
            amount_display     => financialrounding('amount', $order->{account_currency}, $order->{amount}),
            price              => p2p_rate_rounding($order->{rate}) * $order->{amount},
            price_display      => financialrounding('amount', $order->{local_currency}, p2p_rate_rounding($order->{rate}) * $order->{amount}),
            rate               => p2p_rate_rounding($order->{rate}),
            rate_display       => p2p_rate_rounding($order->{rate}, display => 1),
            status             => $order->{status},
            type               => $order->{type},
            chat_channel_url   => $order->{chat_channel_url} // '',
            advertiser_details => {
                id         => $order->{advertiser_id},
                name       => $order->{advertiser_name},
                loginid    => $order->{advertiser_loginid},
                first_name => $order->{advertiser_first_name},
                last_name  => $order->{advertiser_last_name},
                ($role eq 'client' and exists $order->{advertiser_recommended}) ? (is_recommended => $order->{advertiser_recommended}) : (),
                $self->_p2p_advertiser_online_status($order->{advertiser_loginid}, $order->{advertiser_country}),

            },
            client_details => {
                id         => $order->{client_id}   // '',
                name       => $order->{client_name} // '',
                loginid    => $order->{client_loginid},
                first_name => $order->{client_first_name},
                last_name  => $order->{client_last_name},
                ($role eq 'advertiser' and exists $order->{client_recommended}) ? (is_recommended => $order->{client_recommended}) : (),
                $self->_p2p_advertiser_online_status($order->{client_loginid}, $order->{client_country}),
            },
            advert_details => {
                id             => $order->{advert_id},
                description    => $order->{advert_description} // '',
                type           => $order->{advert_type},
                payment_method => 'bank_transfer',                      # must be bank_transfer to not break mobile!
                block_trade    => $order->{advert_block_trade},
            },
            dispute_details => {
                dispute_reason   => $order->{dispute_reason},
                disputer_loginid => $order->{disputer_loginid},
            },
            ($order->{payment_method}) ? (payment_method => $order->{payment_method}) : (),
            ($role eq 'client' and $order->{advertiser_review_rating})
            ? (
                review_details => {
                    created_time => Date::Utility->new($order->{advertiser_review_time})->epoch,
                    rating       => $order->{advertiser_review_rating},
                    recommended  => $order->{advertiser_review_recommended},
                })
            : (),
            ($role eq 'advertiser' and $order->{client_review_rating})
            ? (
                review_details => {
                    created_time => Date::Utility->new($order->{client_review_time})->epoch,
                    rating       => $order->{client_review_rating},
                    recommended  => $order->{client_review_recommended},
                })
            : (),
        };

        unless ($self->_is_order_status_final($order->{status})) {
            my $last_seen_status = $self->_get_last_seen_status(
                order_id => $order->{id},
                loginid  => $self->loginid
            );
            $result->{is_seen} = $order->{status} eq ($last_seen_status // '') ? 1 : 0;
        }

        if ($order->{payment_method_details} and $order->{payment_method_details}->%*) {
            $result->{payment_method_details} = $order->{payment_method_details};
            my (undef, $seller) = $self->_p2p_order_parties($order);
            if ($seller ne $self->loginid) {
                # only the seller (pm owner) can see these fields
                delete $result->{payment_method_details}{$_}->@{qw(used_by_adverts used_by_orders)} for keys $result->{payment_method_details}->%*;
            }
        } elsif ($order->{payment_method}) {
            $payment_method_defs //= $self->p2p_payment_methods();
            $result->{payment_method_names} =
                [map { $payment_method_defs->{$_}{display_name} } grep { exists $payment_method_defs->{$_} } split ',', $order->{payment_method}];
        }

        $result->{is_reviewable} = 0;

        if ($order->{completion_time}) {
            $result->{completion_time} = Date::Utility->new($order->{completion_time})->epoch;
            if ($order->{status} eq 'completed' and not $result->{review_details}) {
                $review_hours //= BOM::Config::Runtime->instance->app_config->payments->p2p->review_period;
                $result->{is_reviewable} = 1 if (time - $result->{completion_time}) <= ($review_hours * 60 * 60);
            }
        }

        if ($redis->exists(P2P_VERIFICATION_HISTORY_KEY . '::' . $order->{id})) {
            my (undef, $seller) = $self->_p2p_order_parties($order);
            my $event_postfix = '|' . $order->{id} . '|' . $seller;

            my $token_expiry = $redis->zscore(P2P_VERIFICATION_EVENT_KEY, "TOKEN_VALID$event_postfix");

            $result->{verification_pending} = ($token_expiry // 0) > time ? 1 : 0;
            $result->{expiry_time}          = $token_expiry if ($token_expiry // 0) > $result->{expiry_time};

            if ($seller eq $self->loginid) {
                $result->{verification_token_expiry} = $token_expiry if $result->{verification_pending};

                my $request_expiry = $redis->zscore(P2P_VERIFICATION_EVENT_KEY, "REQUEST_BLOCK$event_postfix") // 0;
                my $lockout_expiry = $redis->zscore(P2P_VERIFICATION_EVENT_KEY, "LOCKOUT$event_postfix")       // 0;

                $result->{verification_next_request}  = $request_expiry if $request_expiry > time;
                $result->{verification_lockout_until} = $lockout_expiry if $lockout_expiry > time;
            }
        }

        push @results, $result;
    }

    return \@results;
}

=head2 _is_order_status_final

Returns true if the status is final.

=cut

sub _is_order_status_final {
    my (undef, $status) = @_;
    return any { $status eq $_ } P2P_ORDER_STATUS->{final}->@*;
}

=head2 _p2p_record_stat

Records time-sensitive stats for a P2P advertiser.

Takes the following arguments:

=over

=item * C<loginid> - advertiser loginid

=item * C<stat> - name of stat

=item * C<payload> - (array) items to be joined to make unique payload

=back

=cut

sub _p2p_record_stat {
    my ($self, %param) = @_;
    my $redis    = BOM::Config::Redis->redis_p2p_write();
    my $prune_ts = Date::Utility->new->minus_time_interval(P2P_STATS_TTL_IN_DAYS . 'd')->epoch;
    my $expiry   = P2P_STATS_TTL_IN_DAYS * 24 * 60 * 60;
    my $key      = join '::', P2P_STATS_REDIS_PREFIX, $param{loginid}, $param{stat};
    my $item     = join '|',  $param{payload}->@*;
    $redis->zadd($key, ($param{ts} // time), $item);
    $redis->expire($key, $expiry);
    $redis->zremrangebyscore($key, '-inf', '(' . $prune_ts);

    return undef;
}

=head2 _p2p_record_partners

Records trading partners for a successfully completed order.

Takes the following arguments:

=over

=item * C<order> - order hashref

=back

=cut

sub _p2p_record_partners {
    my ($self, $order) = @_;

    my $redis = BOM::Config::Redis->redis_p2p_write();
    $redis->sadd(join('::', P2P_STATS_REDIS_PREFIX, $order->{client_loginid},     'ORDER_PARTNERS'), $order->{advertiser_id});
    $redis->sadd(join('::', P2P_STATS_REDIS_PREFIX, $order->{advertiser_loginid}, 'ORDER_PARTNERS'), $order->{client_id});
    return;
}

=head2 _p2p_record_order_partners

Records order partners for a created order.

Takes the following arguments:

=over

=item * C<order> - order hashref

=back

=cut

sub _p2p_record_order_partners {
    my ($self, $order) = @_;

    my $redis = BOM::Config::Redis->redis_p2p_write();
    $redis->sadd(join('::', P2P_ORDER_PARTIES, $order->{client_id}),     $order->{advertiser_id});
    $redis->sadd(join('::', P2P_ORDER_PARTIES, $order->{advertiser_id}), $order->{client_id});
    return;
}

=head2 _p2p_advertiser_stats

Returns P2P advertiser statistics

Example usage:

    $self->_p2p_order_stats_get('CR001', 24);

Takes the following arguments:

=over 4

=item * C<$loginid> - loginid of advertiser

=item * C<hours> - period to generate stats in hours, lifetime if 0 or undef

=back

Returns hashref.

=cut

sub _p2p_advertiser_stats {
    my ($self, $loginid, $hours) = @_;
    my $start_ts   = $hours ? Date::Utility->new->minus_time_interval($hours . 'h')->epoch : '-inf';
    my $key_prefix = P2P_STATS_REDIS_PREFIX . '::' . $loginid . '::';
    my $redis      = BOM::Config::Redis->redis_p2p();

    # items are "id|amount", "id|time" or "id|boolean"
    my %raw;
    for my $key (
        qw/BUY_COMPLETED SELL_COMPLETED ORDER_CANCELLED BUY_FRAUD SELL_FRAUD CANCEL_TIMES BUY_TIMES RELEASE_TIMES BUY_COMPLETION SELL_COMPLETION ADVERT_RATES/
        )
    {
        $raw{$key} = [map { (split /\|/, $_)[1] } $redis->zrangebyscore($key_prefix . $key, $start_ts, '+inf')->@*];
    }

    my $stats = {
        total_orders_count  => $redis->hget(P2P_STATS_REDIS_PREFIX . '::TOTAL_COMPLETED', $loginid) // 0,
        total_turnover      => financialrounding('amount', $self->currency, $redis->hget(P2P_STATS_REDIS_PREFIX . '::TOTAL_TURNOVER', $loginid) // 0),
        buy_completed_count => scalar $raw{BUY_COMPLETED}->@*,
        buy_completed_amount  => financialrounding('amount', $self->currency, List::Util::sum($raw{BUY_COMPLETED}->@*) // 0),
        sell_completed_count  => scalar $raw{SELL_COMPLETED}->@*,
        sell_completed_amount => financialrounding('amount', $self->currency, List::Util::sum($raw{SELL_COMPLETED}->@*) // 0),
        cancel_count          => scalar $raw{ORDER_CANCELLED}->@*,
        cancel_amount         => financialrounding('amount', $self->currency, List::Util::sum($raw{ORDER_CANCELLED}->@*) // 0),
        buy_fraud_count       => scalar $raw{BUY_FRAUD}->@*,
        buy_fraud_amount      => financialrounding('amount', $self->currency, List::Util::sum($raw{BUY_FRAUD}->@*) // 0),
        sell_fraud_count      => scalar $raw{SELL_FRAUD}->@*,
        sell_fraud_amount     => financialrounding('amount', $self->currency, List::Util::sum($raw{SELL_FRAUD}->@*) // 0),
        buy_time_avg        => $raw{BUY_TIMES}->@*     ? sprintf("%.0f", List::Util::sum($raw{BUY_TIMES}->@*) / $raw{BUY_TIMES}->@*)         : undef,
        release_time_avg    => $raw{RELEASE_TIMES}->@* ? sprintf("%.0f", List::Util::sum($raw{RELEASE_TIMES}->@*) / $raw{RELEASE_TIMES}->@*) : undef,
        cancel_time_avg     => $raw{CANCEL_TIMES}->@*  ? sprintf("%.0f", List::Util::sum($raw{CANCEL_TIMES}->@*) / $raw{CANCEL_TIMES}->@*)   : undef,
        buy_completion_rate => $raw{BUY_COMPLETION}->@*
        ? sprintf("%.1f", (List::Util::sum($raw{BUY_COMPLETION}->@*) / $raw{BUY_COMPLETION}->@*) * 100)
        : undef,
        sell_completion_rate => $raw{SELL_COMPLETION}->@*
        ? sprintf("%.1f", (List::Util::sum($raw{SELL_COMPLETION}->@*) / $raw{SELL_COMPLETION}->@*) * 100)
        : undef,
        advert_rates => $raw{ADVERT_RATES}->@* ? sprintf("%.2f", (List::Util::sum($raw{ADVERT_RATES}->@*) / $raw{ADVERT_RATES}->@*) * 100)
        : undef,
        partner_count => $redis->scard($key_prefix . 'ORDER_PARTNERS'),
    };

    return $stats;
}

=head2 _p2p_advertiser_online_status

Gets online status of an advertiser.

Takes the following arguments:

=over 4

=item * C<$loginid> - loginid of advertiser

=back

Returns hash of fields that can be used directly in responses.

=cut

sub _p2p_advertiser_online_status {
    my ($self, $loginid, $country) = @_;

    my $last_online = BOM::Config::Redis->redis_p2p->zscore(P2P_USERS_ONLINE_KEY, ($loginid . "::" . $country));

    return (
        is_online        => ($last_online and $last_online >= (time - P2P_ONLINE_PERIOD)) ? 1 : 0,
        last_online_time => $last_online,
    );
}

=head2 _p2p_advertiser_relation_lists

Get all P2P advertiser relations of current user.

=cut

sub _p2p_advertiser_relation_lists {
    my ($self) = @_;

    my $advertiser = $self->_p2p_advertiser_cached or return;

    my $relations = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref('SELECT * FROM p2p.advertiser_relation_list(?)', {Slice => {}}, $advertiser->{id});
        });

    my $lists;
    for my $rel (@$relations) {
        push $lists->{$rel->{relation_type}}->@*,
            {
            created_time => Date::Utility->new($rel->{created_time})->epoch,
            id           => $rel->{relation_id},
            name         => $rel->{relation_name},
            };
    }

    return {
        favourite_advertisers => $lists->{favourite} // [],
        blocked_advertisers   => $lists->{block}     // []};
}

=head2 _p2p_order_buy_confirmed

Called when order is buy confirmed by client as $self.

Takes the following argument:

=over 4

=item * C<order> - result of p2p.order_confirm* db function as hashref.

=back

=cut

sub _p2p_order_buy_confirmed {
    my ($self, $order) = @_;

    # for calculating release times
    my $redis = BOM::Config::Redis->redis_p2p_write();
    $redis->hset(P2P_STATS_REDIS_PREFIX . '::BUY_CONFIRM_TIMES', $order->{id}, time);
    return;
}

=head2 _p2p_order_completed

Called when an order is completed as a result of seller confirmation.
Not called for disputes.

Takes the following argument:

=over 4

=item * C<order> - order hashref

=back

=cut

sub _p2p_order_completed {
    my ($self, $order) = @_;

    my ($buyer, $seller) = $self->_p2p_order_parties($order);
    my $redis = BOM::Config::Redis->redis_p2p();
    my ($id, $amount) = $order->@{qw/id amount/};

    $self->_p2p_record_stat(
        loginid => $buyer,
        stat    => 'BUY_COMPLETED',
        payload => [$id, $amount]);

    $self->_p2p_record_stat(
        loginid => $seller,
        stat    => 'SELL_COMPLETED',
        payload => [$id, $amount]);

    $self->_p2p_record_stat(
        loginid => $buyer,
        stat    => 'BUY_COMPLETION',
        payload => [$id, 1]);

    $self->_p2p_record_stat(
        loginid => $seller,
        stat    => 'SELL_COMPLETION',
        payload => [$id, 1]);
    $redis->hincrby(P2P_STATS_REDIS_PREFIX . '::TOTAL_COMPLETED', $buyer,  1);
    $redis->hincrby(P2P_STATS_REDIS_PREFIX . '::TOTAL_COMPLETED', $seller, 1);
    $redis->hincrbyfloat(P2P_STATS_REDIS_PREFIX . '::TOTAL_TURNOVER', $buyer,  $amount);
    $redis->hincrbyfloat(P2P_STATS_REDIS_PREFIX . '::TOTAL_TURNOVER', $seller, $amount);
    $redis->zadd(P2P_ORDER_REVIEWABLE_START_AT, time, $id . '|' . $buyer, time, $id . '|' . $seller);
    $self->_p2p_record_partners($order);

    if (my $buy_confirm_epoch = $redis->hget(P2P_STATS_REDIS_PREFIX . '::BUY_CONFIRM_TIMES', $id)) {

        # only record buy and release time if there is no dispute
        unless ($order->{disputer_loginid}) {
            # this buy time assumes buyer actually paid when buyer clicked "I've paid"
            my $buy_time     = $buy_confirm_epoch - Date::Utility->new($order->{created_time})->epoch;
            my $release_time = time - $buy_confirm_epoch;
            $self->_p2p_record_stat(
                loginid => $buyer,
                stat    => 'BUY_TIMES',
                payload => [$id, $buy_time],
                ts      => $buy_confirm_epoch    # ts: stat occurrence will be time buyer clicked "I've paid", not now
            );
            $self->_p2p_record_stat(
                loginid => $seller,
                stat    => 'RELEASE_TIMES',
                payload => [$id, $release_time]);
        }

        # clean up
        $redis->hdel(P2P_STATS_REDIS_PREFIX . '::BUY_CONFIRM_TIMES', $id);
    }

    for my $loginid ($buyer, $seller) {
        BOM::Platform::Event::Emitter::emit(
            p2p_advertiser_updated => {
                client_loginid => $loginid,
            });
    }

    # only update the seller's ads, the buyer event is triggered by the transaction
    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $order->{type} eq 'sell' ? $order->{client_id} : $order->{advertiser_id},
        });

    return;
}

=head2 _p2p_order_cancelled

Called when an order is cancelled manually or expires while pending.
If beyond the grace period, will increment buyer's cancel count.
Will set temporary bar if on the buyer if cancel limit is exceeded.

Takes the following argument:

=over 4

=item * C<order> - order hashref

=back

=cut

sub _p2p_order_cancelled {
    my ($self, $order) = @_;

    my $config = BOM::Config::Runtime->instance->app_config->payments->p2p;
    my $redis  = BOM::Config::Redis->redis_p2p_write();
    my $id     = $order->{id};

    my $elapsed = time - Date::Utility->new($order->{created_time})->epoch;

    # config period is minutes
    return if $elapsed < ($config->cancellation_grace_period * 60);

    my ($buyer_loginid) = $self->_p2p_order_parties($order);
    # make sure we are operating on the buyer - bom-events will use client_loginid of the order, which is not always buyer
    my $buyer_client = $buyer_loginid eq $self->loginid ? $self : BOM::User::Client->new({loginid => $buyer_loginid, context => $self->{context}});

    $buyer_client->_p2p_record_stat(
        loginid => $buyer_loginid,
        stat    => 'ORDER_CANCELLED',
        payload => [$id, $order->{amount}]);
    $buyer_client->_p2p_record_stat(
        loginid => $buyer_loginid,
        stat    => 'BUY_COMPLETION',
        payload => [$id, 0]);

    # manual cancellation
    if ($order->{status} eq 'cancelled') {
        $buyer_client->_p2p_record_stat(
            loginid => $buyer_loginid,
            stat    => 'CANCEL_TIMES',
            payload => [$id, $elapsed]);
    }

    my $buyer_advertiser = $buyer_client->_p2p_advertisers(loginid => $buyer_loginid)->[0] // return;
    return if $buyer_client->_p2p_get_advertiser_bar_error($buyer_advertiser);
    my $cancellations = $buyer_client->_p2p_advertiser_cancellations;

    if ($cancellations->{remaining} == 0) {
        my $block_time = Date::Utility->new->plus_time_interval($config->cancellation_barring->bar_time . 'h');
        $buyer_client->db->dbic->run(
            fixup => sub {
                $_->do(
                    'SELECT p2p.advertiser_update_v2(?, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, ?, NULL, NULL)',
                    undef, $buyer_advertiser->{id},
                    $block_time->datetime
                );
            });

        # used in p2p daemon to push a p2p_advertiser_info message
        $redis->zadd(P2P_ADVERTISER_BLOCK_ENDS_AT, $block_time->epoch, $buyer_loginid);

        BOM::Platform::Event::Emitter::emit(
            p2p_advertiser_temp_banned => {
                loginid        => $buyer_loginid,
                order_id       => $order->{id},
                limit          => $cancellations->{limit},
                block_end_date => $block_time->date,
                block_end_time => $block_time->time_hhmm,

            });
    } else {
        BOM::Platform::Event::Emitter::emit(
            p2p_advertiser_cancel_at_fault => {
                loginid           => $buyer_loginid,
                order_id          => $order->{id},
                cancels_remaining => $cancellations->{remaining},
            });
    }

    return;
}

=head2 _p2p_order_finalized

Called when an order enters final status for any reason.
For cleanup etc.

Takes the following argument:

=over 4

=item * C<order> - order hashref

=back

=cut

sub _p2p_order_finalized {
    my ($self, $order) = @_;
    my $order_id = $order->{id};
    my $redis    = BOM::Config::Redis->redis_p2p_write;

    my @order_keys = map { $order_id . "|" . $_ } $order->@{qw/client_loginid advertiser_loginid/};
    $redis->hdel(P2P_ORDER_LAST_SEEN_STATUS, @order_keys);

    $redis->del(P2P_VERIFICATION_ATTEMPT_KEY . "::$order_id", P2P_VERIFICATION_HISTORY_KEY . "::$order_id");
}

=head2 _p2p_advertiser_cancellations

Returns a hashref containing:

=over 4

=item *  C<remaining> - remaining cancellations allowed for a client

=item *  C<limit> - current cancellation limit

=back

=cut

sub _p2p_advertiser_cancellations {

    my ($self) = @_;
    my $config = BOM::Config::Runtime->instance->app_config->payments->p2p;

    # config period is hours
    my ($period, $limit) = ($config->cancellation_barring->period, $config->cancellation_barring->count);
    my $stats = $self->_p2p_advertiser_stats($self->loginid, $period);

    return {
        remaining => max($limit - $stats->{cancel_count}, 0),
        limit     => $limit,
    };
}

=head2 _p2p_get_advertiser_bar_error

Returns error message for temporary block, or nothing if not blocked.

=cut

sub _p2p_get_advertiser_bar_error {
    my ($self, $advertiser) = @_;

    my $blocked_until = $advertiser->{blocked_until} // return;

    return +{
        error_code     => 'TemporaryBar',
        message_params => [$blocked_until],
        }
        if Date::Utility->new->is_before(Date::Utility->new($blocked_until));
}

=head2 _p2p_order_fraud

Called when an order dispute is resolved as a fraud case.
May disable the advertiser.

Takes the following arguments:

=over 4

=item * Ctype> - type of fraud: buy or sell

=item * C<order> - order hashref

=back

=cut

sub _p2p_order_fraud {
    my ($self, $type, $order) = @_;

    my $redis = BOM::Config::Redis->redis_p2p();
    my ($buyer, $seller) = $self->_p2p_order_parties($order);
    my $loginid = $type eq 'buy' ? $buyer : $seller;

    # Fraud stats are lifetime, so are not added in the usual way
    my $item = join '|',  $order->@{qw/id amount/};
    my $key  = join '::', P2P_STATS_REDIS_PREFIX, $loginid, uc($type) . '_FRAUD';
    $redis->zadd($key, time, $item);

    my $advertiser = $self->_p2p_advertisers(loginid => $loginid)->[0] // return;
    my $config     = BOM::Config::Runtime->instance->app_config->payments->p2p->fraud_blocking;
    my ($period_cfg, $count_cfg) = ($type . '_period', $type . '_count');

    # config period is days, stats are hours
    my $stats = $self->_p2p_advertiser_stats($loginid, $config->$period_cfg * 24);

    if ($stats->{$type . '_fraud_count'} >= $config->$count_cfg) {
        # disable the advertiser
        $self->db->dbic->run(
            fixup => sub {
                $_->do('SELECT p2p.advertiser_update_v2(?, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, FALSE, NULL, NULL, NULL)',
                    undef, $advertiser->{id});
            });
    }

    return;
}

=head2 _p2p_order_parties

Determinine buyer and seller for an order.

Takes the following argument:

=over 4

=item * C<order> - order hashref

=back

Returns array of loginids: (buyer, seller)

=cut

sub _p2p_order_parties {
    my ($self, $order) = @_;

    my $buyer  = $order->{type} eq 'buy'  ? $order->{client_loginid} : $order->{advertiser_loginid};
    my $seller = $order->{type} eq 'sell' ? $order->{client_loginid} : $order->{advertiser_loginid};
    return ($buyer, $seller);
}

=head2 p2p_order_status_history

Get the list of status changes of the specified order.

Note the list is in chronologically ascending order.

Note the list never returns two consecutive repeated status.

The hashref keys for each status change is described as follow:

=over 4

=item * stamp, the timestamp of the status

=item * status, the updated status

=back

It takes the following parameters:

=over 4

=item * order_id, the id of the order

=back

Returns,
    a ref to the list described.

=cut

sub p2p_order_status_history {
    my ($self, $order_id) = @_;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref('SELECT * FROM p2p.order_status_history(?)', {Slice => {}}, $order_id);
        }) // [];
}

=head2 p2p_payment_methods

Returns P2P payment methods optionally filtered by availability in a country.

The payment_method_countries config (json) is set in backoffice. Each method has 2 keys in the config:
    - countries: list of 2 digit country codes
    - mode: include or exclude - controls if method is included or excluded in the country list

Returns hashref compatible with websocket schema.

Takes the following arguments:

=over 4

=item * country: if not provided all pms are returned

=back

=cut

sub p2p_payment_methods {
    my ($self, $country) = @_;

    my $methods        = BOM::Config::p2p_payment_methods();
    my $country_config = $json->decode(BOM::Config::Runtime->instance->app_config->payments->p2p->payment_method_countries);
    my $result         = {};

    for my $method (keys %$methods) {
        my $config    = $country_config->{$method} // {};
        my $mode      = $config->{mode}            // 'include';
        my $countries = $config->{countries}       // [];

        next if $country and $mode eq 'include' and none { $_ eq $country } @$countries;
        next if $country and $mode eq 'exclude' and any { $_ eq $country } @$countries;

        my $method_def = $methods->{$method};
        my %fields     = map {
            $_ => {
                display_name => localize($method_def->{fields}{$_}{display_name}),
                type         => $method_def->{fields}{$_}{type}     // 'text',
                required     => $method_def->{fields}{$_}{required} // 1,
            }
        } keys $method_def->{fields}->%*;

        # this field is needed for all methods
        $fields{instructions} = {
            display_name => localize('Instructions'),
            type         => 'memo',
            required     => 0,
        };

        $result->{$method} = {
            display_name => localize($method_def->{display_name}),
            type         => $method_def->{type},
            fields       => \%fields,
        };
    }

    return $result;
}

=head2 filter_ad_payment_methods

Filters disabled payment methods from an advert's payment_method_names field.
Used when we don't/can't send country_payment_methods param to p2p.advert_list db function.

=over 4

=item * ad: advert as returned from p2p.advert_list()

=back

Returns modified ad.

=cut

sub filter_ad_payment_methods {
    my ($self, $ad) = @_;

    my @my_pms         = keys $self->p2p_payment_methods($self->residence)->%*;
    my @advertiser_pms = keys $self->p2p_payment_methods($ad->{country})->%*;
    my @ad_pms         = ($ad->{payment_method_names} // [])->@*;
    my @valid_pms      = intersect(@my_pms, @advertiser_pms);
    $ad->{payment_method_names} = [intersect(@ad_pms, @valid_pms)];

    return $ad;
}

=head2 p2p_advertiser_payment_methods

Sets and returns advertiser payment methods.

Takes the following named parameters, all optional:

=over 4

=item * create: arrayref of items to create

=item * update: hashref of items to update

=item * delete: arrayref of items to delete

=back

Returns hashref compatible with websocket schema.

=cut

sub p2p_advertiser_payment_methods {
    my ($self, %param) = @_;

    my $advertiser = $self->_p2p_advertiser_cached;
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser;

    $self->set_db('write') if %param;
    my $existing = $self->_p2p_advertiser_payment_methods(advertiser_id => $advertiser->{id});

    delete $param{p2p_advertiser_payment_methods};
    return $self->_p2p_advertiser_payment_method_details($existing) unless %param;

    die +{error_code => 'PaymentMethodsDisabled'}
        unless BOM::Config::Runtime->instance->app_config->payments->p2p->payment_methods_enabled;

    $existing = $self->_p2p_advertiser_payment_method_delete($existing, $param{delete}) if $param{delete};
    $existing = $self->_p2p_advertiser_payment_method_update($existing, $param{update}) if $param{update};
    $self->_p2p_advertiser_payment_method_create($existing, $param{create}) if $param{create};

    BOM::Platform::Event::Emitter::emit(
        p2p_adverts_updated => {
            advertiser_id => $advertiser->{id},
        }) if $param{delete} or $param{update};

    my $update = $self->_p2p_advertiser_payment_methods(advertiser_id => $advertiser->{id});
    return $self->_p2p_advertiser_payment_method_details($update);
}

=head2 _p2p_advertiser_payment_method_delete

Deletes advertiser payment methods.

Takes the following parameters:

=over 4

=item * existing: hashref of existing methods

=item * deletes: arrayref of ids to delete

=back

Returns $existing with deleted items removed.

=cut

sub _p2p_advertiser_payment_method_delete {
    my ($self, $existing, $deletes) = @_;

    for my $id (@$deletes) {
        die +{error_code => 'PaymentMethodNotFound'} unless delete $existing->{$id};
    }

    $self->_p2p_check_payment_methods_in_use($deletes);

    $self->db->dbic->run(
        fixup => sub {
            $_->do('SELECT p2p.advertiser_payment_method_delete(?)', undef, $deletes);
        });

    return $existing;
}

=head2 _p2p_advertiser_payment_method_update

Updates advertiser payment methods.

Takes the following parameters:

=over 4

=item * existing: hashref of existing methods

=item * updates: hashref of items to update

=back

Returns $existing with updated items.

=cut

sub _p2p_advertiser_payment_method_update {
    my ($self, $existing, $updates) = @_;

    my $method_defs = $self->p2p_payment_methods();    # pm can be updated after being disabled in country

    my (@disabled_ids, @updated_ids);
    for my $id (keys %$updates) {

        die +{error_code => 'PaymentMethodNotFound'}
            unless exists $existing->{$id};

        my $method = $existing->{$id}{method};

        if (my $method_def = $method_defs->{$method}) {
            for my $item_field (grep { $_ !~ /^(method|is_enabled)$/ } keys $updates->{$id}->%*) {

                my $field_def = $method_def->{fields}{$item_field};

                die +{
                    error_code     => 'InvalidPaymentMethodField',
                    message_params => [$item_field, $method_def->{display_name}]}
                    unless $field_def;

                die +{
                    error_code     => 'MissingPaymentMethodField',
                    message_params => [$field_def->{display_name}, $method_defs->{$method}{display_name}]}
                    if $field_def->{required} and not(trim($updates->{$id}{$item_field}));

                $existing->{$id}{fields}{$item_field} = $updates->{$id}{$item_field};
            }
        }

        for my $pm_id (keys %$existing) {
            next if $pm_id == $id;

            my $other_pm = $existing->{$pm_id};
            next unless $other_pm->{method} eq $method;

            # Compare settings of PM
            next unless all { lc $other_pm->{fields}{$_} eq lc $existing->{$id}{fields}{$_} } keys $other_pm->{fields}->%*;

            die +{
                error_code     => 'DuplicatePaymentMethod',
                message_params => [$method_defs->{$method} ? $method_defs->{$method}{display_name} : $method]};
        }

        push(@disabled_ids, $id) if exists $updates->{$id}{is_enabled} and (!$updates->{$id}{is_enabled}) and $existing->{$id}{is_enabled};
        push(@updated_ids,  $id);
    }

    $self->_p2p_check_payment_methods_in_use(\@disabled_ids, \@updated_ids);

    $self->db->dbic->run(
        fixup => sub {
            $_->do('SELECT p2p.advertiser_payment_method_update(?)', undef, Encode::encode_utf8($json->encode($updates)));
        });

    return $existing;
}

=head2 _p2p_advertiser_payment_method_create

Creates advertiser payment methods.

Takes the following parameters:

=over 4

=item * existing: hashref of existing methods

=item * updates: hashref of items to create

=back

Returns undef.

=cut

sub _p2p_advertiser_payment_method_create {
    my ($self, $existing, $new) = @_;

    my $method_defs = $self->p2p_payment_methods($self->residence);

    for my $item (@$new) {
        my $method = $item->{method};

        die +{
            error_code     => 'InvalidPaymentMethod',
            message_params => [$method]}
            unless exists $method_defs->{$method};

        for my $item_field (grep { $_ !~ /^(method|is_enabled)$/ } keys %$item) {
            die +{
                error_code     => 'InvalidPaymentMethodField',
                message_params => [$item_field, $method_defs->{$method}{display_name}]}
                unless exists $method_defs->{$method}{fields}{$item_field};
        }

        for my $required_field (grep { $method_defs->{$method}{fields}{$_}{required} } $method_defs->{$method}{fields}->%*) {
            die +{
                error_code     => 'MissingPaymentMethodField',
                message_params => [$method_defs->{$method}{fields}{$required_field}{display_name}, $method_defs->{$method}{display_name}]}
                unless trim($item->{$required_field});
        }

        for my $existing_pm (values %$existing) {
            next unless $existing_pm->{method} eq $method;

            # Compare settings of PM
            next unless all { lc $item->{$_} eq lc($existing_pm->{fields}{$_} // '') } grep { $_ !~ /^(method|is_enabled)$/ } keys %$item;

            die +{
                error_code     => 'DuplicatePaymentMethod',
                message_params => [$method_defs->{$method}{display_name}]};
        }

        # try to detect duplicates within same call, it will be caught by db in any case
        $existing->{rand()} = {
            method => $method,
            fields => {pairgrep { $a !~ /^(method|is_enabled)$/ } %$item}};

        my $created_pm = $self->db->dbic->run(
            fixup => sub {
                my $dbh = shift;
                return $dbh->selectrow_hashref(
                    'SELECT *  FROM p2p.advertiser_payment_method_create_v2(?, ?)',
                    undef,
                    $self->_p2p_advertiser_cached->{id},
                    Encode::encode_utf8($json->encode($item)));
            });

        if ($created_pm->{error_params}->[0]) {
            $created_pm->{error_params}->[0] = $method_defs->{$item->{method}}{display_name};
        }

        $self->_p2p_db_error_handler($created_pm);

    }

    return;
}

=head2 _p2p_check_payment_methods_in_use

Validates that payment methods can be deactivated or deleted.

=over 4

=item * $deleted_ids: payment method ids to be deleted or deactivated

=item * $updated_ids: payment method ids to be updated

=back

Dies or returns undef.

=cut

sub _p2p_check_payment_methods_in_use {
    my ($self, $deleted_ids, $updated_ids) = @_;

    my $in_use = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref('SELECT * FROM p2p.advertiser_payment_method_in_use(?, ?)', {Slice => {}}, $deleted_ids, $updated_ids);
        });

    return unless @$in_use;

    die +{
        error_code     => 'PaymentMethodUsedByAd',
        message_params => [join ', ', $in_use->[0]{advert_ids}->@*],
        }
        unless grep { $_->{order_ids} } @$in_use;

    die +{
        error_code     => 'PaymentMethodUsedByOrder',
        message_params => [join ', ', $in_use->[0]{order_ids}->@*],
        }
        unless grep { $_->{advert_ids} } @$in_use;

    die +{error_code => 'PaymentMethodInUse'};
}

=head2 _p2p_db_error_handler

Maping db p2p error code to rpc error code 

=over 4

=item * $err_code: error code which comes from db

=item * $err_params: parameters which use in error message  

=back

Dies or returns undef.

=cut

sub _p2p_db_error_handler {
    my ($self, $p2p_object) = @_;

    unless ($p2p_object->{error_code}) {
        delete $p2p_object->@{qw(error_params error_code)};
        return;
    }

    die +{
        error_code => P2P_DB_ERR_MAP->{$p2p_object->{error_code}},
        $p2p_object->{error_params} ? (message_params => $p2p_object->{error_params}) : (),
    };
}

=head1 METHODS - Payments

=cut

sub validate_payment {
    my ($self, %args) = @_;

    my $currency           = $args{currency} || die "no currency\n";
    my $amount             = $args{amount}   || die "no amount\n";
    my $action_type        = $amount > 0 ? 'deposit' : 'withdrawal';
    my $payment_type       = $args{payment_type} // '';
    my $rule_engine        = $args{rule_engine};
    my $action_to_validate = $args{action_to_validate} // 'validate_payment';
    my $skip_cashier_check = exists $args{skip_cashier_check} ? $args{skip_cashier_check} : undef;
    # validate expects 'deposit'/'withdraw' so if action_type is 'withdrawal' should be replaced to 'withdraw'
    my $validation = BOM::Platform::Client::CashierValidation::check_availability($self, $action_type);
    if (exists $validation->{error}) {
        die $validation->{error} unless $skip_cashier_check and $validation->{error}{code} eq 'CashierForwardError';
    }

    # todo: extend rule engine to support conditional rules matching multiple values
    my @internal = qw(internal_transfer mt5_transfer dxtrade_transfer ctrader_transfer);
    # internal_transfer is included because it can lead to external withdrawal via crypto
    my @p2p_restricted = qw(internal_transfer doughflow payment_agent_transfer);

    try {
        $rule_engine->verify_action(
            $action_to_validate,
            loginid             => $self->loginid,
            currency            => $currency,
            action              => $action_type,
            amount              => $amount,
            has_deposits        => $self->has_deposits(),
            is_internal         => (any { $payment_type eq $_ } @internal)       ? 1 : 0,
            is_p2p_restricted   => (any { $payment_type eq $_ } @p2p_restricted) ? 1 : 0,
            brand               => request->brand(),
            payment_type        => $payment_type,
            underlying_action   => $payment_type . '_' . $action_type,
            rule_engine_context => {
                client_list     => [$self],
                stop_on_failure => 1,
            })
    } catch ($e) {
        unless (ref $e) {
            $log->errorf('An error occurred while validating payment for client %s: %s', $self->loginid, $e);
            $e = {};
        }

        my $code    = $e->{error_code} // 'PaymentValidationError';
        my $params  = $e->{params}     // [];
        my $message = localize(error_map()->{$code}, @$params);

        unless ($message) {
            $log->infof('No error message mapping found for error code %s: %s', $code, encode_json_text($e));
            $message = localize(error_map()->{PaymentValidationError});
        }

        die +{
            code              => $code,
            params            => $params,
            message_to_client => $message,
        };

    };

    return 1;
}

sub deposit_virtual_funds {
    my ($self, $source) = @_;
    $self->is_virtual || die "not a virtual client\n";

    my $landing_company                 = $self->landing_company;
    my $currency                        = $self->currency                                   // 'USD';
    my $virtual_account_default_balance = $landing_company->virtual_account_default_balance // 10000;

    # default_account not exists when first time init virtual balance
    my $account = $self->set_default_account($currency);

    my $amount = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare('SELECT (pmnt).amount FROM payment.set_balance($1 ,$2 , $3)');
            $sth->execute($account->id, $virtual_account_default_balance, $source);
            return $sth->fetchrow_array;
        });

    unless (defined $amount) {
        $amount = 0;
        stats_inc('bom_user.deposit_virtual.null');
    }

    return ($currency, $amount);
}

#######################################
# PAYMENT HANDLERS
# These Payment handlers are each named as payment_{payment_gateway_code}
# where each {payment_gateway_code} is a subclass of payment and is a 1-to-1 table.

# 'smart_payment' is a one-stop shop which will validate, and choose the appropriate
# payment_gateway, based on the payment_type.
# Validations can be skipped by calling without a rule_engine in cases like
# some legacy tests which assume that the balance already got out of range somehow.
#######################################

sub smart_payment {
    my ($self, %args) = @_;
    my $payment_type         = $args{payment_type} || die "no payment_type";
    my $payment_gateway_code = $args{payment_gateway_code};
    my $rule_engine          = $args{rule_engine};

    $self->validate_payment(%args) if $rule_engine;

    # each 'payment_type' implies a 'payment_gateway'..
    my %gateway_map = (
        affiliate_reward    => 'affiliate_reward',
        external_cashier    => 'doughflow',
        free_gift           => 'free_gift',
        adjustment          => 'legacy_payment',
        adjustment_purchase => 'legacy_payment',
        adjustment_sale     => 'legacy_payment',
        crypto_cashier      => 'legacy_payment',
        test_account        => 'legacy_payment',
        commission_paid     => 'legacy_payment',
        dormant_fee         => 'payment_fee',
        payment_fee         => 'payment_fee',
        bank_money_transfer => 'bank_wire',
        arbitrary_markup    => 'arbitrary_markup',
        cash_transfer       => 'western_union',      # ! need to fix in db first
        voucher             => 'legacy_payment',
        account_transfer    => 'legacy_payment',
        closed_account      => 'legacy_payment',
        dxtrade_adjustment  => 'legacy_payment',
    );

    $payment_gateway_code ||= $gateway_map{$payment_type}
        || die "unsupported payment_type: $payment_type";
    my $payment_handler = "payment_$payment_gateway_code";
    return $self->$payment_handler(%args);
}

sub payment_legacy_payment {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || die "no payment_type";
    my $staff        = $args{staff}        || 'system';

    # these are only here to support some tests which set up historic payments :(
    my $payment_time     = delete $args{payment_time};
    my $transaction_time = delete $args{transaction_time};
    my $source           = delete $args{source};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    die "cannot deal in $currency; clients currency is " . $account->currency_code() if $account->currency_code() ne $currency;

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'legacy_payment',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
            ($payment_time     ? (payment_time     => $payment_time)     : ()),
            ($transaction_time ? (transaction_time => $transaction_time) : ()),
        },
        {});    # <- TODO: legacy_payment table is redundant

    BOM::User::Client::PaymentNotificationQueue->add(
        source        => 'legacy',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );

    return $trx;
}

sub payment_account_transfer {
    my ($fmClient, %args) = @_;

    my $toClient  = delete $args{toClient} || die "no toClient";
    my $currency  = delete $args{currency} || die "no currency";
    my $amount    = delete $args{amount}   || die "no amount";
    my $to_amount = delete $args{to_amount};
    # fees can be zero as well
    my $fees               = delete $args{fees} // die "no fees";
    my $staff              = delete $args{staff}   || 'system';
    my $toStaff            = delete $args{toStaff} || $staff;
    my $fmStaff            = delete $args{fmStaff} || $staff;
    my $remark             = delete $args{remark};
    my $toRemark           = delete $args{toRemark} || $remark || ("Transfer from " . $fmClient->loginid);
    my $fmRemark           = delete $args{fmRemark} || $remark || ("Transfer to " . $toClient->loginid);
    my $source             = delete $args{source};
    my $is_agent_to_client = delete $args{is_agent_to_client} // 0;
    my $txn_details        = delete $args{txn_details};

    # if client has no default account then error out
    my $fmAccount = $fmClient->default_account || die "Client does not have a default account\n";
    my $toAccount = $toClient->default_account || die "toClient does not have a default account\n";

    my $inter_db_transfer;
    $inter_db_transfer = delete $args{inter_db_transfer} if (exists $args{inter_db_transfer});
    my $gateway_code = delete $args{gateway_code} || 'account_transfer';

    my $from_curr = $fmClient->account->currency_code();
    my $to_curr   = $toClient->account->currency_code();

    if ($to_curr ne $from_curr and not defined $to_amount) {
        die "to_amount is required if from_currency and to_currency are different";
    } elsif ($to_curr eq $from_curr) {
        $to_amount = $amount;
    }

    $to_amount = financialrounding('amount', $to_curr, $to_amount);

    my $emit_transfer_event = sub {
        my $args = shift;

        my $event_properties = {
            from_account       => $fmClient->loginid,
            is_from_account_pa => 0 + !!($fmClient->is_pa_and_authenticated),
            to_account         => $toClient->loginid,
            is_to_account_pa   => 0 + !!($toClient->is_pa_and_authenticated),
            from_currency      => $from_curr,
            to_currency        => $to_curr,
            from_amount        => $amount,
            to_amount          => $to_amount,
            source             => $source,
            fees               => $fees,
            gateway_code       => $gateway_code,
            id                 => $args->{id},
            time               => $args->{transaction_time}};

        BOM::Platform::Event::Emitter::emit(
            'transfer_between_accounts',
            {
                loginid    => $fmClient->loginid,
                properties => $event_properties
            });
    };

    my $dbic = $fmClient->db->dbic;
    unless ($inter_db_transfer) {
        # here we rely on ->set_default_account above
        # which makes sure the `write` database is used.
        my $response;

        $txn_details = Encode::encode_utf8($json->encode($txn_details)) if $txn_details;

        my $records = $dbic->run(
            # Error handling for code below is tricky; it returns a string for normal DB  errors,
            # and an array ref for custom DB errors (starts with "BI").
            ping => sub {
                my $sth = $_->prepare(
                    'SELECT (v_from_trans).id, (v_from_trans).transaction_time FROM payment.payment_account_transfer(?,?,?,?, ?,?,?,?, ?,?,?,?, ?,?)'
                );

                $sth->execute(
                    $fmClient->loginid, $toClient->loginid, $currency,           $amount,   $to_amount,
                    $fmStaff,           $toStaff,           $fmRemark,           $toRemark, $source,
                    $fees,              $gateway_code,      $is_agent_to_client, $txn_details,
                );
                return $sth->fetchall_arrayref({});
            });
        if (scalar @{$records}) {
            $response->{transaction_id} = $records->[0]->{id};

            $emit_transfer_event->($records->[0]);
        }

        return $response;
    }

    # TODO: Interclient transfers ("Transfer Between Accounts") lacks
    #       atomicity and is unsafe; we could potentially debit from one
    #       account and fail to credit into the other. We need to
    #       investigate a safe implementation or drop it altogether.
    my ($fmTrx) = $fmAccount->add_payment_transaction({
            amount               => -$amount,
            payment_gateway_code => $gateway_code,
            payment_type_code    => 'internal_transfer',
            status               => 'OK',
            staff_loginid        => $fmStaff,
            remark               => $fmRemark,
            account_id           => $fmAccount->id,
            staff_loginid        => $fmStaff,
            source               => $source,
            transfer_fees        => $fees,
        },
        undef,
        $txn_details
    );

    # Enforce list context for consistency with the above - for some reason
    # we don't do anything with the result though
    (undef) = $toAccount->add_payment_transaction({
            amount               => $to_amount,
            payment_gateway_code => $gateway_code,
            payment_type_code    => 'internal_transfer',
            status               => 'OK',
            staff_loginid        => $toStaff,
            remark               => $toRemark,
            account_id           => $toAccount->id,
            staff_loginid        => $toStaff,
            source               => $source,
        },
        undef,
        $txn_details
    );

    $emit_transfer_event->($fmTrx);

    return {transaction_id => $fmTrx->transaction_id};
}

sub payment_doughflow {
    # Doughflow payments may charge payment fees in cases where
    # clients deposit, did not trade and want their money back.
    # To ensure the atomicity of both the doughflow payment and its
    # corresponding payment fee, a seperate DB function that makes 2
    # calls to add_payment_transaction is used.
    #
    # add_doughflow_payment returns a superset of add_payment_transaction,
    # adding fee_transaction_id and fee_payment_id, so existing code can
    # expect the same outputs as other payment methods in this file.
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'external_cashier';
    my $staff        = $args{staff}        || 'system';
    my $payment_fee  = $args{payment_fee};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    my %doughflow_values = map { $_ => $args{$_} }
        grep { BOM::Database::AutoGenerated::Rose::Doughflow->meta->column($_) }
        keys %args;
    $doughflow_values{transaction_type} ||= $action_type;
    $doughflow_values{trace_id}         ||= 0;
    $doughflow_values{created_by}       ||= $staff;
    $doughflow_values{payment_processor} //= 'unspecified';
    $doughflow_values{payment_method} = $args{payment_method};
    $doughflow_values{payment_type}   = $args{df_payment_type};

    my @bind_params =
        ($account->id, $amount, $payment_type, $staff, $remark, Encode::encode_utf8($json->encode(\%doughflow_values)), $payment_fee,);

    my $trx = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref("SELECT t.* from payment.add_doughflow_payment(?,?,?,?,?,?,?) t", undef, @bind_params);
        });

    BOM::User::Client::PaymentNotificationQueue->add(
        # Note that this was being passed in as a parameter, but always overridden.
        # This is probably a bug: either the parameter was wrong, or we should
        # use that source to define the gateway.
        source        => 'doughflow',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );
    return BOM::User::Client::PaymentTransaction::Doughflow->new(%$trx);
}

sub payment_ctc {
    my ($self, %args) = @_;

    my $currency         = $args{currency}  || die "no currency";
    my $amount           = $args{amount}    || die "no amount";
    my $remark           = $args{remark}    || '';
    my $staff            = $args{staff}     || 'system';
    my $crypto_id        = $args{crypto_id} || die "no crypto_id";
    my $transaction_hash = $args{transaction_hash};

    my $action_type      = $amount > 0 ? 'deposit' : 'withdrawal';
    my $transaction_type = $args{transaction_type} || $action_type;
    my $account          = $self->set_default_account($currency);

    my $ctc_values = {
        crypto_id        => $crypto_id,
        transaction_type => $transaction_type,
        created_by       => $staff,
        transaction_hash => $transaction_hash,
    };

    my $txn_details = {
        $ctc_values->%*,
        address => $args{address},
    };

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'ctc',
            payment_type_code    => 'crypto_cashier',
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
        },
        $ctc_values,
        $txn_details,
    );

    BOM::User::Client::PaymentNotificationQueue->add(
        source        => 'cryptocashier',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );

    return $trx;
}

sub payment_free_gift {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'free_gift';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'free_gift',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        {reason => $remark}    # <- TODO: This is redundant; we are already storing remark in payments table.
    );

    return $trx;
}

sub payment_mt5_transfer {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'mt5_transfer';
    my $staff        = $args{staff}        || 'system';
    my $fees         = $args{fees};
    my $source       = $args{source};
    my $txn_details  = $args{txn_details};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'account_transfer',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
            transfer_fees        => $fees,
        },
        undef,
        $txn_details,
    );

    return $trx;
}

sub payment_payment_fee {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'payment_fee';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'payment_fee',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        {});    # <- TODO: we currently don't charge payment_fee; this table is redundant.

    return $trx;
}

sub payment_bank_wire {
    my ($self, %args) = @_;

    my $currency = delete $args{currency} || die "no currency";
    my $amount   = delete $args{amount}   || die "no amount";
    my $staff    = delete $args{staff}    || 'system';
    my $remark   = delete $args{remark}   || '';
    my $source   = delete $args{source};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    my %bank_wire_values = map { $_ => $args{$_} }
        grep { BOM::Database::AutoGenerated::Rose::BankWire->meta->column($_) }
        keys %args;

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'bank_wire',
            payment_type_code    => 'bank_money_transfer',
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        \%bank_wire_values
    );

    BOM::User::Client::PaymentNotificationQueue->add(
        source        => 'bankwire',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );

    return $trx;
}

sub payment_affiliate_reward {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'affiliate_reward';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account                     = $self->set_default_account($currency);
    my $mlt_affiliate_first_deposit = ($amount > 0 && $self->landing_company->short eq 'malta' && $self->is_first_deposit_pending);

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'affiliate_reward',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        {});    # <- TODO: affiliate_reward table is redundant

    if ($mlt_affiliate_first_deposit) {
        $self->status->setnx('cashier_locked', 'system', 'MLT client received an affiliate reward as first deposit');
    }

    return $trx;
}

sub payment_western_union {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'cash_transfer';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    my %wu_values = map { $_ => $args{$_} }
        grep { BOM::Database::AutoGenerated::Rose::WesternUnion->meta->column($_) }
        keys %args;
    $wu_values{mtcn_number}     ||= '';
    $wu_values{payment_country} ||= '';

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'western_union',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        \%wu_values
    );

    BOM::User::Client::PaymentNotificationQueue->add(
        source        => 'westernunion',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );

    return $trx;
}

sub payment_arbitrary_markup {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'arbitrary_markup';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
        amount               => $amount,
        payment_gateway_code => 'arbitrary_markup',
        payment_type_code    => $payment_type,
        status               => 'OK',
        staff_loginid        => $staff,
        remark               => $remark,
        account_id           => $account->id,
        source               => $source,
    });

    return $trx;
}

=head2 incr_df_payouts_count

For any new DoughFlow payout request increase the
corresponding key by 1.
Takes the following parameters:

=over 4

=item * C<client> - L<BOM::User::Client> object

=back

=cut

sub incr_df_payouts_count {
    my ($self, $trace_id) = @_;

    return unless $trace_id;

    my $redis     = BOM::Config::Redis::redis_replicated_write();
    my $redis_key = DF_PAYOUTS_COUNTER . $self->loginid;

    $redis->multi;
    $redis->sadd($redis_key, $trace_id);
    $redis->expire($redis_key, DF_PAYOUTS_COUNTER_TTL);
    $redis->exec;

    return;
}

=head2 decr_df_payouts_count

For any new DoughFlow payout request update we receive we
decrease the value of the key by 1.
The df responses we can receive are: "inprogress", "rejected", "canceled"
Takes the following parameters:

=over 4

=item * C<client> - L<BOM::User::Client> object

=back

=cut

sub decr_df_payouts_count {
    my ($self, $trace_id) = @_;

    return unless $trace_id;

    my $redis = BOM::Config::Redis::redis_replicated_write();

    $redis->srem(DF_PAYOUTS_COUNTER . $self->loginid, $trace_id);

    return;
}

=head2 get_df_payouts_count

Returns the amount of active DoughFlow payout requests we have
for each client
Takes the following parameters:

=over 4

=item * C<client> - L<BOM::User::Client> object

=back

=cut

sub get_df_payouts_count {
    my $self = shift;

    my $redis = BOM::Config::Redis::redis_replicated_write();

    my $redis_value = $redis->scard(DF_PAYOUTS_COUNTER . $self->loginid) // 0;

    return $redis_value;
}

=head2 copy_status_to_siblings

Copies the given status from the current client to its siblings that haven't set with it before and returns the loginid of the updated clients.

Returns an arrayref containing the loginids of the clients that have been updated.

=cut

sub copy_status_to_siblings {
    my ($self, $status_code, $staff_name, $all_accounts, $reason) = @_;

    $status_code                or die 'No status code provided';
    $staff_name                 or die 'No staff name provided';
    $self->status->$status_code or die $self->loginid . ": Can't copy $status_code to its siblings because it hasn't been set yet";
    $reason = $reason // $self->status->reason($status_code);

    if ($all_accounts) {
        my @to_update;

        foreach my $client ($self->user->clients) {
            next if $client->status->$status_code;
            next
                if $status_code eq 'disabled'
                && $client->get_open_contracts->@*;    ## current use case is in BO, if there is open contract shouldn't  set to disabled.

            if ($status_code eq 'duplicate_account') {
                my $token = BOM::Platform::Token::API->new;
                $token->remove_by_loginid($client->loginid);
            }

            push(@to_update, $client->loginid) if $client->status->setnx($status_code, $staff_name, $reason);
        }
        return [@to_update];
    } else {
        return $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_arrayref('SELECT betonmarkets.copy_client_status_to_siblings(?,?,?)', undef, $self->loginid, $status_code, $staff_name);
            })->[0] // [];
    }
}

=head2 clear_status_and_sync_to_siblings

Removes the given status from the current client and from its siblings, and returns the loginid of the updated clients.

Returns an array containing the loginids of the clients that have been updated.

=cut

sub clear_status_and_sync_to_siblings {
    my ($self, $status_code, $all_accounts, $allow_reactivate) = @_;

    $status_code or die 'No status code provided';

    die 'Status codes disabled and duplicate_account cannot be removed by this method.'
        if $status_code =~ qr/^disabled|duplicate_account$/ && !$allow_reactivate;

    if ($all_accounts) {

        my @to_update;
        foreach ($self->user->clients(include_disabled => 1)) {
            my $clear_function = "clear_$status_code";
            push(@to_update, $_->loginid) if $_->status->$clear_function;
        }
        return [@to_update];
    } else {
        return $self->db->dbic->run(
            ping => sub {
                $_->selectrow_arrayref('SELECT betonmarkets.clear_client_status_sync_all(?,?)', undef, $self->loginid, $status_code);
            })->[0] // [];
    }
}

=head2 get_sibling_loginids_without_status

Returns the login id of all landing company siblings of the current client that haven't set with the given status code

=cut

sub get_sibling_loginids_without_status {
    my ($self, $status_code) = @_;

    $status_code or die 'No status code provided';

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_arrayref('SELECT betonmarkets.get_sibling_loginids_without_client_status(?,?)', undef, $self->loginid, $status_code);
        })->[0] // [];
}

=head2 siblings

Returns an array containing all the landing company siblings of the current client. Does NOT include the current one.

=cut

sub siblings {
    my $self     = shift;
    my @siblings = grep { $_->loginid ne $self->loginid } $self->user->clients_for_landing_company($self->landing_company->short);
    return \@siblings;
}

=head2 has_siblings

Returns true if the current client landing company siblings, false otherwise.

=cut

sub has_siblings {
    my $self = shift;

    return scalar(@{$self->siblings()}) > 0;
}

=head2 update_status_after_auth_fa

Checks status of the client after authentication, age verification or financial assessment, trying to remove certain account locks (status) automatically if possible.
It's called with following params:

=over 4

=item * C<$reason> - a string value used for setting reason of status codes (optional)

=back

=cut

sub update_status_after_auth_fa {
    my ($self, $msg) = @_;

    return unless $self->user;

    for my $sibling ($self->user->clients) {
        my $sibling_status = $sibling->status;
        if ($sibling->is_financial_assessment_complete) {

            $sibling_status->clear_financial_assessment_required;

            $sibling->status->clear_withdrawal_locked
                if ($sibling->status->reason('withdrawal_locked') // '') =~ 'FA needs to be completed';

            if ($sibling->fully_authenticated && !$sibling->documents->expired) {
                $sibling_status->clear_withdrawal_locked
                    if (($sibling_status->reason('withdrawal_locked') // '') =~
                    /(Pending authentication or FA|Client Deposited - Pending Authentication)/);

                $sibling_status->clear_allow_document_upload
                    if ($sibling_status->reason('allow_document_upload') // '') =~ /BECOME_HIGH_RISK|Pending authentication or FA/;

                $sibling_status->clear_unwelcome
                    if ($sibling_status->reason('unwelcome') // '') =~ /Client Deposited - Pending Authentication/;
            }
        }

        if ($self->get_poi_status(undef, 0) eq 'verified') {
            for my $code (qw/cashier_locked unwelcome/) {
                my $status   = $sibling_status->$code;
                my $clear_fn = "clear_$code";
                $sibling_status->$clear_fn if $status and $status->{reason} =~ FALSE_PROFILE_INFO_REGEX;
            }
        }

        if ($sibling->is_financial_assessment_complete) {
            # Clear unwelcome status for clients without financial assessment and have breached
            # social responsibility thresholds
            $sibling_status->clear_unwelcome
                if ref $sibling_status->unwelcome eq "HASH"
                && $sibling_status->unwelcome->{reason} eq SR_UNWELCOME_REASON;
        }

        if ($sibling->get_poi_status() eq 'verified') {
            # auto-unlock MLT clients locked after first deposit
            $sibling_status->clear_unwelcome
                if ($sibling_status->reason('unwelcome') // '') =~ qr/Age verification is needed after first deposit/;
            # clear withdrawal_locked set by check_name_changes_after_first_deposit event
            $sibling_status->clear_withdrawal_locked
                if ($sibling_status->reason('withdrawal_locked') // '') eq 'Excessive name changes after first deposit - pending POI';

            # Potential fraud limitations should be lifted after proof identity.
            $sibling_status->clear_potential_fraud;
        }
    }

    # gb residents cannot trade synthetics on demo account while not age verified
    my $config = request()->brand->countries_instance->countries_list->{$self->residence};
    if ($config->{require_age_verified_for_synthetic} and $self->status->age_verification and $self->user->bom_virtual_loginid) {
        my $vr_acc = BOM::User::Client->new({loginid => $self->user->bom_virtual_loginid, context => $self->{context}});
        $vr_acc->status->setnx('age_verification', 'system', $msg // '');
    }

    if (my $p2p_advertiser = $self->_p2p_advertiser_cached) {
        my $limit = BOM::Config::payment_limits()->{withdrawal_limits}{$self->landing_company->short};
        $self->db->dbic->run(
            fixup => sub {
                $_->do('SELECT p2p.populate_withdrawal_limits(?, ?, NULL)', undef, $limit->{lifetime_limit}, $p2p_advertiser->{id});
            }) if $limit;
    }
}

=head2 locked_for_false_profile_info

Checks if the client's account is locked for providing false or corporate profile information.
Such clients have B<cashier_locked> or B<unwelcome> status with predefined reasons.
Returns 1 if the account was locked for providing false information otherwise undef.
=cut

sub locked_for_false_profile_info {
    my $self = shift;

    return undef if $self->is_virtual;

    for my $code (qw/cashier_locked unwelcome/) {
        my $reason = $self->status->reason($code) // '';

        return 1 if $reason =~ FALSE_PROFILE_INFO_REGEX;
    }

    return;
}

=head2 anonymize_client

Anonymizes the client

=head2 Usage Caution

**NOTE:** Be careful to use this function it clears client data from all databases and it is irreversible action.

=cut

sub anonymize_client {
    my $self = shift;

    $self->db->dbic->run(
        fixup => sub {
            $_->do('SELECT * FROM betonmarkets.client_anonymization(?)', undef, $self->loginid);
        });
}

=head2 remove_client_authentication_docs_from_S3

Removes the client authentication documents from s3

=cut

sub remove_client_authentication_docs_from_S3 {
    my $self = shift;

    my $docs = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(<<'SQL', undef, $self->loginid);
SELECT file_name
FROM betonmarkets.client_authentication_document
WHERE client_loginid = ?
SQL
        });
    if ($docs) {
        my $s3_client = BOM::Platform::S3Client->new(BOM::Config::s3()->{document_auth});
        foreach my $doc (@$docs) {
            my $filename = $doc->[0];
            $s3_client->delete($filename);
        }
    }
}

=head2 anonymize_associated_user_return_list_of_siblings

Anonymize the associated user for this client and returns a list of siblings loginids

=head2 Usage Caution

**NOTE:** Be careful to use this function, it clears the client associated user data from all databases and it is irreversible action.

=cut

sub anonymize_associated_user_return_list_of_siblings {
    my $self = shift;

    # Get list of loginids for a userid
    return BOM::Database::UserDB::rose_db()->dbic->run(
        fixup => sub {
            $_->selectall_arrayref("SELECT * FROM users.user_anonymization(?)", {Slice => {}}, $self->loginid);
        })->@*;
}

=head2 get_all_comments

Returns a list of comments for a given client, including all siblings (from all brokers, including virtuals).

=cut

sub get_all_comments {
    my ($self, $section) = @_;

    my $brokers  = {};
    my $comments = [];

    for my $loginid ($self->user->loginids) {
        next if $loginid =~ /^(DX|MT|EZ|CT)/;

        my $client = BOM::User::Client->new({loginid => $loginid, context => $self->{context}});

        next if $brokers->{$client->broker_code};

        $brokers->{$client->broker_code} = $client;
    }

    for my $client (values $brokers->%*) {
        $client->set_db('replica');

        push $comments->@*, $client->get_comments($section)->@*;
    }

    return [sort { Date::Utility->new($b->{creation_time})->epoch <=> Date::Utility->new($a->{creation_time})->epoch } $comments->@*];
}

=head2 get_comments

Returns the list of comments of the current client and its same-broker siblings.

=cut

sub get_comments {
    my ($self, $section) = @_;

    return $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare(q{SELECT * FROM betonmarkets.get_client_comments(?, ?)});
            $sth->execute($self->loginid, $section);
            return $sth->fetchall_arrayref({});
        }) // [];
}

=head2 add_comment

Add a new MLRO comment for a given client

=cut

sub add_comment {
    my ($self, %args) = @_;

    my $old_db = $self->get_db;
    $self->set_db('write') if 'write' ne $old_db;

    die "CommentRequired\n" unless $args{comment};
    die "AuthorRequired\n"  unless $args{author};

    $args{section}       //= '';
    $args{creation_time} //= Date::Utility->new->datetime;

    my $sql    = q{SELECT * FROM betonmarkets.add_client_comment(?,?,?,?,?)};
    my $result = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute($self->loginid, @args{qw(comment author section creation_time)});
            return $sth->fetch->[0];
        });

    $self->set_db($old_db) if 'write' ne $old_db;

    return $result;
}

=head2 edit_comment

Adjust an existing MLRO comment with a specified ID

=cut

sub update_comment {
    my ($self, %args) = @_;

    my $old_db = $self->get_db;
    $self->set_db('write') if 'write' ne $old_db;

    die "CommentRequired\n"   unless $args{comment};
    die "AuthorRequired\n"    unless $args{author};
    die "CommentIDRequired\n" unless $args{id};
    die "ChecksumRequired\n"  unless $args{checksum};

    my $sql    = q{SELECT * FROM betonmarkets.update_client_comment(?,?,?,?)};
    my $result = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute(@args{qw(id comment author checksum)});
            return $sth->fetch->[0];
        });
    $self->set_db($old_db) if 'write' ne $old_db;

    return $result;
}

=head2 delete_comment

Remove a MLRO comment by ID

=cut

sub delete_comment {
    my ($self, $id, $checksum) = @_;

    my $old_db = $self->get_db;
    $self->set_db('write') if 'write' ne $old_db;

    die "CommentIDRequired\n" unless $id;
    die "ChecksumRequired\n"  unless $checksum;

    my $sql    = q{SELECT * FROM betonmarkets.delete_client_comment(?, ?)};
    my $result = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute($id, $checksum);
            return $sth->fetch->[0];
        });
    $self->set_db($old_db) if 'write' ne $old_db;

    return $result;
}

=head2 lifetime_internal_withdrawals

Gets the total amount of internal transfer (withdrawal)
The amount is in the client's currency

=cut

sub lifetime_internal_withdrawals {
    my $self = shift;

    my $lifetime_transfer_amount = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare("SELECT * FROM payment.get_internal_transfer_withdrawal_amount(?)");
            $sth->execute($self->loginid);
            return $sth->fetchrow_array;
        });

    return $lifetime_transfer_amount // 0;
}

=head2 get_account_details

Prepares a formatted hash for $self

Takes the following arguments as named parameters

=over 4

=item * C<client> - L<BOM::User::Client> object for which formatted details are required

=back

Returns a Hashref of details of client.

=cut

sub get_account_details {
    my ($self) = @_;

    my $exclude_until = $self->get_self_exclusion_until_date;
    my $created_at    = $self->date_joined ? Date::Utility->new($self->date_joined)->epoch : undef;

    my $acc          = $self->account;
    my $account_type = $self->get_account_type;

    return {
        account_type         => $account_type->name,
        account_category     => $account_type->category->name,
        loginid              => $self->loginid,
        currency             => $acc ? $acc->currency_code : '',
        landing_company_name => $self->landing_company->short,
        is_disabled          => $self->status->disabled ? 1 : 0,
        is_virtual           => $self->is_virtual       ? 1 : 0,
        created_at           => $created_at,
        $exclude_until ? (excluded_until => Date::Utility->new($exclude_until)->epoch) : (),
    };
}

=head2 get_pow_status

Resolves the Proof of Income/wealth status.
This C<status> is inferred from client C<documents>.

It takes the following params:

=over 4

=item * C<documents> hashref containing the client documents by type (optional)

=back

Returns,
    string for the current POW(proof of wealth/income) status, it can be: none, pending, rejected, verified.

=cut

sub get_pow_status {
    my ($self, $documents) = @_;
    # Note optional arguments will be resolved if not provided
    $documents //= $self->documents->uploaded();

    my ($is_pending, $is_verified, $is_rejected, $is_uploaded) =
        @{$documents->{proof_of_income}}{qw/is_pending is_verified is_rejected is_uploaded/};

    # order matters

    return 'locked' if $is_pending && $is_pending >= 3;

    return 'pending' if $is_pending || $is_uploaded;

    return 'verified' if $is_verified;

    # limit the allowed documents uploaded to be rejected with a max of 3
    return 'locked' if $is_rejected && $is_rejected >= 3;

    return 'rejected' if $is_rejected;

    return 'none';
}

=head2 get_poa_status

Resolves the POA status.
This C<status> is inferred from client C<documents>.

It takes the following params:

=over 4

=item * C<documents> hashref containing the client documents by type (optional)

=back

Returns,
    string for the current POA status, it can be: none, expired, pending, rejected, verified.

=cut

sub get_poa_status {
    my ($self, $documents) = @_;
    # Note optional arguments will be resolved if not provided
    $documents //= $self->documents->uploaded();

    my ($is_poa_pending, $is_rejected, $is_outdated) =
        @{$documents->{proof_of_address}}{qw/is_pending is_rejected is_outdated/};

    return 'pending' if $is_poa_pending;

    my $risk = $self->aml_risk_classification // '';

    if ($self->fully_authenticated({ignore_idv => $risk eq 'high'})) {
        return 'expired' if $is_outdated;

        return 'verified';
    }

    return 'rejected' if $is_rejected;

    # note: POA documents do not expire, but they can get outdated by compliance rules
    # for our state machine this is "expired" to avoid adding extra statuses

    return 'expired' if $is_outdated;

    return 'none';
}

=head2 get_poi_status

Resolves the POI status.

Infers C<status> from onfido/idv/manual latest check.

Arguments:

=over 4

=item landing_company - an optional argument by default current client's landing company is used. Different LCs may have different POI rules. 

=back

Returns,
    string for the current POI status, it can be: none, expired, pending, rejected, suspected, verified.

=cut

sub get_poi_status {
    my ($self, $args) = @_;

    my ($poi_by) = $self->latest_poi_by($args);

    $poi_by //= 'none';

    my $status = 'none';

    $status = $self->get_manual_poi_status() if $poi_by eq 'manual';

    $status = $self->get_onfido_status() if $poi_by eq 'onfido';

    $status = $self->get_idv_status() if $poi_by eq 'idv';

    return 'pending' if $status eq 'pending';

    my $ignore_age_verification = $self->ignore_age_verification($args);
    if (!$ignore_age_verification && ($self->fully_authenticated || $self->status->age_verification)) {
        my $expired;

        $expired = $self->documents->expired(undef) if $poi_by eq 'manual';

        $expired = $self->documents->expired(undef, 'onfido') if $poi_by eq 'onfido';

        return $status if $expired;

        return 'verified';
    }

    return 'suspected' if $status eq 'suspected';

    return 'rejected' if $self->status->poi_name_mismatch || $self->status->poi_dob_mismatch;

    return 'rejected' if $status eq 'rejected';

    return 'expired' if $status eq 'expired';

    return 'verified' if $self->get_manual_poi_status eq 'verified';

    return 'none';
}

=head2 get_poi_status_jurisdiction

Resolves the POI status.
Infers C<status> from onfido/idv/manual latest check, or returns C<verified> if client already has poi.
support query by jurisdiction type.
Returns,
    string for the current POI status, it can be: none, expired, pending, rejected, suspected, verified.
=cut

sub get_poi_status_jurisdiction {
    my ($self, $args) = @_;

    # invalidate any status if the ignore conditions are met
    # for this LC
    return 'none' if $self->ignore_age_verification($args);

    my $manual = $self->get_manual_poi_status();
    my $idv    = $self->get_idv_status();
    my $onfido = $self->get_onfido_status();
    my %poi    = (
        manual => $manual,
        idv    => $idv,
        onfido => $onfido
    );

    my $lc = LandingCompany::Registry->by_name($args->{landing_company} // '') || return 'none';

    my %status = map { $poi{$_} => 1 } $lc->allowed_poi_providers->@*;

    return 'verified' if $status{verified};

    return 'pending' if $status{pending};

    return 'suspected' if $status{suspected};

    return 'rejected' if $self->status->poi_name_mismatch || $self->status->poi_dob_mismatch;

    return 'rejected' if $status{rejected};

    return 'expired' if $status{expired};

    return 'none';
}

=head2 get_idv_status

Gets the current IDV status of the client.

It takes the following parameters:

=over 4

=item * C<$document> - A hashref of document info retrived from database (optional)

=back

Returns,
    string for the current IDV status, it can be: none, expired, pending, rejected, verified.

Note:
    poa_authenticated_with_idv will override a 'none' status.

=cut

sub get_idv_status {
    my ($self, $document) = @_;
    my $idv_status = BOM::User::IdentityVerification->new(user_id => $self->binary_user_id)->status($document);

    return 'verified' if $idv_status eq 'none' && $self->poa_authenticated_with_idv;
    return $idv_status;
}

=head2 get_onfido_status

Gets the current Onfido status of the client. This is an Onfido-only analysis, may vary from
the actual POI status of the client.
It takes the following parameters;

=over 4

=item * C<$documents> hashref containing the client documents by type (optional)

=back

Returns,
    string for the current Onfido status, it can be: none, expired, pending, rejected, suspected, verified.

=cut

sub get_onfido_status {
    my ($self) = @_;

    return BOM::User::Onfido::maybe_pending($self) if BOM::User::Onfido::pending_request($self->binary_user_id);

    my $onfido = BOM::User::Onfido::get_latest_check($self);

    my ($check, $report_document_status, $report_document_sub_result) =
        @{$onfido}{qw/user_check report_document_status report_document_sub_result/};
    my $check_result = $check->{result} // '';
    $report_document_status     //= '';
    $report_document_sub_result //= '';

    return BOM::User::Onfido::maybe_pending($self) if any { $_ eq $report_document_status } qw/in_progress awaiting_applicant/;

    # Note that `expired` would be indistinguishable from the manual `expired` status
    # but we will do some cheeky stuff to get a more accurate result. Basically,
    # we are gonna flag `expired` if the documents are expired + we got a clear Onfido result
    # (it would yield verified otherwise). Far from perfect but better than null.

    if ($check_result eq 'clear') {
        my $is_poi_expired = $self->documents->uploaded->{onfido}->{is_expired};

        return 'expired' if $is_poi_expired;

        # it must've been validated by Onfido, otherwise it was rejected by some reason (maybe mismatch)
        my $reason = $self->status->reason('age_verification');
        return 'verified' if $reason && $reason =~ /onfido/i;

        return 'rejected';
    }

    return 'suspected' if $report_document_sub_result eq 'suspected';

    return 'rejected' if any { $_ eq $report_document_sub_result } qw/rejected caution/;

    return 'rejected' if $check_result eq 'consider';

    my $submissions_left = BOM::User::Onfido::submissions_left($self);

    my $country = $self->residence;

    return 'rejected' if $submissions_left < BOM::User::Onfido::limit_per_user($country);

    return 'none';
}

=head2 get_manual_poi_status

Gets the current manual POI status of the client. This would only apply to Onfido unsupported
countries, although due to the monolithic implementation we may share some status across both.
This may vary from the actual client POI status.

Returns,
    string for the current manual POI status, it can be: none, expired, pending, verified.

=cut

sub get_manual_poi_status {
    my ($self) = @_;

    my $poi_documents  = $self->documents->uploaded->{proof_of_identity};
    my $is_poi_expired = $poi_documents->{is_expired};

    return 'none' if scalar keys $poi_documents->{documents}->%* == 0 && !$self->status->age_verification;

    return 'pending' if $self->documents->pending;

    return 'expired' if $is_poi_expired;

    if ($self->status->age_verification) {
        if (!$self->ignore_age_verification) {
            my $staff = $self->status->age_verification->{staff_name} // '';

            # if set by staff at BO
            return 'verified' if $staff ne 'system';

            # return verified if fully authenticated
            return 'verified' if $self->fully_authenticated({ignore_idv => 1});
        }
    }

    # Return pending when the documents are verified, but the age is not verified yet.
    return 'pending' if $self->documents->verified;

    return 'rejected' if scalar keys $poi_documents->{documents}->%*;    # if docs are not pending, not age verified, what else could it be?

    return 'none';
}

=head2 needs_poa_verification

Determines if POA documents are needed.

It takes the following params:

=over 4

=item * C<documents> hashref containing the client documents by type (optional)

=item * C<status> the current poa status (optional)

=item * C<is_required_auth> the account verification status (optional)

=back

Returns,
    a boolean that indicates whether a POA is needed

=cut

sub needs_poa_verification {
    my ($self, $documents, $status, $is_required_auth, $risk_aml, $risk_sr) = @_;
    # Note optional arguments will be resolved if not provided
    $documents //= $self->documents->uploaded();
    $status    //= $self->get_poa_status($documents);

    # From POA status
    return 1 if any { $_ eq $status } qw/expired rejected/;

    # Resubmissions
    return 1 if $self->status->allow_poa_resubmission;

    return 0 if $status eq 'pending';

    # Not fully authenticated rules
    unless ($self->fully_authenticated) {
        my $poa_documents = $documents->{proof_of_address}->{documents};
        $is_required_auth //= $self->is_verification_required(
            check_authentication_status => 1,
            risk_aml                    => $risk_aml,
            risk_sr                     => $risk_sr
        );
        return 1 if $is_required_auth and not $poa_documents;
    }

    return 0;
}

=head2 needs_poi_verification

Determines if POI documents are needed.

It takes the following params:

=over 4

=item * C<documents> hashref containing the client documents by type (optional)

=item * C<status> the current poi status (optional)

=item * C<is_required_auth> the account verification status (optional)

=back

Returns,
    a boolean that indicates whether a POI is needed

=cut

sub needs_poi_verification {
    my ($self, $documents, $status, $is_required_auth, $risk_aml, $risk_sr) = @_;
    # Note optional arguments will be resolved if not provided
    $documents //= $self->documents->uploaded();
    $status    //= $self->get_poi_status($documents);

    # Resubmissions
    return 1 if $self->status->allow_poi_resubmission;

    # From POI status
    return 1 if $status eq 'rejected';
    return 1 if $status eq 'expired';
    return 0 if $status eq 'pending';

    # Not age verified and not fully authenticated (de morgan law)
    unless ($self->status->age_verification or $self->fully_authenticated) {
        # If shared payment method, the POI is required
        return 1 if $self->status->shared_payment_method;
        # If detected as potential fraud, POI is mandatory
        return 1 if $self->status->potential_fraud;
        # POI is required for payment agents
        return 1 if $self->get_payment_agent;
        #  Account locked  for  false profile, will be unlocked only by POI
        return 1 if $self->locked_for_false_profile_info;

        $is_required_auth //=
            # requires both poi and poa needed
            $self->is_verification_required(
            check_authentication_status => 1,
            risk_aml                    => $risk_aml,
            risk_sr                     => $risk_sr
            );

        return 1 if $is_required_auth && $status eq 'none';

        # Try to infer state from onfido results
        # TODO: these might be redundant now

        return 1 if any { $_ eq $self->get_onfido_status() } qw/rejected suspected expired/;
    }

    # TODO: remove when latest poi by supports manual
    return 0 if $self->get_manual_poi_status eq 'verified';

    # we must ask for POI docs if the age verification status is meant to be ignored
    return 1 if $self->ignore_age_verification;

    return 0;
}

=head2 needs_pow_verification

Determines if POW documents are needed.

It takes the following params:

=over 4

=item * C<documents> hashref containing the client documents by type (optional)

=back

Returns,
    a boolean that indicates whether a POW is needed

=cut

sub needs_pow_verification {
    my ($self, $documents) = @_;

    $documents //= $self->documents->uploaded();
    my $user = $self->user;

    return 1 if $self->status->allow_poinc_resubmission;

    return 1 if $user->get_edd_status->{status} && (grep { $user->get_edd_status->{status} eq $_ } qw{pending in_progress rejected locked contacted});

    return 0;
}

=head2 p2p_balance

Returns the balance available for p2p

=cut

sub p2p_balance {
    my ($self) = @_;

    my $account_balance = $self->account->balance;
    my $excluded_amount = $self->p2p_exclusion_amount;
    my $advertiser      = $self->_p2p_advertiser_cached    // {};
    my $extra_sell      = $advertiser->{extra_sell_amount} // 0;
    my $p2p_balance     = min($account_balance, max(0, $account_balance - $excluded_amount) + $extra_sell);

    return financialrounding('amount', $self->currency, $p2p_balance);
}

=head2 p2p_exclusion_amount

Returns the amount that must be excluded from a P2P advertiser's account balance.

=cut

sub p2p_exclusion_amount {
    my ($self) = @_;

    my ($reversible, $limit, $lookback);
    my @restricted_countries = BOM::Config::Runtime->instance->app_config->payments->p2p->fiat_deposit_restricted_countries->@*;

    if (any { $self->residence eq $_ } @restricted_countries) {
        $limit      = 0;
        $lookback   = BOM::Config::Runtime->instance->app_config->payments->p2p->fiat_deposit_restricted_lookback;
        $reversible = 0;
    } else {
        $limit      = BOM::Config::Runtime->instance->app_config->payments->reversible_balance_limits->p2p / 100;
        $lookback   = BOM::Config::Runtime->instance->app_config->payments->reversible_deposits_lookback;
        $reversible = 1;
    }

    my ($amount) = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_array('SELECT * FROM p2p.balance_exclusion_amount(?, ?, ?, ?)', undef, $self->account->id, $limit, $lookback, $reversible);
        });

    return $amount;
}

=head2 p2p_withdrawable_balance

Returns the amount that can be withdrawn via cashier or transferred to sibling accounts.

=cut

sub p2p_withdrawable_balance {
    my ($self) = @_;

    my $balance = $self->account->balance;
    my $config  = BOM::Config::Runtime->instance->app_config->payments;
    my $limit   = $config->p2p_withdrawal_limit;

    return $balance if $limit >= 100;                                                      # setting is a percentage
    return $balance unless BOM::Config::P2P::available_countries()->{$self->residence};    # banned countries can withdraw p2p deposits

    my $lookback = $config->p2p_deposits_lookback;

    my ($p2p_net) = $self->db->dbic->run(
        fixup => sub {
            return $_->selectrow_array('SELECT payment.aggregate_payments_by_type(?, ?, ?)', undef, $self->account->id, 'p2p', $lookback);
        }) // 0;

    return $balance if $p2p_net <= 0;
    $p2p_net = $p2p_net * (1 - ($limit / 100));
    my $p2p_excluded = $self->p2p_exclusion_amount;

    # this calcalution was tested on over 10k clients so even though it may look strange, we know it works
    return min($balance, $p2p_excluded + max(0, $balance - $p2p_excluded - $p2p_net));
}

=head2 balance_for_cashier

Returns the irreversible balance available for the specified cashier.

=cut

=over 4

=item * C<cashier> Cashier name, must be a value of a key within runtime config payments.reversible_balance_limits

=back

Returns current irreversible balance for a cashier as a float.

=cut

sub balance_for_cashier {
    my ($self, $cashier) = @_;

    my $global_limit = BOM::Config::Runtime->instance->app_config->payments->reversible_balance_limits->$cashier;
    my $lookback     = BOM::Config::Runtime->instance->app_config->payments->reversible_deposits_lookback;

    my ($amount) = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_array('SELECT * FROM payment.get_available_balance_by_cashier(?,?,?,?)',
                undef, $self->loginid, $cashier, $global_limit / 100, $lookback);
        });

    return $amount;
}

=head2 balance_for_doughflow

Returns withdrawable amount for doughflow. Used for paymentapi /account endpoint.

=cut

sub balance_for_doughflow {
    my ($self) = @_;

    my $pa = $self->get_payment_agent;
    if ($pa && ($pa->status // '') eq 'authorized' && !$pa->service_is_allowed('cashier_withdraw')) {
        return $pa->cashier_withdrawable_balance()->{available};
    }

    return $self->account->balance;
}

=head2 propagate_status

This sub performs an C<BOM::User::Status::upsert> of the desired status on
each real account the client owns.

Note we cannot C<BOM::User::Client::copy_status_to_siblings> as it does not
perform cross LC operations (e.g. MLT -> MF).

=over 4

=item * status_code

=item * staff_name (optional)

=item * reason (optional)

=back

Returns undef

=cut

sub propagate_status {
    my ($self, $status_code, $staff_name, $reason) = @_;

    my @clients = grep { !$_->is_virtual } $self->user->clients;
    $_->status->upsert($status_code, $staff_name, $reason) foreach @clients;

    return undef;
}

=head2 propagate_clear_status

This sub performs an C<BOM::User::Status::_clear> of the desired status on
each real account the client owns.

Note we cannot C<BOM::User::Client::clear_status_and_sync_to_siblings>
as it does not perform cross LC operations (e.g. MLT -> MF).

=over 4

=item * status_code

=back

Returns undef

=cut

sub propagate_clear_status {
    my ($self, $status_code) = @_;

    my @clients = grep { !$_->is_virtual } $self->user->clients(
        include_disabled   => 1,
        include_duplicated => 1,
    );

    foreach my $cl (@clients) {
        my $method = $cl->status->can('clear_' . $status_code);
        croak 'Unkown status code ' . ($status_code // 'undef') unless $method;
        $cl->status->$method();
    }

    return undef;
}

=head2 is_wallet

Returns whether this client instance is a wallet.

=cut

sub is_wallet {
    return 0;
}

=head2 is_legacy

Returns whether this client instance is binary (legacy type).

=cut

sub is_legacy {
    return shift->get_account_type->name eq BOM::Config::AccountType::LEGACY_TYPE ? 1 : 0;
}

=head2 is_affiliate

Returns whether this client instance is an affiliate.

=cut

sub is_affiliate {
    return 0;
}

=head2 get_account_type

Gets the account type as a BOM::Config::AccountType object.

=cut

sub get_account_type {
    my $self = shift;

    $self->{_account_type_obj} //=
        BOM::Config::AccountType::Registry->account_type_by_name($self->account_type // BOM::Config::AccountType::LEGACY_TYPE);

    return $self->{_account_type_obj};
}

=head2 can_trade

Returns whether this client instance can perform trading.

=cut

sub can_trade { 1 }

=head2 get_class_by_broker_code

Retruns the client class name by broker code. It gets the following args:

=over 4

=item * C<broker_code> - a broker code

=back


=cut

sub get_class_by_broker_code {
    my (undef, $broker_code) = @_;

    die 'Broker code is missing' unless $broker_code;

    return 'BOM::User::Affiliate'
        if BOM::Config::AccountType::Registry->find_broker_code(
        broker       => $broker_code,
        category     => 'wallet',
        account_type => 'affiliate'
        );

    return 'BOM::User::Wallet' if BOM::Config::AccountType::Registry->find_broker_code(
        broker   => $broker_code,
        category => 'wallet'
    );

    return 'BOM::User::Client';
}

=head2 get_client_instance

Returns a client or wallet instance from a loginid.

=over 4

=item * C<loginid> - string

=item * C<db_operation> - string

=back

=cut

sub get_client_instance {
    my ($self, $loginid, $db_operation, $context) = @_;

    my ($broker_code) = $loginid =~ /(^[a-zA-Z]+)/;
    die "Invalid loginid $loginid" unless $broker_code;

    my $class = BOM::User::Client->get_class_by_broker_code($broker_code);

    return $class->new({
        loginid      => $loginid,
        db_operation => $db_operation // 'replica',
        context      => $context,
    });
}

=head2 start_document_upload

Starts a document upload. This sub is a wrapper for `betonmarkets.start_document_upload`
database function.

Allocates a row into the table with status `uploading`.

It takes a hashref containing the following parameters:

=over 4

=item * C<document_type> Required. The type of the document, this is our internal classification of documents such as `passport`, `bank_statement` and many others (Required otherwise constraint violation).

=item * C<document_format> Required. The type of the file (should've been named file_format) such as `png`, `jpg` and others.

=item * C<expiration_date> The expiration date of the given document if applies.

=item * C<document_id> Required. The arbitrary id of the document, nothing to do with primary keys.

=item * C<checksum> Required. Checksum of the file being uploaded

=item * C<comments> Comments attached to the file

=item * C<page_type> Required. The page type of the document such as `front` or `back`.

=item * C<issue_date> The issuance date of the given document if applies.

=item * C<lifetime_valid> boolean that indicates whether the document is lifetime valid.

=item * C<origin> enum for the origin of the document: bo, client, onfido or legacy.

=item * C<issuing_country> 2 letter country code.

=back

Returns a hashref containing:

=over 4

=item * C<file_id> the ID of the new document (unlike the parameter mentioned before, this is a primary key).

=item * C<file_name> the computed name of the document.

=back

=cut

sub start_document_upload {
    my ($self, $params) = @_;
    my (
        $document_type, $document_format, $expiration_date, $document_id, $checksum, $comments,
        $page_type,     $issue_date,      $lifetime_valid,  $origin,      $issuing_country
        )
        = @$params{
        qw/document_type document_format expiration_date document_id checksum comments page_type issue_date lifetime_valid origin issuing_country/};

    return $self->db->dbic->run(
        ping => sub {
            $_->selectrow_hashref(
                'SELECT * FROM betonmarkets.start_document_upload(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                undef,
                $self->loginid,
                $document_type,
                $document_format,
                $expiration_date,
                $document_id,
                $checksum,
                $comments // '',    # This field has non null constraint however feels like it should be optional anyway
                $page_type,
                $issue_date,
                $lifetime_valid ? 1 : 0,
                $origin // 'legacy',
                $issuing_country,
            );
        });
}

=head2 finish_document_upload

Finishes a document upload. This sub is a wrapper for `betonmarkets.finish_document_upload`
database function.

Updates the document status to `uploaded`.

It takes the following parameters:

=over 4

=item C<file_id> the id of the document being finished (yeah, tricky name indeed).

=item C<status> the status of the document after finishing (uploaded by default).

=back

Returns the same C<file_id> given when no exception is seen.

=cut

sub finish_document_upload {
    my ($self, $file_id, $status) = @_;
    $status //= 'uploaded';

    my $verified_date;
    $verified_date = Date::Utility->new->date_yyyymmdd if $status eq 'verified';

    return $self->db->dbic->run(
        ping => sub {
            $_->selectrow_array(
                'SELECT * FROM betonmarkets.finish_document_upload(?, ?::status_type, ?::date)',
                undef, $file_id, $status // 'uploaded',
                $verified_date
            );
        });
}

=head2 payment_accounts_limit

Returns the maximum allowed payment accounts for this client.

=cut

sub payment_accounts_limit {
    my ($self, $payment_method_limit) = @_;
    my $custom_limit =
        $json->decode(BOM::Config::Runtime->instance->app_config->payments->custom_payment_accounts_limit_per_user)->{$self->user->{id}};
    my $limits_per_broker         = BOM::Config::client_limits()->{max_client_payment_accounts_per_broker_code} // {};
    my $account_broker_code_limit = $limits_per_broker->{$self->{broker_code}};
    my $default_limit             = BOM::Config::client_limits()->{max_payment_accounts_per_user};

    return $custom_limit // $account_broker_code_limit // $payment_method_limit // $default_limit;
}

=head2 linked_accounts

Returns L<BOM::User::Wallet> account details linked to a L<BOM::User::Client> instance:

    {
        trading => {
            linked_to => [
                {
                    account_id      => 'DW1000',
                    payment_method  => 'Skrill',
                    balance         => '0.00',
                    currency        => 'USD',
                }
            ]
        }
    }

=cut

sub linked_accounts {
    my $self = shift;

    return $self->user->get_accounts_links->{$self->loginid} // [];
}

=head2 latest_poi_by

Resolves the name of the latest POI check subsystem made by this client.

It takes a hashref of parameters:

=over

=item * C<only_verified> - (optional) flag to consider only verified documents.

=item * C<landing_company> - (optional) landing company. Default: client's landing company.

=back

Returns an array of triplets containing:
    [0] Name of the subsystem (idv, onfido, manual)
    [1] Related check
    [2] Timestamp of the check

=cut

sub latest_poi_by {
    my ($self, $args) = @_;
    my @triplets;

    my $lc = $args->{landing_company} ? LandingCompany::Registry->by_name($args->{landing_company}) : $self->landing_company;

    my $idv_allowed    = any { $_ eq 'idv' } $lc->allowed_poi_providers->@*;
    my $onfido_allowed = any { $_ eq 'onfido' } $lc->allowed_poi_providers->@*;
    my $manual_allowed = any { $_ eq 'manual' } $lc->allowed_poi_providers->@*;

    if ($onfido_allowed) {
        my $onfido_check = BOM::User::Onfido::get_latest_check($self, $args)->{user_check} // {};

        if (my $onfido_created_at = $onfido_check->{created_at}) {
            # most probably this check is Onfido-only, reason is even though the check is clear
            # name/dob mismatch is computed after
            if (!$args->{only_verified} || $self->get_onfido_status() eq 'verified') {
                push @triplets, ['onfido', $onfido_check, Date::Utility->new($onfido_created_at)->epoch];
            }
        }
    }

    if ($idv_allowed) {
        my $idv = BOM::User::IdentityVerification->new(user_id => $self->binary_user_id);

        if (my $idv_document = $idv->get_last_updated_document($args)) {
            if (my $idv_document_check = $idv->get_document_check_detail($idv_document->{id})) {
                push @triplets,
                    [
                    'idv', +{$idv_document_check->%*, status => $idv_document->{status}},
                    Date::Utility->new($idv_document_check->{requested_at})->epoch
                    ];
            } elsif (!($args->{only_verified} // 0)) {
                # no check but still a pending document
                push @triplets, ['idv', undef, Date::Utility->new($idv_document->{submitted_at})->epoch];
            }
        }
    }

    if ($manual_allowed) {
        if (my $document = $self->documents->latest) {
            my $origin = $document->{origin} // '';

            if ($origin eq 'client' || $origin eq 'bo') {
                push @triplets, ['manual', $document, Date::Utility->new($document->{upload_date})->epoch];
            }
        }

        if (my $age_verification = $self->status->age_verification) {
            $age_verification->{staff_name} //= 'system';
            if (lc $age_verification->{staff_name} ne 'system') {
                push @triplets, ['manual', {status => 'verified'}, Date::Utility->new($age_verification->{last_modified_date})->epoch];
            }
        }
    }

    my @sorted = sort { @{$b}[2] <=> @{$a}[2] } @triplets;

    my $latest = shift @sorted // [];

    return $latest->@*;
}

=head2 poi_attempts

Gets the list of POI attempts in chronological descending order.

The following services are supported:

=over 4

=item * C<onfido>

=item * C<idv>

=item * C<manual>

=back

Each element of the list is a hashref containing:

=over 4

=item * C<service> - the name of the service (onfido, idv)

=item * C<id> - the id of this attempt, make sure these are strings

=item * C<status> - the status of this attempt (keep it simple: pending, verified, rejected)

=item * C<country_code> - the country code used/selected on this attempt

=item * C<timestamp> - timestamp of the attempt

=back

It returns an hashref with the following structure:

=over 4

=item * C<history> - the list mentioned above

=item * C<count> - the size of the list mentioned above

=item * C<latest> - the latest attempt made (the head of the list mentioned above)

=back

=cut

sub poi_attempts {
    my ($self) = @_;
    my $attempts = [];

    my $country_code = uc($self->place_of_birth || $self->residence // '');

    if (BOM::Config::Onfido::is_country_supported($country_code)) {
        if (my $onfido_checks = BOM::User::Onfido::get_onfido_checks($self->binary_user_id, undef, 1)) {
            for my $onfido_check ($onfido_checks->@*) {
                my ($onfido_id, $onfido_result, $onfido_created_at) = @{$onfido_check}{qw/id result created_at/};

                $onfido_result //= '';

                my $onfido_status = 'pending';
                $onfido_status = 'rejected' if $onfido_result eq 'consider';
                $onfido_status = 'verified' if $onfido_result eq 'clear';

                push $attempts->@*, {
                    id      => $onfido_id,
                    status  => $onfido_status,
                    service => 'onfido',
                    # the country for onfido is just this, not stored anywhere
                    country_code => $self->place_of_birth // $self->residence,
                    timestamp    => Date::Utility->new($onfido_created_at)->epoch,
                };
            }
        }
    }

    my $idv = BOM::User::IdentityVerification->new(user_id => $self->binary_user_id);

    if (my $idv_checks = $idv->get_document_check_list) {
        for my $idv_check ($idv_checks->@*) {
            my $idv_status = 'pending';
            $idv_status = 'rejected' if $idv_check->{status} eq 'failed';
            $idv_status = 'rejected' if $idv_check->{status} eq 'refuted';
            $idv_status = 'verified' if $idv_check->{status} eq 'verified';
            $idv_status = 'pending'  if $idv_check->{status} eq 'deferred';

            push $attempts->@*,
                {
                id            => '' . $idv_check->{id},
                status        => $idv_status,
                service       => 'idv',
                country_code  => $idv_check->{issuing_country},
                document_type => $idv_check->{document_type},
                timestamp     => Date::Utility->new($idv_check->{submitted_at})->epoch,
                };
        }
    }

    if (my $document = $self->documents->latest) {
        my $origin = $document->{origin} // '';

        if ($origin eq 'client' || $origin eq 'bo') {
            my $manual_status = $self->get_manual_poi_status();    # docs are more liquid than idv/onfido checks

            push $attempts->@*, {
                id           => $document->{id},
                status       => $manual_status,
                service      => 'manual',
                country_code => $self->place_of_birth // $self->residence,    # as for now we don't have a column for country on the documents table
                timestamp    => Date::Utility->new($document->{upload_date})->epoch,
            };
        }
    }

    $attempts = [sort { $b->{timestamp} <=> $a->{timestamp} } $attempts->@*];

    return {
        latest  => $attempts->[0],
        count   => scalar $attempts->@*,
        history => $attempts,
    };
}

=head2 has_forged_documents

Computes the forged status of the client documents.

Naive approach, for now we will use the reason of the SOP defined status to tell the forged status of the client documents.

The SOP statuses for forged documents are:

=over 4

=item * C<cashier_locked>

=item * C<no_trading>

=back

Returns a boolean.

=cut

sub has_forged_documents {
    my $self                = shift;
    my @sop_forged_statuses = qw/cashier_locked no_trading/;

    for my $code (@sop_forged_statuses) {
        next unless my $status = $self->status->$code;

        next unless my $reason = $status->{reason};

        return 1 if $reason =~ /^Forged document/i;
    }

    return 0;
}

=head2 get_sum_trades

gets the sum of trades directly form database

=cut

sub get_sum_trades {
    my ($self, $from_time) = @_;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref(
                "select sum(buy_price) sum_trade from betonmarkets.get_client_sold_contracts_v3(?, ?, ?, ?, ?, ?);",
                {Slice => {}},
                $self->account->id, $from_time, 'tomorrow', '', 0, 0
            );
        })->{sum_trade} // 0;
}

=head2 get_summary_of_deposits

Gets the summary of deposits for this and all sibling accounts in the same broker code.

=cut

sub get_summary_of_deposits {
    my ($self, $from_time) = @_;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref("SELECT * FROM payment.summary_of_deposits_v3(?,?)", {Slice => {}}, $self->loginid, $from_time);
        });
}

=head2 today_payment_agent_withdrawal_sum_count

Gets the total amount and count of the payment  agent  withdrawal performed by a client in the current day.

Returns an array with two elements:

=over 4

=item * amount

=item * count

=back

=cut

sub today_payment_agent_withdrawal_sum_count {
    my $self = shift;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_array("select result->>'amount', result->>'count'  from payment_v1.get_today_payment_agent_withdrawal_sum_count(?)",
                undef, $self->loginid);
        });
}

=head2 allow_paymentagent_withdrawal_legacy
to check client can withdrawal through payment agent. return undef (allow) or 1 (denied)
- if explicit flag is set it means cs/payments team have verified to allow
payment agent withdrawal
- if flag is not set then we fallback to check for doughflow or bank wire
payments, if those does not exists then allow
=cut

sub allow_paymentagent_withdrawal_legacy {
    my $self = shift;

    return undef if $self->status->pa_withdrawal_explicitly_allowed;

    # Check if siblings have any transaction through doughflow/bankwire
    my @all_loginids = $self->user->bom_real_loginids;

    return undef
        unless any {
        BOM::Database::DataMapper::Payment->new({'client_loginid' => $_})
            ->get_client_payment_count_by({payment_gateway_code => ['doughflow', 'bank_wire']})
        } @all_loginids;

    return 1;
}

=head2 allow_paymentagent_withdrawal
- if explicit flag is set it means cs/payments team have verified to allow
payment agent withdrawal
- if flag is not set then we follow the process below to grant permission or not
- returns an error if PAwithdrawal is NOT allowed
- returns undef if it is allowed
=cut

sub allow_paymentagent_withdrawal {
    my $self = shift;

    return undef if $self->status->pa_withdrawal_explicitly_allowed;

    # we need to get trades and deposits from last 6 months in the format of 'yyyymmmddd 00:00:00'
    # This has been configed in reversible_deposits_lookback = 180 days (6 months)
    my $days         = BOM::Config::Runtime->instance->app_config->payments->reversible_deposits_lookback;
    my $amount_limit = BOM::Config::Runtime->instance->app_config->payments->pa_sum_deposits_limit;
    my $from_time    = Date::Utility->new()->minus_time_interval($days . 'd')->truncate_to_day->datetime_yyyymmdd_hhmmss;

    my $start = Time::HiRes::time;

    my $summary_of_deposits = $self->get_summary_of_deposits($from_time);
    $summary_of_deposits->{has_p2p} = 0 unless BOM::Config::P2P::available_countries()->{$self->residence};

    my $elapsed = Time::HiRes::time - $start;
    stats_timing('bom_rpc.allow_payment_agent_withdraw.timing', $elapsed);

    return "PaymentAgentZeroDeposits" if $self->account->balance <= 0;

    my $sum_deposits = $summary_of_deposits->{sum_deposits};    # query converts this to USD

    return undef unless $sum_deposits;                          # according to the query if this is undef it means client has only pa deposits

    my $sum_of_trades = convert_currency($self->get_sum_trades($from_time), $self->currency, 'USD');

    my $traded_half_of_deposits = $sum_of_trades >= $sum_deposits / 2;

    if ($summary_of_deposits->{has_visa}) {

        return $self->apply_reversible_deposit_conditions($self);

    } elsif ($summary_of_deposits->{has_mastercard}) {

        return "PaymentAgentUseOtherMethod";

    } elsif ($summary_of_deposits->{has_reversible}) {    #the same as VISA (most restricted condition)

        return $self->apply_reversible_deposit_conditions($self);

    } elsif ($summary_of_deposits->{has_zingpay}) {

        return "PaymentAgentWithdrawSameMethod";

    } elsif ($summary_of_deposits->{has_irreversible_withdrawal_true} || $summary_of_deposits->{has_p2p}) {

        return "PaymentAgentWithdrawSameMethod" unless $sum_deposits < $amount_limit;
        return "PaymentAgentJustification"      unless $traded_half_of_deposits;

    } elsif ($summary_of_deposits->{has_irreversible_withdrawal_false}) {

        return "PaymentAgentJustification" unless $traded_half_of_deposits;

    } elsif ($summary_of_deposits->{has_crypto}) {

        return "PaymentAgentWithdrawSameMethod" unless $traded_half_of_deposits;

    }

    return undef;
}

=head2 apply_reversible_deposit_conditions

applies the conditions related to visa/reversible deposits

=cut

sub apply_reversible_deposit_conditions {
    my $self                  = shift;
    my $cft_blocked_countries = BOM::Config::cft_blocked_countries();

    return "PaymentAgentUseOtherMethod" if $cft_blocked_countries->{lc $self->residence};
    return "PaymentAgentWithdrawSameMethod";
}

=head2 duplicate_sibling_from_vr

Gets the real duplicated sibling of a VR account.

Only applicable for Duplicate account - currency change reason, otherwise the client should be forsaken.

=cut

sub duplicate_sibling_from_vr {
    my ($self) = @_;

    if ($self->is_virtual) {
        return $self->duplicate_sibling;
    }

    return undef;
}

=head2 duplicate_sibling

Gets the real duplicated sibling of the client, giving more priority to MF clients.

=cut

sub duplicate_sibling {
    my ($self) = @_;

    my @clients = $self->user->clients(include_duplicated => 1);

    my @dup_candidates = sort {
        ($a->date_joined ? Date::Utility->new($a->date_joined)->epoch : 0) < ($b->date_joined ? Date::Utility->new($b->date_joined)->epoch : 0);
    } grep { $_->status->duplicate_account && !$_->is_virtual && $_->status->reason('duplicate_account') =~ /Duplicate account - currency change/ }
        @clients;

    my $duplicated = first { $_->landing_company->short eq 'maltainvest' } @dup_candidates;

    # mf will have higer prio

    return $duplicated if $duplicated;

    ($duplicated) = @dup_candidates;

    return $duplicated;
}

=head2 ignore_age_verification

We may want to override or invalidate the age verification under specific circumstances.

Rules:

=over 4

=item * High Risk profile and IDV validated account

=item * LC may not support IDV as identification method

=back

Arguments:

=over 4

=item landing_company - an optional argument by default current client's landing company is used. 

=back

It returns 1 when we invalidate the age verification, 0 otherwise.

=cut

sub ignore_age_verification {
    my ($self, $args) = @_;

    my $lc = $args->{landing_company} ? LandingCompany::Registry->by_name($args->{landing_company}) : $self->landing_company;

    return 0 unless $lc;

    # Check if it was validated by IDV, we ignore IDV verification for some LC and high risk clients
    if ($self->is_high_risk || none { $_ eq 'idv' } $lc->allowed_poi_providers->@*) {
        # Disregard idv authentication under high risk
        return 1 if $self->is_idv_validated;
    }

    return 0;
}

=head2 is_idv_validated 

Check to see if the client has been validated by IDV

Returns 1 if validated else 0.

=cut

sub is_idv_validated {
    my ($self) = @_;

    # if age verification is set, we will check which subsystem has a verified status
    # if there are more than one verified subsystems we will take the latest one, a couple lines after this check

    if ($self->status->age_verification) {
        my ($poi_system) = $self->latest_poi_by({
            only_verified => 1,
        });

        return 0 unless $poi_system;

        return 1 if $poi_system eq 'idv';
    }

    return 0;

}

=head2 is_face_similarity_required 

Check to see if the client requires Face similarity check for Onfido.

This applies for MF accounts and CR that have high aml risk. 

Returns 1 if required else 0.

=cut

sub is_face_similarity_required {
    my ($self) = @_;

    return 1 if $self->landing_company->requires_face_similarity_check;

    return 1 if $self->risk_level_aml eq 'high';

    return 0;
}

=head2 update_affiliate_token_for_batch_of_clients

Update myaffiliate token for list of clients

Arguments:

=over 4

=item affiliate_token - affiliate token that going to be used for replacing current tokens for clients

=item broker_code - broker code for clientDB => CR, MF , ...

=item login_ids - list of client login ids to used for the replacement action

=back

return 1 if successful otherwise 0

=cut

sub update_affiliate_token_for_batch_of_clients {
    my ($affiliate_token, $broker_code, $login_ids) = @_;
    my $client_dbic = BOM::Database::ClientDB->new({broker_code => $broker_code // 'CR'})->db->dbic;

    my $count = $client_dbic->run(
        fixup => sub {
            $_->selectrow_array('SELECT betonmarkets.update_affiliate_token_on_batch_of_clients(?, ?)', {Slice => {}}, $login_ids, $affiliate_token);
        });
    return $count;

}

=head2 is_mt5_additional_kyc_required 

Applicable to svg and non-high risk countries only Check if the client is has not filled any of the information 
i,e tax information and account opening reason and place of birth - 
if not, then we need add status with the flag 'additional_kyc_required'    
restrict high risk countries from bvi, labuan and vanuatua

Returns 1 if additional_kyc_ else 0.

=cut

sub is_mt5_additional_kyc_required {
    my ($self) = @_;
    return 0 if $self->landing_company->short ne 'svg';
    # get the trading plaforms supported from here
    my $platform = BOM::TradingPlatform->new(
        platform => 'mt5',
        client   => $self
    );
    return 0 unless $self->residence;
    my $platforms = $platform->available_accounts({country_code => $self->residence});

    return 0 unless $platforms;
    my @supported_platforms = grep { $_->{shortcode} =~ /^(bvi|vanuatu|labuan)$/ } @$platforms;

    return 0 unless @supported_platforms;

    my @signup_and_compliance_values = ();

    foreach my $company (@supported_platforms) {
        push @signup_and_compliance_values, $company->{requirements}{signup}->@*;
        my $compliance_values = $company->{requirements}->{compliance};
        if ($compliance_values && $compliance_values->{tax_information}) {
            push @signup_and_compliance_values, $compliance_values->{tax_information}->@*;
        }
    }
    my @unique_fields = uniq(@signup_and_compliance_values);
    foreach my $field (@unique_fields) {
        return 1 if !defined $self->{$field} || $self->{$field} eq '';
    }
    return 0;
}

1;
