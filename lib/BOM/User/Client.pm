package BOM::User::Client;
# ABSTRACT: binary.com client handling and business logic

use strict;
use warnings;

our $VERSION = '0.145';

use parent 'BOM::Database::AutoGenerated::Rose::Client';

no indirect;
use Syntax::Keyword::Try;
use Email::Address::UseXS;
use Email::Stuffer;
use Date::Utility;
use List::Util qw/all first min any uniq max/;
use Locale::Country::Extra;
use Format::Util::Numbers qw(roundcommon);
use Text::Trim qw(trim);
use BOM::Platform::Context qw/ localize request /;
use YAML::XS qw(LoadFile);
use Path::Tiny;
use Format::Util::Numbers qw/financialrounding formatnumber/;
use Date::Utility;
use ExchangeRates::CurrencyConverter qw/convert_currency in_usd/;
use JSON::MaybeXS ();
use Encode;
use DataDog::DogStatsd::Helper qw(stats_inc);

use Rose::DB::Object::Util qw(:all);
use Rose::Object::MakeMethods::Generic scalar => ['self_exclusion_cache'];

use LandingCompany::Registry;

use BOM::Platform::Account::Real::default;
use BOM::Database::ClientDB;
use BOM::User::Client::PaymentAgent;
use BOM::User::Client::Status;
use BOM::User::Client::Account;
use BOM::User::Phone;
use BOM::User::FinancialAssessment qw(is_section_complete decode_fa);
use BOM::User::Utility;
use BOM::Platform::Event::Emitter;
use BOM::Database::UserDB;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::Payment;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::AutoGenerated::Rose::Client::Manager;
use BOM::Database::AutoGenerated::Rose::SelfExclusion;
use BOM::Config;
use BOM::Config::Redis;
use BOM::Config::CurrencyConfig;

use BOM::User::Client::PaymentNotificationQueue;
use BOM::User::Client::PaymentTransaction::Doughflow;
use BOM::Database::ClientDB;

use BOM::Platform::S3Client;
use BOM::Platform::Event::Emitter;
use BOM::Platform::Client::CashierValidation;

use Carp qw(croak);

use Log::Any qw($log);

sub DOCUMENT_TYPE_CATEGORIES {
    my %document_type_categories = (
        POI => {
            doc_types =>
                [qw(passport proofid driverslicense driving_licence national_identity_card vf_face_id vf_id photo live_photo selfie_with_id)],
            doc_types_appreciated => [qw(passport national_identity_card driving_licence proofid driverslicense)],
        },
        POA => {
            doc_types => [qw(vf_poa proofaddress utility_bill bankstatement cardstatement)],
        },
        Funds => {
            doc_types => [qw(payslip tax_receipt employment_contract)],
        },
        Checks => {
            doc_types => [qw(amlglobalcheck docverification)],
        },
        Declarations => {
            doc_types => [qw(power_of_attorney code_of_conduct)],
        },
        Other => {
            doc_types => [qw(other professional_eu_qualified_investor professional_uk_high_net_worth professional_uk_self_certified_sophisticated)],
        });
    return %document_type_categories;
}

use constant P2P_TOKEN_MIN_EXPIRY => 2 * 60 * 60;    # 2 hours

use constant {
    MT5_REGEX     => qr/^MT[DR]?(?=\d+$)/,
    VIRTUAL_REGEX => qr/^VR/,
};

# this email address should not be added into brand as it is specific to internal system
my $SUBJECT_RE = qr/(New Sign-Up|Update Address)/;

my $META = __PACKAGE__->meta;                        # rose::db::object::manager meta rules. Knows our db structure

my $json = JSON::MaybeXS->new;

sub rnew { return shift->SUPER::new(@_) }

sub new {
    my $class = shift;
    my $args  = shift || die 'BOM::User::Client->new called without args';

    my $loginid = $args->{loginid};
    die "no loginid" unless $loginid;

    my $operation = delete $args->{db_operation};

    my $self = $class->SUPER::new(%$args);

    $self->set_db($operation) if $operation;

    $self->load(speculative => 1) || return undef;    # must exist in db

    return $self;
}

sub get_instance {
    my $args = shift;
    return __PACKAGE__->new($args);
}

#              real db column                                    =>  legacy name
$META->column('address_city')->method_name('get_set' => 'city');
$META->column('address_line_1')->method_name('get_set' => 'address_1');
$META->column('address_line_2')->method_name('get_set' => 'address_2');
$META->column('address_postcode')->method_name('get_set' => 'postcode');
$META->column('address_state')->method_name('get_set' => 'state');
$META->column('client_password')->method_name('get_set' => 'password');

my $date_inflator_ymdhms = sub {
    my $self = shift;
    my $val  = shift // return undef;
    return $val unless ref($val);
    return $val->isa('DateTime') ? ($val->ymd . ' ' . $val->hms) : $val;
};

my $date_inflator_ymd = sub {
    my $self = shift;
    my $val  = shift // return undef;
    return $val unless ref($val);
    return $val->isa('DateTime') ? $val->ymd : $val;
};

$META->column('date_of_birth')->add_trigger(inflate => $date_inflator_ymd);
$META->column('date_of_birth')->add_trigger(deflate => $date_inflator_ymd);
$META->column('date_joined')->add_trigger(inflate => $date_inflator_ymdhms);
$META->column('date_joined')->add_trigger(deflate => $date_inflator_ymdhms);
$META->column('non_pep_declaration_time')->add_trigger(inflate => $date_inflator_ymdhms);
$META->column('non_pep_declaration_time')->add_trigger(deflate => $date_inflator_ymdhms);

my %DEFAULT_VALUES = (
    cashier_setting_password => '',
    latest_environment       => '',
    restricted_ip_address    => '',
);

$META->column($_)->default($DEFAULT_VALUES{$_}) for sort keys %DEFAULT_VALUES;

# END OF METADATA -- do this after all 'meta' calls.
$META->initialize(replace_existing => 1);

sub save {
    my $self = shift;
    # old code can set these numeric columns to ''.  should have been undef.
    for my $col (qw/custom_max_acbal custom_max_daily_turnover custom_max_payout/) {
        my $val = $self->$col // next;
        $self->$col(undef) if $val eq '';    # if we get here, it's defined.
    }

    $self->set_db('write');
    my $r = $self->SUPER::save(cascade => 1);    # Rose
    return $r;
}

sub store_details {
    my ($self, $args) = @_;

    $self->aml_risk_classification('low') unless $self->is_virtual;

    $self->$_($args->{$_}) for sort keys %$args;

    # special cases.. force empty string if necessary in these not-nullable cols.  They oughta be nullable in the db!
    for (qw(citizen address_2 state postcode salutation)) {
        $self->$_ || $self->$_('');
    }

    # resolve Gender from Salutation
    if ($self->salutation and not $self->gender) {
        my $gender = (uc $self->salutation eq 'MR') ? 'm' : 'f';
        $self->gender($gender);
    }

    $self->gender('m') unless $self->gender;

    return undef;
}

sub register_and_return_new_client {
    my $class = shift;
    my $args  = shift;

    my $broker = $args->{broker_code} || die "can't register a new client without a broker_code";
    my $self   = $class->rnew(broker => $broker);

    store_details($self, $args);

    $self->set_db('write');

    my $sql    = "SELECT nextval('sequences.loginid_sequence_$broker')";
    my $dbic   = $self->db->dbic;
    my @seqnum = $dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute();
            return $sth->fetchrow_array();
        });

    $self->loginid("$broker$seqnum[0]");
    return $self->save;
}

sub full_name {
    my $self = shift;
    return $self->salutation . ' ' . $self->first_name . ' ' . $self->last_name;
}

sub landing_company {
    my $self = shift;
    return LandingCompany::Registry->get_by_broker($self->broker);
}

=head2 set_promotion

Description: Sets or Gets the promotion object. Linked to the table betonmarkets.client_promo_code
If the client does not have a promo_code object it will be created otherwise the existing one will be returned.
Takes no Arguments


Returns a L<BOM::Database::AutoGenerated::Rose::ClientPromoCode>

=cut

sub set_promotion {
    my ($self) = @_;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
        $self->client_promo_code(undef);    # empty Rose's read-only version..
    }
    # get the existing one or make a dummy one..
    if (my $obj = $self->client_promo_code) {
        return $obj;
    }
    if (LandingCompany::Registry::get_currency_type($self->currency) eq 'crypto') {
        die "Promo code cannot be added to crypto currency accounts\n";
    }
    my %args = (
        broker         => $self->broker,
        client_loginid => $self->loginid,
        status         => 'NOT_CLAIM',
        mobile         => '',
        apply_date     => Date::Utility->new->db_timestamp,
        db             => $self->db,
    );

    my $obj = BOM::Database::AutoGenerated::Rose::ClientPromoCode->new(%args);
    return $self->client_promo_code($obj);
}

# support legacy calls to these get/set shortcuts from Client to the promo_code record
sub promo_code {
    my ($self, $promo_code) = @_;
    if ($promo_code) {
        my $dbic   = $self->db->dbic;
        my $result = $dbic->run(
            fixup => sub {
                $_->selectrow_hashref('SELECT * FROM betonmarkets.promo_code WHERE code = ?', undef, ($promo_code),);
            });
        die "invalid promocode $promo_code\n" if (!$result);
        return $self->set_promotion->promotion_code($promo_code);
    }
    return ($self->client_promo_code || return)->promotion_code;
}

sub promo_code_status {
    my $self = shift;
    return $self->set_promotion->status(@_) if @_;
    return ($self->client_promo_code || return)->status;
}

sub promo_code_apply_date {
    my $self = shift;
    return $self->set_promotion->apply_date(@_) if @_;
    return ($self->client_promo_code || return)->apply_date;
}

sub promo_code_checked_in_myaffiliates {
    my $self = shift;
    return $self->set_promotion->checked_in_myaffiliates(@_) if @_;
    return ($self->client_promo_code || return)->checked_in_myaffiliates;
}

sub by_promo_code {
    my ($class, %args) = @_;
    my $broker  = $args{broker_code} || die 'by_promo_code needs a broker_code';
    my $db      = $class->rnew(broker => $broker)->db;
    my $clients = BOM::Database::AutoGenerated::Rose::Client::Manager->get_client(
        db           => $db,
        with_objects => ['client_promo_code'],
        query        => [%args],
        sort_by      => 't1.broker_code, t1.loginid'
    );
    # turn BPDPR::Client objects into (much smarter) Client objects
    return map { bless $_, $class } @$clients;
}

sub by_args {
    my ($class, %query) = @_;
    my $broker = $query{broker_code} || die 'by_args needs a broker_code';
    my %opts   = (
        db      => $class->rnew(broker => $broker)->db,
        sort_by => 'broker_code, loginid'
    );
    if (my $limit = delete $query{limit}) {
        $opts{limit} = $limit;
    }
    my $clients = BOM::Database::AutoGenerated::Rose::Client::Manager->get_client(%opts, query => [%query]);
    # turn BPDPR::Client objects into (much smarter) Client objects
    return [map { bless $_, $class } @$clients];
}

sub get_objects_from_sql {
    my ($class, %args) = @_;
    my $broker = delete $args{broker_code} || die 'get_objects_from_sql needs a broker_code';
    $args{db} ||= $class->rnew(broker => $broker)->db;
    my $clients = BOM::Database::AutoGenerated::Rose::Client::Manager->get_objects_from_sql(%args);
    # turn BPDPR::Client objects into (much smarter) Client objects
    return [map { bless $_, $class } @$clients];
}

sub is_virtual { return shift->broker =~ VIRTUAL_REGEX }

sub has_funded { return shift->first_funded_date ? 1 : 0 }

sub get_authentication {
    my $self            = shift;
    my $method          = shift;
    my $column          = shift;
    my $authentications = {map { $_->authentication_method_code => $_ } $self->client_authentication_method};
    my $obj             = $authentications->{$method} || return undef;
    return $column ? $obj->$column : $obj;
}

sub set_authentication {
    my $self   = shift;
    my $method = shift;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
        $self->client_authentication_method(undef);    # throw out my read-only versions..
    }
    return $self->get_authentication($method) || do {
        $self->add_client_authentication_method({
            authentication_method_code => $method,
            status                     => 'pending'
        });
        $self->get_authentication($method);
    }
}

=head2 risk_level

Get the risk level of clients, based on:

- SR (Social Responsibility): Always high for clients that have breached thresholds
and have no financial assessment

- AML (Anti-Money Laundering): Applies for clients under all landing companies

=cut

sub risk_level {
    my $self = shift;

    my $risk = $self->aml_risk_classification // '';

    # use `low`, `standard`, `high` as prepending `manual override` string is for internal purpose
    $risk =~ s/manual override - //;

    if ($self->landing_company->social_responsibility_check_required && !$self->financial_assessment) {
        $risk = 'high'
            if BOM::Config::Redis::redis_events()->get($self->loginid . '_sr_risk_status');
    }

    return $risk;
}

=head2 is_financial_assessment_complete

Check if the client has filled out the financial assessment information:

- For non-MF, only the the financial information (FI) is required and risk level is high.
- For MF, both the FI and trading experience is required, regardless of rish level.

=cut

sub is_financial_assessment_complete {
    my $self = shift;

    my $sc                   = $self->landing_company->short;
    my $financial_assessment = decode_fa($self->financial_assessment());

    my $is_FI = is_section_complete($financial_assessment, 'financial_information');

    if ($sc ne 'maltainvest') {
        return 0 if ($self->risk_level() eq 'high' and not $is_FI);
        return 1;
    }

    my $is_TE = is_section_complete($financial_assessment, 'trading_experience');

    return 0 unless ($is_FI and $is_TE);

    return 1;
}

=head2 documents_expired

documents_expired returns a boolean indicating if this client (or any related clients)
have any POI documents (passport, proofid, driverslicense, vf_id, vf_face_id) which have expired.

=cut

sub documents_expired {
    my $self = shift;

    my @siblings = $self->user->clients(
        include_disabled   => 1,
        include_duplicated => 1
    );

    for my $sibling (@siblings) {

        next if $sibling->is_virtual;

        next if !($sibling->is_document_expiry_check_required());

        return 1 if $sibling->_get_documents_expiry_by_date();
    }
    return 0;
}

=head2 is_any_document_expiring_by_date

Returns a boolean indicating if this client (or any related clients)
have any POI documents (passport, proofid, driverslicense, vf_id, vf_face_id) which
have expired or the expiration is before a specific date.

Takes one argument:

=over 4

=item * $date_limit

If this argument is not specified, the sub which check for documents which have expired
(i.e. have an expiration date yesterday or earlier).
If this argument is specified, the sub will check for documents whose expiration
date is earlier than the specified date.

=back

=cut

sub is_any_document_expiring_by_date {
    my ($self, $date_limit) = @_;

    return 0 if $self->is_virtual;

    $date_limit //= Date::Utility->new();

    return 0 + !!($self->_get_documents_expiry_by_date($date_limit));
}

sub _get_documents_expiry_by_date {
    my ($self, $date_limit) = @_;

    $date_limit //= Date::Utility->new();

    my @query_params = ($self->loginid, $date_limit->db_timestamp);
    my $dbic_code    = sub {
        my $query = $_->prepare('SELECT * FROM betonmarkets.get_expired_documents_loginids($1::TEXT, $2::DATE)');
        $query->execute(@query_params);
        return $query->fetchrow_arrayref();
    };

    return $self->db->dbic->run(fixup => $dbic_code);
}

=head2 documents_uploaded

Return all the uploaded documents for the current client.
Ignores that are in uploading state

Returns

=over 4

=item * A hashref containing list of different document types

    {
        proof_of_identity => {
            documents => {
                file_name1 => {},
                file_name2 => {},
            },
            is_expired => 0,
            minimum_expiry_date => epoch,
        },
        proof_of_address => {
            documents => {
                file_name1 => {},
                file_name2 => {},
            },
            is_expired => 0,
            minimum_expiry_date => epoch,
        },
        others => {
            documents => {
                file_name1 => {},
                file_name2 => {},
            },
            is_expired => 0,
            minimum_expiry_date => epoch,
        },
    }

=back

=cut

sub documents_uploaded {
    my $self = shift;

    my $doc_structure = sub {
        my $doc = shift;

        return {
            expiry_date => $doc->expiration_date ? $doc->expiration_date->epoch : undef,
            type        => $doc->document_type,
            format      => $doc->document_format,
            id          => $doc->document_id,
            status      => $doc->status,
        };
    };

    my %documents = ();

    my @siblings = $self->user->clients(
        include_disabled   => 1,
        include_duplicated => 1
    );

    for my $each_sibling (@siblings) {
        next if $each_sibling->is_virtual;

        foreach my $single_document ($each_sibling->client_authentication_document) {
            # uploading document can lead to any success or failure
            # so better to not consider that
            next if defined $single_document->status and $single_document->status eq 'uploading';

            my $type                = 'other';
            my %doc_type_categories = DOCUMENT_TYPE_CATEGORIES();
            $type = 'proof_of_identity' if (first { $_ eq $single_document->document_type } @{$doc_type_categories{POI}{doc_types_appreciated}});
            $type = 'proof_of_address'
                if (first { $_ eq $single_document->document_type } qw(proofaddress payslip utility_bill bankstatement cardstatement));

            $documents{$type}{documents}{$single_document->file_name} = $doc_structure->($single_document);

            # there should be no expiration date for POA
            next if $type eq 'proof_of_address';

            my $expires = $documents{$type}{documents}{$single_document->file_name}{expiry_date};
            next unless $expires;

            my $existing_expiry_date_epoch = $documents{$type}{minimum_expiry_date} // $expires;
            # Even though the key is 'minimum_expiry_date' we are taking into account the latest date found for POI, hence max is used
            my $minimum_expiry_date;
            $minimum_expiry_date = max($expires, $existing_expiry_date_epoch) if $type eq 'proof_of_identity';
            $minimum_expiry_date = min($expires, $existing_expiry_date_epoch) if $type ne 'proof_of_identity';

            $documents{$type}{minimum_expiry_date} = $minimum_expiry_date;
            $documents{$type}{is_expired}          = Date::Utility->new->epoch > $minimum_expiry_date ? 1 : 0;
        }
    }

    if (scalar(keys %documents) and exists $documents{proof_of_identity}) {
        $documents{proof_of_identity}{is_pending} = 1 unless $self->status->age_verification;
    }

    # set document status for authentication
    # status - needs_action and under_review
    if (scalar(keys %documents) and exists $documents{proof_of_address}) {
        if (($self->authentication_status // '') eq 'needs_action') {
            $documents{proof_of_address}{is_rejected} = 1;
        } elsif (not $self->fully_authenticated) {
            $documents{proof_of_address}{is_pending} = 1;
        }
    }

    return \%documents;
}

sub has_valid_documents {
    my $self = shift;

    my $documents = $self->documents_uploaded();

    # no documents
    return 0 unless scalar(keys %$documents);

    # if any of the document is expired then documents are invalid
    return 0 if any { $documents->{$_}{is_expired} } keys %$documents;

    return 1;
}

=head2 fully_authenticated

For reference a client is termed fully authenticated with following parameters :

CR - POI + POA
MX - Prove ID / (POI + POA)
MLT - POI + POA
MF - POI + POA + Selfie in Onfido

=cut

sub fully_authenticated {
    my $self = shift;

    for my $method (qw/ID_DOCUMENT ID_NOTARIZED ID_ONLINE/) {
        my $auth = $self->get_authentication($method);
        return 1 if $auth and $auth->status eq 'pass';
    }

    return 0;
}

sub authentication_status {
    my ($self) = @_;

    my $online = $self->get_authentication('ID_ONLINE');

    return 'online' if $online and $online->status eq 'pass';

    my $notarized = $self->get_authentication('ID_NOTARIZED');

    return 'notarized' if $notarized and $notarized->status eq 'pass';

    my $id_auth = $self->get_authentication('ID_DOCUMENT');

    return 'no' unless $id_auth;

    my $id_auth_status = $id_auth->status;

    return 'scans' if $id_auth_status eq 'pass';

    return $id_auth_status;
}

sub set_exclusion {
    my $self = shift;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
    }
    # return the existing one..
    if (my $obj = $self->self_exclusion) {
        $obj->db($self->db);
        $self->self_exclusion_cache([$obj]);
        return $obj;
    }
    # or make a new one
    $self->self_exclusion(my $obj = BOM::Database::AutoGenerated::Rose::SelfExclusion->new());
    $self->self_exclusion_cache([$obj]);
    return $self->self_exclusion;
}

# make this relationship return its smarter version too
sub get_payment_agent {
    my $self = shift;
    my $obj  = $self->payment_agent || return undef;
    my $pa   = bless $obj, 'BOM::User::Client::PaymentAgent';
    return $pa;
}

# return a (new or existing) writeable BOM::User::Client::PaymentAgent
sub set_payment_agent {
    my $self = shift;
    unless ($self->get_db eq 'write') {
        $self->set_db('write');
    }
    # return the existing one..
    if (my $obj = $self->get_payment_agent) {
        $obj->db($self->db);
        return $obj;
    }
    my %args = (
        client_loginid => $self->loginid,
        db             => $self->db
    );
    $self->payment_agent(BOM::Database::AutoGenerated::Rose::PaymentAgent->new(%args));
    return $self->get_payment_agent;
}

sub get_self_exclusion {
    my $self = shift;

    my $excl = $self->self_exclusion_cache;
    return $excl->[0] if $excl;

    $excl = $self->self_exclusion;
    $self->self_exclusion_cache([$excl]);
    return $excl;
}

sub get_limits_for_max_deposit {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    return undef unless $excl;

    my $max_deposit = $excl->max_deposit;
    my $begin_date  = $excl->max_deposit_begin_date;
    my $end_date    = $excl->max_deposit_end_date;
    my $today       = Date::Utility->new;

    undef $end_date if $end_date and Date::Utility->new($end_date)->is_before($today);
    undef $begin_date  unless $end_date;
    undef $max_deposit unless $end_date;

    # No limits if any of the fields are missing
    return undef unless $max_deposit and $begin_date and $end_date;

    return +{
        max_deposit => $max_deposit,
        begin       => $begin_date->date,
        end         => $end_date->date
    };
}

=head2 get_limit_for_account_banace

Get client's balance limit from global configuration and self exclusion.

Return: account balance limit

=cut

sub get_limit_for_account_balance {
    my $self = shift;

    my @maxbalances        = ();
    my $max_bal            = BOM::Config::client_limits()->{max_balance};
    my $curr               = $self->currency;
    my $config_max_balance = $self->is_virtual ? $max_bal->{virtual}->{$curr} : $max_bal->{real}->{$curr};
    if (defined($config_max_balance)) {
        push @maxbalances, $config_max_balance;
    } else {
        local $log->context->{loginid} = $self->loginid;
        $log->warn("No such currency $curr in BOM::Config::Client_limits");
    }

    my $self_max_balance = $self->get_self_exclusion ? $self->get_self_exclusion->max_balance : undef;
    if (defined($self_max_balance)) {
        push @maxbalances, $self_max_balance;
    }

    return List::Util::min(@maxbalances);
}

sub get_limit_for_daily_turnover {
    my $self = shift;

    # turnover maxed at 500K of any currency.
    my @limits = (BOM::Config::client_limits()->{maximum_daily_turnover}{$self->currency});
    if ($self->get_self_exclusion && $self->get_self_exclusion->max_turnover) {
        push @limits, $self->get_self_exclusion->max_turnover;
    }

    return List::Util::min(@limits);
}

sub get_limit_for_daily_losses {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_losses) {
        return $excl->max_losses;
    }
    return undef;
}

sub get_limit_for_7day_turnover {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_7day_turnover) {
        return $excl->max_7day_turnover;
    }
    return undef;
}

sub get_limit_for_7day_losses {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_7day_losses) {
        return $excl->max_7day_losses;
    }
    return undef;
}

sub get_limit_for_30day_turnover {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_30day_turnover) {
        return $excl->max_30day_turnover;
    }
    return undef;
}

sub get_limit_for_30day_losses {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_30day_losses) {
        return $excl->max_30day_losses;
    }
    return undef;
}

sub get_limit_for_open_positions {
    my $self = shift;

    my @limits = BOM::Config::client_limits()->{max_open_bets_default};

    my $excl = $self->get_self_exclusion;
    if ($excl && $excl->max_open_bets) {
        push @limits, $excl->max_open_bets;
    }

    return List::Util::min(@limits);
}

# return undef or an exclusion date string
sub get_self_exclusion_until_date {
    my $self = shift;

    my $excl = $self->get_self_exclusion;
    return undef unless $excl;

    my $exclude_until = $excl->exclude_until;
    my $timeout_until = $excl->timeout_until;
    my $today         = Date::Utility->new;
    # Don't uplift exclude_until date for clients under Deriv (Europe) Limited,
    # Deriv (MX) Ltd, and Deriv Investments (Europe) Limited upon expiry.
    # This is in compliance with Section 3.5.4 (5e) of the United Kingdom Gambling
    # Commission licence conditions and codes of practice
    # United Kingdom Gambling Commission licence conditions and codes of practice is
    # applicable to clients under Deriv (Europe) Limited & Deriv (MX) Ltd only. Change is also
    # applicable to clients under Deriv Investments (Europe) Limited for standardisation.
    # (http://www.gamblingcommission.gov.uk/PDF/LCCP/Licence-conditions-and-codes-of-practice.pdf)
    if ($self->landing_company->short !~ /^(?:iom|malta|maltainvest)$/) {
        # undef if expired
        undef $exclude_until
            if $exclude_until and Date::Utility->new($exclude_until)->is_before($today);
    }

    undef $timeout_until if $timeout_until and Date::Utility->new($timeout_until)->is_before($today);

    return undef unless $exclude_until || $timeout_until;

    if ($exclude_until && $timeout_until) {
        my $exclude_until_dt = Date::Utility->new($exclude_until);
        my $timeout_until_dt = Date::Utility->new($timeout_until);

        return $exclude_until_dt->date if $exclude_until_dt->epoch < $timeout_until_dt->epoch;
        return $timeout_until_dt->datetime_yyyymmdd_hhmmss_TZ;
    }

    return Date::Utility->new($exclude_until)->date if $exclude_until;
    return Date::Utility->new($timeout_until)->datetime_yyyymmdd_hhmmss_TZ;
}

sub get_limit_for_payout {
    my $self = shift;

    my $max_payout = BOM::Config::client_limits()->{max_payout_open_positions};

    return $max_payout->{$self->currency};
}

sub get_limit {
    my $self = shift;
    my $args = shift || die 'get_limit needs args';
    my $for  = $args->{for} || die 'get_limit needs a "for" arg';

    $for = 'get_limit_for_' . $for;
    return $self->$for;
}

sub currency {
    my $self = shift;

    return 'USD' if $self->is_virtual;

    if (my $account = $self->default_account) {
        return $account->currency_code();
    }

    return 'GBP' if $self->residence eq 'gb';
    return 'AUD' if $self->landing_company->short eq 'svg' and $self->residence eq 'au';
    return $self->landing_company->legal_default_currency;
}

=head2 local_currency

Returns the 3-character currency code matching the client's residence as defined in L<ISO 4217|https://en.wikipedia.org/wiki/ISO_4217>.

=over 4

=item * C<$country> - optional 3-character ISO country code used to override the country
for the currency mapping, for cases where you want to use citizenship or a specific country

=back

=cut

sub local_currency {
    my ($self, $country) = @_;
    $country //= $self->residence;

    return undef unless $country;

    return BOM::Config::CurrencyConfig::local_currency_for_country($country);
}

sub has_deposits {
    my $self = shift;
    my $args = shift;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref("SELECT * from betonmarkets.has_first_deposit(?, ?);", undef, $self->loginid, $args->{exclude});
        })->{has_first_deposit};
}

sub is_first_deposit_pending {
    my $self = shift;
    # we need to ignore free gift as its payment done manually by marketing
    return !$self->is_virtual && !$self->has_deposits({exclude => ['free_gift']});
}

=head2 is_mt5

Returns 1 if this is an MT5 account.
Returns 0 if this isn't an MT5 account

=cut

sub is_mt5 {
    my $self = shift;
    return $self->loginid =~ MT5_REGEX;
}

sub has_mt5_deposits {
    my $self   = shift;
    my $mt5_id = shift;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref("SELECT * from betonmarkets.has_first_mt5_deposit(?);", undef, $mt5_id);
        })->{has_first_mt5_deposit};
}

sub first_funded_currency { return shift->_ffd->{first_funded_currency} }
sub first_funded_amount   { return shift->_ffd->{first_funded_amount} }
sub first_funded_date     { return shift->_ffd->{first_funded_date} }

sub _ffd {    # first_funded_details
    my $self           = shift;
    my $ffd            = {};
    my $payment_mapper = BOM::Database::DataMapper::Payment->new({client_loginid => $self->loginid});
    if (my $ff = $payment_mapper->first_funding) {
        $ffd->{first_funded_date}     = Date::Utility->new($ff->payment_time->epoch);
        $ffd->{first_funded_amount}   = sprintf '%.2f', $ff->amount;
        $ffd->{first_funded_currency} = $ff->account->currency_code();
    }
    return $ffd;
}

# The following 2 subroutines are proxies to
# the real account sub routine and can be removed
# when the calls are refactored.

sub set_default_account {
    my $self     = shift;
    my $currency = shift;
    return $self->account($currency);
}

sub default_account {
    my $self = shift;
    return $self->account();
}

=head2 account

C<< $account = $self->account($currency) >>

If one does not exist it creates an account entry assigns it a currency symbol
and marks it as default.  If there is already a default currency set it makes
no changes.

Takes the following parameters.

=over 4

=item * C<currency> - (optional) An alphanumeric string with 2-20 characters as defined in L<ISO 4217|https://en.wikipedia.org/wiki/ISO_4217> where C<ISO 4217> applicable for some currencies (i.e. fiat). An account will be created based on the given string, if it does not exist.

=back

Returns C<Account> - An Account Object of type BOM::User::Client::Account

=cut

sub account {
    my $self     = shift;
    my $currency = shift;

    my $account = BOM::User::Client::Account->new(
        client_loginid => $self->loginid,
        currency_code  => $currency,
        db             => $self->db,
    );

    #calls to Account new will always return some sort of object because that's how moo works,
    #so to maintain backward compatibility we return undef if no currency_code exists showing
    #an empty account.
    return undef if !defined $account->currency_code();

    return $account;
}

sub open_bets {
    my $self    = shift;
    my $account = $self->default_account || return undef;
    my $fmbs    = $account->find_financial_market_bet(query => [is_sold => 0]);
    return @$fmbs;
}

=head1 CUSTOMER SERVICE RELATED FUNCTIONS

These are for interfacing with customer service facing applications (like email
queues or CRM applications).

=head2 add_note($subject, $content)

Adds a note for a customer record.  This is supposed to integrate with whatever
CS is doing, and returns 1 on success or 0 on failure.

Currently this is simply an emailer which sends the email to the helpdesk
system.  Since we go through localhost, we die if there is an error.  This
might happen if somehow we are sending invalid SMTP commands or the like.

As the implementation changes the exceptions may change as well, but the basic
guarantee is that if there is a serious system error that prevents this from
working going forward with any input, it should die.

=cut

sub add_note {
    my ($self, $subject, $content) = @_;

    # send to different email based on the subject of the email, as the helpdesk system handles different subject and email differently.
    my $email_to = ($subject =~ /$SUBJECT_RE/) ? 'support_new_account' : 'support';
    $email_to = request()->brand->emails($email_to);
    my $email_from = request()->brand->emails('system_generated');

    # We want to record who this note is for, but many legacy places already include client ID.
    # If you're reading this, please check for those and remove the condition.
    my $loginid = $self->loginid;
    $subject = $loginid . ': ' . $subject unless $subject =~ /\Q$loginid/;
    return Email::Stuffer->from($email_from)->to($email_to)->subject($subject)->text_body($content)->send_or_die;
}

=pod

=head2 get_promocode_dependent_limit

get the limits based on promocode

=cut

sub get_promocode_dependent_limit {
    my ($self) = @_;

    my $payment_mapper = BOM::Database::DataMapper::Payment->new({
        'client_loginid' => $self->loginid,
        'currency_code'  => $self->currency,
    });

    my $total_free_gift_deposits            = $payment_mapper->get_total_free_gift_deposit();
    my $total_free_gift_rescind_withdrawals = $payment_mapper->get_total_free_gift_rescind_withdrawal();

    my $free_gift_deposits = $total_free_gift_deposits - $total_free_gift_rescind_withdrawals;

    my $frozen_free_gift = 0;
    my $turnover_limit   = 0;

    my $cpc = $self->client_promo_code;
    if ($cpc && $cpc->status !~ /^(CANCEL|REJECT)$/) {

        my $pc = $cpc->promotion;
        try {
            $pc->{_json} ||= JSON::MaybeXS->new->decode($pc->promo_code_config);
        } catch {
            $log->debugf('Unable to parse promo code config: %s', $pc->promo_code_config);
        }

        if ($pc->promo_code_type eq 'FREE_BET') {

            my $min_turnover = $pc->{_json}{min_turnover};
            my $amount       = $pc->{_json}{amount};

            my $made_actual_deposit = $payment_mapper->get_total_deposit() - $amount;
            if ($made_actual_deposit) {
                $frozen_free_gift = $free_gift_deposits;
            } else {
                my $account_mapper = BOM::Database::DataMapper::Account->new({
                    'client_loginid' => $self->loginid,
                    'currency_code'  => $self->currency,
                });
                $frozen_free_gift = $account_mapper->get_balance();
            }

            $turnover_limit = 25 * $amount;

            # matched bets
            if (defined($min_turnover) and length($min_turnover) > 0) {
                $frozen_free_gift = 0;
            }

            my $txn_data_mapper = BOM::Database::DataMapper::Transaction->new({
                client_loginid => $self->loginid,
                currency_code  => $self->currency,
            });

            if (roundcommon(0.01, $txn_data_mapper->get_turnover_of_account) >= $turnover_limit) {
                $frozen_free_gift = 0;
            }
        }
    }

    return {
        frozen_free_gift         => $frozen_free_gift,
        free_gift_turnover_limit => $turnover_limit,
    };
}

=pod

=head2 get_withdrawal_limits

get withdraw limits

=cut

sub get_withdrawal_limits {
    my $self = shift;

    my $withdrawal_limits = $self->get_promocode_dependent_limit();

    my $max_withdrawal = 0;
    if ($self->default_account) {
        my $balance = $self->default_account->balance;
        $max_withdrawal = List::Util::max(0, $balance - $withdrawal_limits->{'frozen_free_gift'});
    }

    $withdrawal_limits->{'max_withdrawal'} = $max_withdrawal;

    return $withdrawal_limits;
}

=head2 user

    my $user = $self->user;
returns the user associated with the client : C<BOM::User>

=cut

sub user {
    my $self = shift;

    my $id = $self->binary_user_id;
    my $user;

    # Use binary_user_id to get the user
    $user = BOM::User->new(id => $id) if $id;
    # Fall back to loginid if binary_user_id does not work
    $user ||= BOM::User->new(loginid => $self->loginid);
    # Fall back to email if loginid does not work
    # in case that the user object is created but the client has not been registered into it.
    $user ||= BOM::User->new(email => $self->email);

    return $user;
}

=head2 is_available

return false if client is disabled or is duplicated account

=cut

sub is_available {
    my $self = shift;
    foreach my $status (qw(disabled duplicate_account)) {
        return 0 if $self->status->$status();
    }
    return 1;
}

sub real_account_siblings_information {
    my ($self, %args) = @_;
    my $include_disabled             = $args{include_disabled}             // 1;
    my $include_self                 = $args{include_self}                 // 1;
    my $exclude_disabled_no_currency = $args{exclude_disabled_no_currency} // 0;

    my $user = $self->user;
    # return empty if we are not able to find user, this should not
    # happen but added as additional check
    return {} unless $user;

    my @clients = $user->clients(include_disabled => $include_disabled);

    # filter out virtual clients
    @clients = grep { not $_->is_virtual } @clients;

    if ($exclude_disabled_no_currency) {
        # filter out disabled & no currency clients
        @clients = grep { not($_->status->disabled && !$_->default_account) } @clients;
    }

    my $siblings;
    foreach my $cl (@clients) {
        my $acc = $cl->default_account;

        $siblings->{$cl->loginid} = {
            loginid              => $cl->loginid,
            landing_company_name => $cl->landing_company->short,
            currency => $acc ? $acc->currency_code()                                        : '',
            balance  => $acc ? formatnumber('amount', $acc->currency_code(), $acc->balance) : "0.00",
            }
            unless (!$include_self && ($cl->loginid eq $self->loginid));
    }

    return $siblings;
}

sub is_tnc_approval_required {
    my $self = shift;

    return 0 if $self->is_virtual;
    return 0 unless $self->landing_company->tnc_required;

    my $current_tnc_version = BOM::Config::Runtime->instance->app_config->cgi->terms_conditions_version;
    my $client_tnc_status   = $self->status->tnc_approval;

    return 1 if (not $client_tnc_status or ($client_tnc_status->{reason} ne $current_tnc_version));

    return 0;
}

sub user_id {
    my $self = shift;
    return $self->binary_user_id // $self->user->{id};
}

sub status {
    my $self = shift;
    if (not $self->{status}) {
        $self->set_db('write') unless $self->get_db eq 'write';
        $self->{status} = BOM::User::Client::Status->new({
            client_loginid => $self->loginid,
            dbic           => $self->db->dbic
        });
    }

    return $self->{status};
}

sub is_pa_and_authenticated {
    my $self = shift;
    return 0 unless my $pa = $self->get_payment_agent();
    return $pa->is_authenticated ? 1 : 0;
}

sub is_same_user_as {
    my ($self, $other_client) = @_;

    return 0 unless $self;

    return 0 unless $other_client;

    return $self->binary_user_id == $other_client->binary_user_id ? 1 : 0;
}

=head2 get_mt5_details

returns hashref contains information we need for MT5 clients

=cut

sub get_mt5_details {
    my $self = shift;
    return {
        name    => $self->first_name . ' ' . $self->last_name,
        email   => $self->email,
        address => $self->address_1,
        phone   => $self->phone,
        state   => $self->state,
        city    => $self->city,
        zipCode => $self->postcode,
        country => Locale::Country::Extra->new()->country_from_code($self->residence),
    };
}

=head2 missing_requirements

Returns a list of missing entries of fields of a given requirement (defaults to signup requirement).

=cut

sub missing_requirements {
    my $self        = shift;
    my $requirement = shift // "signup";

    my $requirements = $self->landing_company->requirements->{$requirement};
    my @missing;

    for my $detail (@$requirements) {
        push(@missing, $detail) unless $self->$detail;
    }

    return @missing;
}

=head2 is_region_eu

return 1 or 0 according to client's landing company or the residence for VRT client.

=cut

sub is_region_eu {
    my ($self) = @_;

    if ($self->is_virtual) {

        my $countries_instance = request()->brand->countries_instance;
        my $company            = $countries_instance->real_company_for_country($self->residence);

        return LandingCompany::Registry->new->get($company)->is_eu;
    } else {
        return $self->landing_company->is_eu;
    }

}

=head2 get_open_contracts

Returns the list of open contracts for a given client

=cut

sub get_open_contracts {
    my $self = shift;

    return BOM::Database::ClientDB->new({
            client_loginid => $self->loginid,
            operation      => 'replica',
        })->getall_arrayref('select * from bet.get_open_bets_of_account(?,?,?)', [$self->loginid, $self->currency, 'false']);
}

=head2 increment_social_responsibility_values

Pass in an hashref and increment the social responsibility values in redis

=cut

sub increment_social_responsibility_values {
    my ($self, $sr_hashref) = @_;
    my $loginid = $self->loginid;

    my $hash_name  = 'social_responsibility';
    my $event_name = $loginid . '_sr_check';

    my $redis = BOM::Config::Redis::redis_events_write();

    foreach my $attribute (keys %$sr_hashref) {
        my $field_name = $loginid . '_' . $attribute;
        my $value      = $sr_hashref->{$attribute};

        $redis->hincrbyfloat($hash_name, $field_name, $value);
    }

    # This is only set once; there is no point to queue again and again
    # We only queue if the client is at low-risk only (low-risk means it is not in the hash)
    BOM::Platform::Event::Emitter::emit('social_responsibility_check', {loginid => $loginid})
        if (!$redis->get($loginid . '_sr_risk_status') && $redis->hsetnx($hash_name, $event_name, 1));

    return undef;
}

=head2 is_verification_required

Check if client needs account verifcation
(both proof of identity and proof of address)

=begin comment

These are the current regulations for when do we
need to ask client to submit proof of identity (POI)
and proof of address (POA)

    Labuan
      POI: Upon signup
      POA: Upon signup
    Vanuatu
      POI: Upon signup
      POA: Upon signup
    CR
      POI: High risk, withdrawals above 8k
      POA: High risk, withdrawals above 8k
    MF
      POI: Upon signup
      POA: Upon signup
    MLT
      POI: Upon first successful deposit
      POA: Upon first successful deposit
    MX
      POI: If ProveID fails or insufficient scores / high risk status
      POA: If ProveID fails or insufficient scores / high risk status

Currently both requirements are same so currently the sub has no
separate logic for them.

=end comment

=cut

sub is_verification_required {
    my ($self, %args) = @_;

    return 0 if $self->is_virtual;

    return 0 if $self->landing_company->skip_authentication;

    return 0 if $self->fully_authenticated and $self->status->age_verification;

    if ($args{check_authentication_status}) {
        return 1 if ($self->authentication_status // '') eq 'needs_action';
        return 1 if ($self->residence eq 'gb' and not $self->get_authentication('ID_ONLINE'));
    }

    # applicable for all landing companies
    return 1 if ($self->aml_risk_classification // '') eq 'high';

    return 1 if ($self->landing_company->short =~ /^(?:malta|iom)$/ and $self->residence ne 'gb' and $self->has_deposits());

    return 1 if ($self->residence eq 'gb' and not $self->status->age_verification and $self->status->unwelcome);

    return 1 if $self->landing_company->short eq 'maltainvest';

    # we need to check if mt5 group is for
    # labuan - regulated one, if yes then it needs authentication
    return 1 if $self->user->has_mt5_regulated_account();

    return 0;
}

=head2 is_document_expiry_check_required

Check if we need to validate for expired documents

=cut

sub is_document_expiry_check_required {
    my $self = shift;

    return 1 if $self->landing_company->documents_expiration_check_required();

    return 1 if ($self->aml_risk_classification // '') eq 'high';

    return 0;
}

=head2 is_document_expiry_check_required_mt5

Check if we need to validate for expired documents

In addition to is_document_expiry_check_required it
checks if user has mt5 regulated account

Separate sub is needed as don't want to block normal
cashier for client if they have mt5 regulated accounts

=cut

sub is_document_expiry_check_required_mt5 {
    my $self = shift;

    return 1 if $self->is_document_expiry_check_required();

    return 1 if $self->user->has_mt5_regulated_account();

    return 0;
}

=head2 increment_qualifying_payments

Pass in a hashref and increment the qualifying payment check values, which
is either deposit or withdrawals.

If no key is present, a new key is set with an expiry of 30 days (Regulation as at 14th August, 2019)
Otherwise, increment existing key

=cut

sub increment_qualifying_payments {
    my ($self, $args) = @_;
    my $loginid = $self->loginid;

    my $redis     = BOM::Config::Redis::redis_events();
    my $redis_key = $loginid . '_' . $args->{action} . '_qualifying_payment_check';

    my $payment_check_limits = BOM::Config::payment_limits()->{qualifying_payment_check_limits}->{$self->landing_company->short};

    if ($redis->exists($redis_key)) {
        # abs() is used, as withdrawal transactions have negative amount
        $redis->incrbyfloat($redis_key => abs($args->{amount}));
    } else {
        $redis->set(
            $redis_key => $args->{amount},
            EX         => 86400 * $payment_check_limits->{for_days});
    }

    my $event_name = $loginid . '_qualifying_payment_check';
    BOM::Platform::Event::Emitter::emit('qualifying_payment_check', {loginid => $loginid}) if $redis->setnx($event_name, 1);

    return undef;
}

=pod

=head2 format_input_details

format the input fields for new_account and set_settings and backoffice

=over 4

=item * $args

Hashref of the input fields

=back

Return {
    error   => C<error_code>
}

=cut

sub format_input_details {
    my ($self, $args) = @_;

    my %format = (
        first_name    => sub { trim(shift) },
        last_name     => sub { trim(shift) },
        phone         => sub { BOM::User::Phone::format_phone(shift) || die "InvalidPhone\n" },
        date_of_birth => sub {
            eval { Date::Utility->new(shift)->date } // die "InvalidDateOfBirth\n";
        },
    );

    try {
        $args->{$_} = $format{$_}->($args->{$_}) for grep { exists $format{$_} } keys %$args;
        return undef;
    } catch {
        chomp(my $err = $@);
        return {error => $err || 'UnknownError'};
    }
}

=pod

=head2 validate_common_account_details

common client details validation for new_account and set_settings and backoffice

=over 4

=item * $args

Hashref of the input fields

=back

Return {
    error   => C<error_code>
    details => C<detail info>
}

=cut

sub validate_common_account_details {
    my ($self, $args) = @_;

    my $residence = $self->residence;
    try {
        if ($args->{date_of_birth}) {
            _validate_dob($args->{date_of_birth}, $residence);
        }

        ## The secret question can start out as an empty string, but cannot be changed to empty
        die "Secret question cannot be set to empty\n"
            if (defined $args->{secret_question} && !$args->{secret_question} && length($self->secret_question));

        ## Likewise, it is possible for the secret_answer to be blank
        die "Secret answer cannot be set to empty\n"
            if (defined $args->{secret_answer} && !$args->{secret_answer} && length($self->secret_answer));

        ## Question must always come with an answer
        ## Due to the way we decrypt and send the answer to backoffice,
        ## it is common that secret_answer is set in $args but not the secret_question,
        ## so we do not want to check for that combination
        die "NeedBothSecret\n"
            if ($args->{secret_question} && !($args->{secret_answer} // ''));

        die "InvalidPlaceOfBirth\n" if ($args->{place_of_birth} and not Locale::Country::code2country($args->{place_of_birth}));

        my $brand = request()->brand;

        die "InvalidCitizenship\n"
            if ($args->{'citizen'} && !defined $brand->countries_instance->countries->country_from_code($args->{'citizen'}));

        ## If this is non-virtual United Kingdom account, it must have a postcode
        die "invalid UK postcode\n"
            if ($residence eq 'gb' and not $self->is_virtual and not($args->{address_postcode} // $self->address_postcode));

        # If not broker code is passed rely on current client landing company.
        # This is remarkably useful for new account calls.
        my $lc =
            (defined $args->{broker_code})
            ? LandingCompany::Registry->get_by_broker($args->{broker_code})
            : $self->landing_company;

        if ($lc->short =~ /^(?:iom|malta|maltainvest)$/) {
            die "invalid PO Box\n"
                if (($args->{address_line_1} || '') =~ /p[\.\s]+o[\.\s]+box/i
                or ($args->{address_line_2} || '') =~ /p[\.\s]+o[\.\s]+box/i);
        }

        die "No promotion code was provided\n" if (trim($args->{promo_code_status}) and not(trim($args->{promo_code}) // $self->promo_code));

        _validate_non_pep_time($args->{non_pep_declaration_time}) if $args->{non_pep_declaration_time};

        return undef;
    } catch {
        chomp(my $err = $@);

        return {error => $err || 'UnknownError'};
    }
}

sub _validate_dob {
    my ($dob, $residence) = @_;

    my $dob_date = eval { Date::Utility->new($dob) };
    die "InvalidDateOfBirth\n" unless $dob_date;

    my $countries_instance = request()->brand->countries_instance;

    # Get the minimum age from the client's residence
    my $min_age = $countries_instance && $countries_instance->minimum_age_for_country($residence);
    die "InvalidResidence\n" unless $min_age;

    my $minimum_date = Date::Utility->new->minus_time_interval($min_age . 'y');
    die "BelowMinimumAge\n" if $dob_date->is_after($minimum_date);

    return undef;
}

sub _validate_non_pep_time {
    my ($non_pep_time) = @_;

    my $non_pep_date = eval { Date::Utility->new($non_pep_time) };
    die "InvalidNonPepTime\n" unless $non_pep_date;

    die "TooLateNonPepTime\n" if $non_pep_date->epoch > time;

    return undef;
}

=pod

=head2 validate_fields_immutable

check if any fields_immutable is changed

=over 4

=item * $args

Hashref of the input fields

=back

Return {
    error   => C<error_code>
    details => C<field>
}

=cut

sub validate_fields_immutable {
    my ($self, $args) = @_;

    #fields not allow to change once been set
    my @fields_immutable =
        qw/place_of_birth date_of_birth salutation first_name last_name citizen account_opening_reason secret_answer secret_question tax_residence tax_identification_number/;

    for my $field (@fields_immutable) {
        #if the input field value is differnt from self setting, means it is been changed
        if ($args->{$field} and $self->$field and ($args->{$field} ne $self->$field)) {
            if ($self->landing_company->is_field_changeable_before_auth($field)) {
                return {
                    error   => 'NoChangeAfterAuth',
                    details => $field
                } if $self->fully_authenticated();
            } else {
                return {
                    error   => 'ImmutableField',
                    details => $field
                };
            }
        }
    }
    return undef;
}

=pod

=head2 check_duplicate_account

check if the input fields match any exists account

=over 4

=item * $args

Hashref of the input fields

=back

Return undef if there is not need to check for duplicate account or if there is no duplicate account found for the given user information

Return {
    error   => C<error_code>
    details => C<dup_account_details>
}

=cut

sub check_duplicate_account {
    my ($self, $args) = @_;

    # Get target broker code either from $args or client itself
    my $target_broker = $args->{broker_code} // $self->broker_code;

    # If client is going to update his virtual account there is no need to check for duplicate account
    return undef if $target_broker =~ BOM::User::VIRTUAL_REGEX();

    my $checks = ['first_name', 'last_name', 'date_of_birth'];

    if (any { $args->{$_} and defined $self->$_ and $args->{$_} ne $self->$_ } @$checks) {
        my $dup_details = {
            email          => $self->email,
            exclude_status => ['duplicate_account']};
        $dup_details->{$_} = $args->{$_} || $self->$_ for @$checks;

        my @dup_account_details = BOM::Database::ClientDB->new({broker_code => $target_broker})->get_duplicate_client($dup_details);
        return {
            error   => 'DuplicateAccount',
            details => \@dup_account_details
        } if scalar @dup_account_details;

    }
    return undef;
}

=head1 METHODS - P2P cashier

=cut

use constant {
    # For some currency pairs we need to have limit so big for example: VND/BTC
    # Also this limit may need to be adjusted in future.
    P2P_RATE_LOWER_LIMIT => 0.000001,    # We need it because 0.000001 < 0.1**6 is true
    P2P_RATE_UPPER_LIMIT => 10**9,
    P2P_RATE_PRECISION   => 6,

    P2P_MAXIMUM_ACTIVE_ADVERTS     => 10,
    P2P_COUNTERYPARTY_TYPE_MAPPING => {
        buy  => 'sell',
        sell => 'buy',
    },
    P2P_STATS_REDIS_PREFIX => 'P2P::ADVERTISER_STATS',
    P2P_STATS_TTL_IN_DAYS  => 120,                       # days after which to prune redis stats
};

=head2 p2p_advertiser_create

Attempts to register client as an advertiser.
Returns the advertiser info or dies with error code.

=cut

sub p2p_advertiser_create {
    my ($self, %param) = @_;

    die +{error_code => 'AlreadyRegistered'} if $self->_p2p_advertisers(loginid => $self->loginid)->[0];

    my $name = trim($param{name});
    die +{error_code => 'AdvertiserNameRequired'} unless $name;
    die +{error_code => 'AdvertiserNameTaken'} if $self->_p2p_advertisers(unique_name => $name)->[0];

    my ($id) = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_array("SELECT nextval('p2p.advertiser_serial')");
        });

    my $sb_api     = BOM::User::Utility::sendbird_api();
    my $sb_user_id = join '_', 'p2puser', $self->broker_code, $id, time;
    my $sb_user;
    try {
        $sb_user = $sb_api->create_user(
            user_id             => $sb_user_id,
            nickname            => $name,
            profile_url         => '',
            issue_session_token => 'true'
        );
    } catch {
        die +{error_code => 'AdvertiserCreateChatError'};
    }

    # sb api returns milliseconds timestamps
    my ($token, $expiry) = ($sb_user->session_tokens->[0]{session_token}, int($sb_user->session_tokens->[0]{expires_at} / 1000));

    my $advertiser = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref(
                'SELECT * FROM p2p.advertiser_create(?, ?, ?, ?, ?, ?, ?, ?, ?)',
                undef,             $id,    $self->loginid, $name, @param{qw/default_advert_description payment_info contact_info/},
                $sb_user->user_id, $token, $expiry
            );
        });

    unless ($self->status->age_verification or $self->status->allow_document_upload) {
        $self->status->set('allow_document_upload', 'system', 'P2P_ADVERTISER_CREATED');
    }

    my $details = $self->_advertiser_details($advertiser);

    BOM::Platform::Event::Emitter::emit(
        p2p_advertiser_created => {
            client_loginid => $self->loginid,
            $details->%*
        });

    return $details;
}

=head2 p2p_advertiser_info

Returns advertiser info of param{id} otherwise current client.

=cut

sub p2p_advertiser_info {
    my ($self, %param) = @_;

    my $advertiser;
    if (exists $param{id}) {
        $advertiser = $self->_p2p_advertisers(id => $param{id})->[0];
    } else {
        $advertiser = $self->_p2p_advertisers(loginid => $self->loginid)->[0];
    }

    return unless $advertiser;
    return $self->_advertiser_details($advertiser);
}

=head2 p2p_advertiser_update

Updates the client advertiser info with fields in %param.
Returns latest advertiser info.

=cut

sub p2p_advertiser_update {
    my ($self, %param) = @_;

    my $advertiser_info = $self->p2p_advertiser_info;
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;
    die +{error_code => 'AdvertiserNotApproved'}   unless $advertiser_info->{is_approved} or defined $param{is_approved};

    if (exists $param{name}) {
        $param{name} = trim($param{name});
        die +{error_code => 'AdvertiserNameRequired'} unless $param{name};
        die +{error_code => 'AdvertiserNameTaken'}
            if $param{name} ne $advertiser_info->{name} and $self->_p2p_advertisers(name => $param{name})->[0];
    }

    die +{error_code => 'AdvertiserCannotListAds'} if $param{is_listed} and not $advertiser_info->{is_approved} and not $param{is_approved};
    $param{is_listed} = 0 if defined $param{is_approved} and not $param{is_approved};

    # Return the current information of the advertiser if nothing changed
    return $advertiser_info unless grep { exists $advertiser_info->{$_} and $param{$_} ne $advertiser_info->{$_} } keys %param;

    my $update = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref(
                'SELECT * FROM p2p.advertiser_update(?, ?, ?, ?, ?, ?, ?, NULL, NULL, NULL)',
                undef,
                $advertiser_info->{id},
                @param{qw/is_approved is_listed name default_advert_description payment_info contact_info/});
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_advertiser_updated => {
            client_loginid => $self->loginid,
        },
    );

    return $self->_advertiser_details($update);
}

=head2 p2p_advertiser_adverts

Returns a list of adverts belonging to current client

=cut

sub p2p_advertiser_adverts {
    my ($self, %param) = @_;

    my $advertiser_info = $self->_p2p_advertisers(loginid => $self->loginid)->[0];
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;

    my $list = $self->_p2p_adverts(%param, advertiser_id => $advertiser_info->{id});
    return $self->_advert_details($list);
}

=head2 p2p_advertiser_stats

Returns statistics of a P2P user.

Example usage:

    $self->p2p_advertiser_stats(id=>1, days=>30);

Takes the following arguments as named parameters:

=over 4

=item * C<id> - advertiser id. Defaults to $self->p2p_advertiser_info->{id}.

=item * C<days> - number of days to aggregrate statistics. Default: 30.

=back

Returns a hashref.

=cut

sub p2p_advertiser_stats {
    my ($self, %param) = @_;

    my $advertiser;
    if (exists $param{id}) {
        $advertiser = $self->_p2p_advertisers(id => $param{id})->[0];
        die +{error_code => 'AdvertiserNotFound'} unless $advertiser;
    } else {
        $advertiser = $self->_p2p_advertisers(loginid => $self->loginid)->[0];
        die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser;
    }

    $param{days} //= 30;
    return $self->_p2p_advertiser_stats_get($advertiser->{client_loginid}, $param{days});
}

=head2 p2p_advert_create

Creates an advert with %param with client as advertiser.
Returns new advert or dies with error code.

=cut

sub p2p_advert_create {
    my ($self, %param) = @_;

    my $advertiser_info = $self->_p2p_advertisers(loginid => $self->loginid)->[0];
    die +{error_code => 'AdvertiserNotRegistered'} unless $advertiser_info;
    die +{error_code => 'AdvertiserNotApproved'}   unless $advertiser_info->{is_approved};

    $param{country}          = $self->residence;
    $param{account_currency} = $self->currency;

    _validate_advert_amounts(%param);

    my $active_adverts_count = $self->_p2p_adverts(
        advertiser_id => $advertiser_info->{id},
        is_active     => 1,
    )->@*;
    die +{error_code => 'AdvertMaxExceeded'} if $active_adverts_count >= P2P_MAXIMUM_ACTIVE_ADVERTS;

    $param{local_currency} //= $self->local_currency || die +{error_code => 'NoLocalCurrency'};

    if ($param{rate} < P2P_RATE_LOWER_LIMIT) {
        die +{
            error_code     => 'RateTooSmall',
            message_params => [sprintf('%.' . P2P_RATE_PRECISION . 'f', P2P_RATE_LOWER_LIMIT)]};
    }

    if ($param{rate} > P2P_RATE_UPPER_LIMIT) {
        die +{
            error_code     => 'RateTooBig',
            message_params => [sprintf('%.02f', P2P_RATE_UPPER_LIMIT)],
        };
    }

    my $min_price = $param{rate} * $param{min_order_amount};
    if (financialrounding('amount', $param{local_currency}, $min_price) == 0) {
        die +{
            error_code     => 'MinPriceTooSmall',
            message_params => [0]};
    }

    die +{error_code => 'AdvertPaymentContactInfoNotAllowed'}
        if $param{type} eq 'buy' && (trim($param{payment_info}) || trim($param{contact_info}));

    die +{error_code => 'AdvertPaymentInfoRequired'}
        if $param{type} eq 'sell' && !trim($param{payment_info});

    die +{error_code => 'AdvertContactInfoRequired'}
        if $param{type} eq 'sell' && !trim($param{contact_info});

    my $advert = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref(
                'SELECT * FROM p2p.advert_create(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                undef,
                $advertiser_info->{id},
                @param{
                    qw/type account_currency local_currency country amount rate min_order_amount max_order_amount description payment_method payment_info contact_info/
                });
        });

    return $self->_advert_details([$advert])->[0];
}

=head2 p2p_advert_info

Get a single advert by $id.

=cut

sub p2p_advert_info {
    my ($self, %param) = @_;
    my $id   = $param{id} // return;
    my $list = $self->_p2p_adverts(id => $id);
    return $self->_advert_details($list, undef, 1)->[0];
}

=head2 p2p_advert_list

Get adverts for client view.
Inactive adverts, unlisted or unapproved advertisers, and max < min are excluded.

=cut

sub p2p_advert_list {
    my ($self, %param) = @_;

    if ($param{counterparty_type}) {
        $param{type} = P2P_COUNTERYPARTY_TYPE_MAPPING->{$param{counterparty_type}};
    }

    my $list = $self->_p2p_adverts(
        %param,
        is_active              => 1,
        can_order              => 1,
        advertiser_is_approved => 1,
        advertiser_is_listed   => 1,
        country                => $self->residence,
        account_currency       => $self->currency,
    );
    return $self->_advert_details($list, $param{amount}, 1);
}

=head2 p2p_advert_update

Updates the advert of $param{id} with fields in %param.
Client must be advert owner.
Cannot delete if there are open orders.
Returns latest advert info or dies with error code.

=cut

sub p2p_advert_update {
    my ($self, %param) = @_;
    my $id          = delete $param{id}                   or die +{error_code => 'AdvertNotFound'};
    my $advert_info = $self->_p2p_adverts(id => $id)->[0] or die +{error_code => 'AdvertNotFound'};

    die +{error_code => 'PermissionDenied'} if $advert_info->{advertiser_loginid} ne $self->loginid;

    # return current advert details if nothing changed
    unless ($param{delete} or grep { exists $advert_info->{$_} and $param{$_} ne $advert_info->{$_} } keys %param) {
        delete $advert_info->{max_order_amount_actual};    # not relevant for advertiser
        return $self->_advert_details([$advert_info])->[0];
    }

    if ($param{delete}) {
        my $open_orders = $self->_p2p_orders(
            advert_id => $id,
            status    => ['pending', 'buyer-confirmed', 'timed-out'],
        );
        die +{error_code => 'OpenOrdersDeleteAdvert'} if @$open_orders;
    }

    my $update = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.advert_update(?, ?, ?, ?, ?, ?, ?)',
                undef, $id, @param{qw/is_active delete description payment_method payment_info contact_info/});
        });

    return $self->_advert_details([$update])->[0];
}

=head2 p2p_order_create

Creates an order for advert $param{advert_id} with %param for client.
Advert must be active. Advertiser must be active and authenticated.
Only one active order per advert per client is allowed.
Returns new order or dies with error code.
This will move funds from advertiser to escrow.

=cut

sub p2p_order_create {
    my ($self, %param) = @_;

    my ($advert_id, $amount, $expiry, $payment_info, $contact_info, $source) = @param{qw/advert_id amount expiry payment_info contact_info source/};

    my $client_info = $self->_p2p_advertisers(loginid => $self->loginid)->[0];
    die +{error_code => 'AdvertiserNotFoundForOrder'}    unless $client_info;
    die +{error_code => 'AdvertiserNotApprovedForOrder'} unless $client_info->{is_approved};

    my $p2p_config = BOM::Config::Runtime->instance->app_config->payments->p2p;
    $expiry //= $p2p_config->order_timeout;
    my $limit_per_day_per_client = $p2p_config->limits->count_per_day_per_client;

    my ($day_order_count) = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_array('SELECT * FROM p2p.client_orders_created(?)', undef, $self->loginid);
        });

    die +{
        error_code     => 'ClientDailyOrderLimitExceeded',
        message_params => [$limit_per_day_per_client]}
        if ($day_order_count // 0) >= $limit_per_day_per_client;

    my $advert_info = $self->_p2p_adverts(
        id                     => $advert_id,
        is_active              => 1,
        can_order              => 1,
        advertiser_is_approved => 1,
        advertiser_is_listed   => 1,
        country                => $self->residence,
        account_currency       => $self->currency
    )->[0];

    die +{error_code => 'AdvertNotFound'} unless $advert_info;
    die +{error_code => 'InvalidAdvertOwn'} if $advert_info->{advertiser_loginid} eq $self->loginid;

    die +{
        error_code => 'OrderMaximumExceeded',
        message_params =>
            [$advert_info->{account_currency}, formatnumber('amount', $advert_info->{account_currency}, $advert_info->{max_order_amount_actual}),]}
        if $amount > $advert_info->{max_order_amount_actual};

    die +{
        error_code => 'OrderMinimumNotMet',
        message_params =>
            [$advert_info->{account_currency}, formatnumber('amount', $advert_info->{account_currency}, $advert_info->{min_order_amount}),]}
        if $amount < ($advert_info->{min_order_amount} // 0);

    my $advert_type = $advert_info->{type};

    my $advertiser_info = $self->_p2p_advertisers(id => $advert_info->{advertiser_id})->[0];

    my $limit_remaining = $advertiser_info->{'daily_' . $advert_type . '_limit'} - $advertiser_info->{'daily_' . $advert_type};
    die +{
        error_code     => 'OrderMaximumTempExceeded',
        message_params => [$advert_info->{account_currency}, formatnumber('amount', $advert_info->{account_currency}, $limit_remaining),]}
        if $amount > $limit_remaining;

    my ($order_type, $amount_advertiser, $amount_client);

    if ($advert_type eq 'buy') {
        $order_type = 'sell';
        die +{error_code => 'OrderPaymentInfoRequired'} if !trim($param{payment_info});
        die +{error_code => 'OrderContactInfoRequired'} if !trim($param{contact_info});
        $amount_advertiser = $amount;
        $amount_client     = -$amount;
    } elsif ($advert_type eq 'sell') {
        $order_type = 'buy';
        die +{error_code => 'OrderPaymentContactInfoNotAllowed'} if $payment_info or $contact_info;
        ($payment_info, $contact_info) = $advert_info->@{qw/payment_info contact_info/};
        $amount_advertiser = -$amount;
        $amount_client     = $amount;
    } else {
        die 'Invalid advert type ' . ($advert_type // 'undef') . ' for advert ' . $advert_info->{id};
    }

    try {
        $self->validate_payment(
            amount   => $amount_client,
            currency => $advert_info->{account_currency});
    } catch {
        chomp($@);
        die +{
            error_code     => 'OrderCreateFailClient',
            message_params => [$@],
        };
    }

    my $advertiser = BOM::User::Client->new({loginid => $advertiser_info->{client_loginid}});
    try {
        $advertiser->validate_payment(
            amount   => $amount_advertiser,
            currency => $advert_info->{account_currency});
    } catch {
        die +{
            error_code => 'OrderCreateFailAdvertiser',
        };
    }

    my $client_ad_info = $self->_p2p_advertisers(loginid => $self->loginid)->[0];
    if ($client_ad_info) {
        # For client inverted advert type needs to be checked, for example in a sell advert, client is buyer, so we need to check their daily_buy_limit
        my $client_limit_remaining = $client_ad_info->{'daily_' . $order_type . '_limit'} - $client_ad_info->{'daily_' . $order_type};
        die +{
            error_code => 'OrderMaximumTempExceeded',
            message_params =>
                [$client_ad_info->{account_currency}, formatnumber('amount', $client_ad_info->{account_currency}, $client_limit_remaining),]}
            if $amount > $client_limit_remaining;
    }

    my $escrow = $self->p2p_escrow;

    die +{error_code => 'EscrowNotFound'} unless $escrow;

    my $open_orders = $self->_p2p_orders(
        advert_id => $advert_id,
        loginid   => $self->loginid,
        status    => ['pending', 'buyer-confirmed'],
    );

    die +{error_code => 'OrderAlreadyExists'} if @{$open_orders};

    my $txn_time = Date::Utility->new->datetime;
    my $order    = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_create(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                undef, $advert_id, $self->loginid, $escrow->loginid, $amount, $expiry, $payment_info, $contact_info, $source, $self->loginid,
                $limit_per_day_per_client, $txn_time);
        });

    $self->_p2p_order_stats_record('ORDER_CREATED', $order);

    BOM::Platform::Event::Emitter::emit(
        p2p_order_created => {
            client_loginid => $self->loginid,
            order_id       => $order->{id},
        });

    return $self->_order_details([$order])->[0];
}

=head2 p2p_order_info

Return a single order of $param{id}

=cut

sub p2p_order_info {
    my ($self, %param) = @_;

    my $id = $param{id} // return;

    # ensure client can only see their orders
    my $list = $self->_p2p_orders(
        id      => $id,
        loginid => $self->loginid
    );
    return $self->_order_details($list)->[0];
}

=head2 p2p_order_list

Get orders filtered by %param.

=cut

sub p2p_order_list {
    my ($self, %param) = @_;

    $param{loginid} = $self->loginid;
    $param{status} =
        $param{active}
        ? ['pending',   'buyer-confirmed', 'timed-out']
        : ['completed', 'cancelled',       'refunded']
        if exists $param{active};

    my $list = $self->_p2p_orders(%param);
    return $self->_order_details($list);
}

=head2 p2p_order_confirm

Confirms the order of $param{id} and returns updated order.
Client = client, type = buy: order is buyer-confirmed
Client = client, type = sell: order is completed
Client = advertiser, type = buy: order is completed
Client = advertiser, type = sell: order is buyer-confirmed
Otherwise dies with error code.

=cut

sub p2p_order_confirm {
    my ($self, %param) = @_;
    my $id         = $param{id} // die +{error_code => 'OrderNotFound'};
    my $order_info = $self->_p2p_orders(id => $id)->[0];
    die +{error_code => 'OrderNotFound'} unless $order_info;

    my $ownership_type = _order_ownership_type($self, $order_info);
    my $method         = $self->can('_p2p_' . $ownership_type . '_' . $order_info->{type} . '_confirm');
    die +{error_code => 'PermissionDenied'} unless $method;

    my $update = $self->$method($order_info, $param{source});

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $id,
            order_event    => 'confirmed',
        });

    return $update;
}

=head2 p2p_order_cancel

Cancels the order of $param{id}.
Order must belong to the buyer.
Order must be in pending status.
This will move funds from escrow to seller.

=cut

sub p2p_order_cancel {
    my ($self, %param) = @_;
    my $id    = $param{id} // die +{error_code => 'OrderNotFound'};
    my $order = $self->_p2p_orders(id => $id)->[0];

    die +{error_code => 'OrderNotFound'} unless $order;
    die +{error_code => 'OrderNoEditExpired'}    if $order->{is_expired};
    die +{error_code => 'OrderAlreadyCancelled'} if $order->{status} eq 'cancelled';

    my $ownership_type = _order_ownership_type($self, $order);

    die +{error_code => 'PermissionDenied'}
        unless ($ownership_type eq 'client' and $order->{type} eq 'buy')
        or ($ownership_type eq 'advertiser' and $order->{type} eq 'sell');
    die +{error_code => 'PermissionDenied'} unless $order->{status} eq 'pending';

    my $escrow      = $self->p2p_escrow;
    my $is_refunded = 0;                   # order will have cancelled status

    my $txn_time = Date::Utility->new->datetime;

    my $update = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_refund(?, ?, ?, ?, ?, ?)',
                undef, $id, $escrow->loginid, $param{source}, $self->loginid, $is_refunded, $txn_time);
        });

    $self->_p2p_order_stats_record('ORDER_REFUNDED', $update);

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $id,
            order_event    => 'cancelled',
        });

    return $update;
}

=head2 p2p_chat_create

Creates a sendbird chat channel for an order, and users if required.
Both clients of the order must be P2P advertisers.

=cut

sub p2p_chat_create {
    my ($self, %param) = @_;

    my $order_id = $param{order_id}                         // die +{error_code => 'OrderNotFound'};
    my $order    = $self->_p2p_orders(id => $order_id)->[0] // die +{error_code => 'OrderNotFound'};

    my $counterparty_loginid;
    if ($order->{advertiser_loginid} eq $self->loginid) {
        $counterparty_loginid = $order->{client_loginid};
    } elsif ($order->{client_loginid} eq $self->loginid) {
        $counterparty_loginid = $order->{advertiser_loginid};
    } else {
        die +{error_code => 'PermissionDenied'};
    }

    die +{error_code => 'OrderChatAlreadyCreated'} if $order->{chat_channel_url};
    my $advertiser_info = $self->_p2p_advertisers(loginid => $self->loginid)->[0] // die +{error_code => 'AdvertiserNotFoundForChat'};

    my $counterparty_advertiser = $self->_p2p_advertisers(loginid => $counterparty_loginid)->[0]
        // die +{error_code => 'CounterpartyNotAdvertiserForChat'};

    my $sb_api     = BOM::User::Utility::sendbird_api();
    my $sb_channel = join '_', ('p2porder', $self->broker_code, $order_id, time);

    my $sb_chat;
    try {
        $sb_chat = $sb_api->create_group_chat(
            channel_url => $sb_channel,
            user_ids    => [$advertiser_info->{chat_user_id}, $counterparty_advertiser->{chat_user_id}],
            name        => 'Chat about order ' . $order_id,
        );
    } catch {
        die +{error_code => 'CreateChatError'};
    }

    $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_update(?, ?, ?)', undef, $order_id, undef, $sb_chat->channel_url);
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_order_updated => {
            client_loginid => $self->loginid,
            order_id       => $order_id,
            order_event    => 'chat_created',
        });

    return {
        channel_url => $sb_chat->channel_url,
        order_id    => $order_id,
    };
}

=head2 p2p_chat_token

Returns sendbird session token.
Creates one if it doesn't exist or has expired.

=cut

sub p2p_chat_token {
    my ($self) = @_;

    my $advertiser_info = $self->_p2p_advertisers(loginid => $self->loginid)->[0] // die +{error_code => 'AdvertiserNotFoundForChatToken'};
    my $sendbird_api    = BOM::User::Utility::sendbird_api();

    my ($token, $expiry) = $advertiser_info->@{qw(chat_token chat_token_expiry)};
    if ($token and $expiry and ($expiry - time) >= P2P_TOKEN_MIN_EXPIRY) {
        return {
            token       => $token,
            expiry_time => $expiry,
            app_id      => $sendbird_api->app_id,
        };
    } else {
        my $sb_user = WebService::SendBird::User->new(
            user_id    => $advertiser_info->{chat_user_id},
            api_client => $sendbird_api
        );
        try {
            ($token, $expiry) = $sb_user->issue_session_token()->@{qw(session_token expires_at)};
        } catch {
            die +{error_code => 'ChatTokenError'};
        }
    }

    $expiry = int($expiry / 1000);    # sb api returns milliseconds timestamps

    $self->db->dbic->run(
        fixup => sub {
            $_->do(
                'SELECT * FROM p2p.advertiser_update(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                undef, $advertiser_info->{id},
                undef, undef, undef, undef, undef, undef, undef, $token, $expiry
            );
        });

    BOM::Platform::Event::Emitter::emit(
        p2p_advertiser_updated => {
            client_loginid => $self->loginid,
        },
    );

    return {
        token       => $token,
        expiry_time => $expiry,
        app_id      => $sendbird_api->app_id,
    };
}

=head2 p2p_escrow

Gets the configured escrow account for clients currency and landing company.

=cut

sub p2p_escrow {
    my ($self) = @_;
    my ($broker, $currency) = ($self->broker_code, $self->currency);
    my @escrow_list = BOM::Config::Runtime->instance->app_config->payments->p2p->escrow->@*;

    foreach my $loginid (@escrow_list) {
        try {
            my $escrow = BOM::User::Client->new({loginid => $loginid});

            return $escrow if $escrow && $escrow->broker eq $broker && $escrow->currency eq $currency;
        } catch {
            next;    # TODO: ideally, we should never have an error here, we should maybe log it?
        }
    }

    return undef;
}

=head1 Non-RPC P2P methods

The methods below are not called by RPC and, therefore, they are not needed to die in the 'P2P way'.

=head2 p2p_timeout_refund

Moves back the funds to the seller.
The order should be in the state C<timed-out> and at least 30 days (by default but configurable) should have passed since C<expire_time>.

It takes a hash argument as:

=over 4

=item * C<id>: the id of the order

=item * C<source>: the calling source

=item * C<staff>: the calling staff

=back

Returns, the order itself with updated status C<refunded> on success, otherwise an exception is thrown.

=cut

sub p2p_timeout_refund {
    my ($self, %param) = @_;

    my $id          = $param{id} // die "no id provided to p2p_timeout_refund";
    my $order       = $self->_p2p_orders(id => $id)->[0];
    my $days_needed = BOM::Config::Runtime->instance->app_config->payments->p2p->refund_timeout;

    # Note for non-rpc methods we don't craft the P2P error object
    die sprintf('P2P Order not found: %d',     $id) unless $order;
    die sprintf('Cannot refund P2P order: %d', $id) unless $order->{status} eq 'timed-out';

    my $expire_time = Date::Utility->new($order->{expire_time});
    # There are 86,400 seconds in a day
    # Check whether we've reached the days required to move the funds back
    die sprintf('P2P Order is not ready to refund: %d', $id) if Date::Utility::days_between(Date::Utility->new, $expire_time) < $days_needed;

    my $escrow = $self->p2p_escrow;
    die 'Escrow not found' unless $escrow;

    my $txn_time = Date::Utility->new->datetime;
    $self->db->dbic->txn(
        fixup => sub {
            $_->do('SELECT p2p.order_refund(?, ?, ?, ?, ?, ?)', undef, $order->{id}, $escrow->loginid, $param{source}, $param{staff}, 1, $txn_time);
        });

    return $self->_p2p_orders(id => $id)->[0];
}

=head2 p2p_expire_order

Expire order in different states.
Method returns order data in case if state of order was changed.

=cut

sub p2p_expire_order {
    my ($self, %param) = @_;

    my $id    = $param{id} // die "no id provided to p2p_expire_order";
    my $order = $self->_p2p_orders(id => $id)->[0];
    die +{error_code => 'OrderNotFound'} unless $order;

    my $status = $order->{status};

    if ($status eq 'pending') {
        my $escrow = $self->p2p_escrow;
        die +{error_code => 'EscrowNotFound'} unless $escrow;

        my $txn_time    = Date::Utility->new->datetime;
        my $is_refunded = 1;                              # order will have refunded status

        my $result = $self->db->dbic->txn(
            fixup => sub {
                $_->selectrow_hashref('SELECT * FROM p2p.order_refund(?, ?, ?, ?, ?, ?)',
                    undef, $order->{id}, $escrow->loginid, $param{source}, $param{staff}, $is_refunded, $txn_time);
            });
        $self->_p2p_order_stats_record('ORDER_REFUNDED', $result);
        return $result;
    } elsif ($status eq 'buyer-confirmed') {
        return $self->db->dbic->run(
            fixup => sub {
                $_->selectrow_hashref('SELECT * FROM p2p.order_update(?, ?, ?)', undef, $id, 'timed-out', undef);
            });
    }
}

=head1 Private P2P methods

=head2 _p2p_advertisers

Returns a list of advertisers filtered by id and/or loginid.

=cut

sub _p2p_advertisers {
    my ($self, %param) = @_;

    my $advertisers = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref('SELECT * FROM p2p.advertiser_list(?, ?, ?, ?)', {Slice => {}}, @param{qw/id loginid name unique_name/});
        });

    for my $item (@$advertisers) {
        $item->{daily_buy_limit}  = convert_currency($item->{daily_buy_limit},  $item->{limit_currency}, $item->{account_currency});
        $item->{daily_sell_limit} = convert_currency($item->{daily_sell_limit}, $item->{limit_currency}, $item->{account_currency});
    }
    return $advertisers;
}

=head2 _p2p_adverts

Gets adverts from DB

=cut

sub _p2p_adverts {
    my ($self, %param) = @_;

    my ($limit, $offset) = @param{qw/limit offset/};
    die +{error_code => 'InvalidListLimit'}  if defined $limit  && $limit <= 0;
    die +{error_code => 'InvalidListOffset'} if defined $offset && $offset < 0;

    $param{client_loginid} = $self->loginid;
    $param{max_order} = convert_currency(BOM::Config::Runtime->instance->app_config->payments->p2p->limits->maximum_order, 'USD', $self->currency);

    $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(
                'SELECT * FROM p2p.advert_list(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                {Slice => {}},
                @param{
                    qw/id account_currency advertiser_id is_active type country can_order max_order advertiser_is_listed advertiser_is_approved client_loginid limit offset/
                });
        }) // [];
}

=head2 _p2p_orders

Gets orders from DB.
$param{loginid} will match on advert advertiser loginid or order client loginid.
$param{status} if provided must by an arrayref.

=cut

sub _p2p_orders {
    my ($self, %param) = @_;

    croak 'Invalid status format'
        if defined $param{status}
        && ref $param{status} ne 'ARRAY';

    my ($limit, $offset) = @param{qw/limit offset/};
    die +{error_code => 'InvalidListLimit'}  if defined $limit  && $limit <= 0;
    die +{error_code => 'InvalidListOffset'} if defined $offset && $offset < 0;

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(
                'SELECT * FROM p2p.order_list(?, ?, ?, ?, ?, ?)',
                {Slice => {}},
                @param{qw/id advert_id loginid status limit offset/});
        }) // [];
}

=head2 _order_ownership_type

Returns whether client is the buyer or seller of the order.

=cut

sub _order_ownership_type {
    my ($self, $order_info) = @_;

    return 'client' if $order_info->{client_loginid} eq $self->loginid;

    return 'advertiser' if $order_info->{advertiser_loginid} eq $self->loginid;

    return '';
}

=head2 _p2p_client_buy_confirm

Sets order client confirmed = true and status = buyer-confirmed.

Takes a single argument:

=over 4

=item * C<order> - an order as returned from L<_p2p_orders>

=back

Returns a hashref of the row returned by the final db function.

=cut

sub _p2p_client_buy_confirm {
    my ($self, $order) = @_;

    # $self is the buyer
    $self->_p2p_validate_buyer_confirm($order);

    my $result = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_confirm_client(?, ?)', undef, $order->{id}, 1);
        });
    $self->_p2p_order_stats_record('BUY_CONFIRM', $result);
    return $result;
}

=head2 _p2p_advertiser_buy_confirm

Sets order advertiser_confirmed = true and completes the order in a single transaction.
Completing the order moves funds from escrow to order client.

Takes a single argument:

=over 4

=item * C<order> - an order as returned from L<_p2p_orders>

=back

Returns a hashref of the row returned by the final db function.

=cut

sub _p2p_advertiser_buy_confirm {
    my ($self, $order, $source) = @_;

    # $self is the seller
    $self->_p2p_validate_seller_confirm($order);

    my $escrow   = $self->p2p_escrow;
    my $txn_time = Date::Utility->new->datetime;
    my $result   = $self->db->dbic->txn(
        fixup => sub {
            $_->do('SELECT * FROM p2p.order_confirm_advertiser(?, ?)', undef, $order->{id}, 1);
            return $_->selectrow_hashref('SELECT * FROM p2p.order_complete(?, ?, ?, ?, ?)',
                undef, $order->{id}, $escrow->loginid, $source, $self->loginid, $txn_time);
        });
    $self->_p2p_order_stats_record('ORDER_COMPLETED', $result);
    return $result;
}

=head2 _p2p_client_sell_confirm

Sets order client_confirmed = true and completes the order in a single transaction.
Completing the order moves funds from escrow to advertiser.

Takes a single argument:

=over 4

=item * C<order> - an order as returned from L<_p2p_orders>

=back

Returns a hashref of the row returned by the final db function.

=cut

sub _p2p_client_sell_confirm {
    my ($self, $order, $source) = @_;

    # $self is the seller
    $self->_p2p_validate_seller_confirm($order);

    my $escrow   = $self->p2p_escrow;
    my $txn_time = Date::Utility->new->datetime;

    my $result = $self->db->dbic->txn(
        fixup => sub {
            $_->do('SELECT * FROM p2p.order_confirm_client(?, ?)', undef, $order->{id}, 1);
            return $_->selectrow_hashref('SELECT * FROM p2p.order_complete(?, ?, ?, ?, ?)',
                undef, $order->{id}, $escrow->loginid, $source, $self->loginid, $txn_time);
        });
    $self->_p2p_order_stats_record('ORDER_COMPLETED', $result);
    return $result;
}

=head2 _p2p_advertiser_sell_confirm

Sets order advertiser confirmed = true and status = buyer-confirmed.

Takes a single argument:

=over 4

=item * C<order> - an order as returned from L<_p2p_orders>

=back

Returns a hashref of the row returned by the final db function.

=cut

sub _p2p_advertiser_sell_confirm {
    my ($self, $order) = @_;

    # $self is the buyer
    $self->_p2p_validate_buyer_confirm($order);

    my $result = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref('SELECT * FROM p2p.order_confirm_advertiser(?, ?)', undef, $order->{id}, 1);
        });
    $self->_p2p_order_stats_record('BUY_CONFIRM', $result);
    return $result;
}

=head2 _p2p_validate_buyer_confirm

Validates if order can be confirmed by client as a buyer.
Throws an error hashref if cannot.

Takes a single argument:

=over 4

=item * C<order> - an order as returned from L<_p2p_orders>

=back

Returns nothing.

=cut

sub _p2p_validate_buyer_confirm {
    my ($self, $order) = @_;

    die +{error_code => 'OrderAlreadyConfirmedBuyer'}    if $order->{status} eq 'buyer-confirmed';
    die +{error_code => 'OrderAlreadyConfirmedTimedout'} if $order->{status} eq 'timed-out';
    die +{error_code => 'OrderConfirmCompleted'}         if $order->{status} ne 'pending';

    return;
}

=head2 _p2p_validate_seller_confirm

Validates if order can be confirmed by client as a seller.
Throws an error hashref if cannot.

Takes a single argument:

=over 4

=item * C<order> - an order as returned from L<_p2p_orders>

=back

Returns nothing.

=cut

sub _p2p_validate_seller_confirm {
    my ($self, $order) = @_;

    die +{error_code => 'OrderNotConfirmedPending'} if $order->{status} eq 'pending';
    die +{error_code => 'OrderConfirmCompleted'}    if $order->{status} !~ /^(buyer-confirmed|timed-out)$/;

    return;
}

=head2 _advertiser_details

Prepares advertiser fields for client display.
Takes and returns single advertiser.

=cut

sub _advertiser_details {
    my ($self, $advertiser) = @_;

    my $stats_days = 30;    # days for stats, per websocket fields description

    my $details = {
        id                         => $advertiser->{id},
        name                       => $advertiser->{name},
        created_time               => Date::Utility->new($advertiser->{created_time})->epoch,
        is_approved                => $advertiser->{is_approved},
        is_listed                  => $advertiser->{is_listed},
        default_advert_description => $advertiser->{default_advert_description} // '',
        $self->_p2p_advertiser_stats_get($advertiser->{client_loginid}, $stats_days)->%*,
    };

    # only advertiser themself can see these fields
    # We will manualy clean up this field in websocket
    # If you're adding any new field here please add it to websocket subscription clean up as well
    if ($self->loginid eq $advertiser->{client_loginid}) {
        $details->{payment_info} = $advertiser->{payment_info} // '';
        $details->{contact_info} = $advertiser->{contact_info} // '';
        $details->{chat_user_id} = $advertiser->{chat_user_id};
        $details->{chat_token} = $advertiser->{chat_token} // '';
        # band limits are not returned by all db functions
        if ($advertiser->{limit_currency}) {
            $details->{daily_buy}        = financialrounding('amount', $advertiser->{account_currency}, $advertiser->{daily_buy});
            $details->{daily_sell}       = financialrounding('amount', $advertiser->{account_currency}, $advertiser->{daily_sell});
            $details->{daily_buy_limit}  = financialrounding('amount', $advertiser->{account_currency}, $advertiser->{daily_buy_limit});
            $details->{daily_sell_limit} = financialrounding('amount', $advertiser->{account_currency}, $advertiser->{daily_sell_limit});
        }
    }
    return $details;
}

=head2 _advert_details

Prepares advert fields for client display.
Takes and returns an arrayref of advert.

=cut

sub _advert_details {
    my ($self, $list, $amount, $show_limits) = @_;
    my @results;

    for my $advert (@$list) {

        my $result = {
            account_currency  => $advert->{account_currency},
            country           => $advert->{country},
            created_time      => Date::Utility->new($advert->{created_time})->epoch,
            description       => $advert->{description} // '',
            id                => $advert->{id},
            is_active         => $advert->{is_active},
            local_currency    => $advert->{local_currency},
            payment_method    => $advert->{payment_method},
            type              => $advert->{type},
            counterparty_type => P2P_COUNTERYPARTY_TYPE_MAPPING->{$advert->{type}},
            price             => financialrounding('amount', $advert->{local_currency}, $advert->{rate} * ($amount // 1)),
            price_display     => formatnumber('amount', $advert->{local_currency}, $advert->{rate} * ($amount // 1)),
            rate              => $advert->{rate},
            rate_display      => _p2p_rate_format($advert->{rate}),
            (
                $show_limits
                ? (
                    min_order_amount_limit         => financialrounding('amount', $advert->{account_currency}, $advert->{min_order_amount}),
                    min_order_amount_limit_display => formatnumber('amount', $advert->{account_currency}, $advert->{min_order_amount}),
                    max_order_amount_limit         => financialrounding('amount', $advert->{account_currency}, $advert->{max_order_amount_actual}),
                    max_order_amount_limit_display => formatnumber('amount', $advert->{account_currency}, $advert->{max_order_amount_actual}),
                    )
                : ()
            ),
            (
                $self->loginid eq $advert->{advertiser_loginid}    # only advert owner can see these fields
                ? (
                    payment_info => $advert->{payment_info} // '',
                    contact_info => $advert->{contact_info} // '',
                    amount                   => financialrounding('amount', $advert->{account_currency}, $advert->{amount}),
                    amount_display           => formatnumber('amount', $advert->{account_currency}, $advert->{amount}),
                    min_order_amount         => financialrounding('amount', $advert->{account_currency}, $advert->{min_order_amount}),
                    min_order_amount_display => formatnumber('amount', $advert->{account_currency}, $advert->{min_order_amount}),
                    max_order_amount         => financialrounding('amount', $advert->{account_currency}, $advert->{max_order_amount}),
                    max_order_amount_display => formatnumber('amount', $advert->{account_currency}, $advert->{max_order_amount}),
                    remaining_amount         => financialrounding('amount', $advert->{account_currency}, $advert->{remaining}),
                    remaining_amount_display => formatnumber('amount', $advert->{account_currency}, $advert->{remaining}),
                    )
                : ()
            ),
            advertiser_details => {
                id   => $advert->{advertiser_id},
                name => $advert->{advertiser_name},
            },
        };

        push @results, $result;
    }

    return \@results;
}

=head2 _order_details

Prepares order fields for client display.
Takes and returns an arrayref of orders.

=cut

sub _order_details {
    my ($self, $list) = @_;
    my @results;

    for my $order (@$list) {
        my $result = +{
            account_currency   => $order->{account_currency},
            created_time       => Date::Utility->new($order->{created_time})->epoch,
            payment_info       => $order->{payment_info} // '',
            contact_info       => $order->{contact_info} // '',
            expiry_time        => Date::Utility->new($order->{expire_time})->epoch,
            id                 => $order->{id},
            is_incoming        => $self->loginid eq $order->{advertiser_loginid} ? 1 : 0,
            local_currency     => $order->{local_currency},
            amount             => financialrounding('amount', $order->{account_currency}, $order->{amount}),
            amount_display     => formatnumber('amount', $order->{account_currency}, $order->{amount}),
            price              => financialrounding('amount', $order->{local_currency}, $order->{advert_rate} * $order->{amount}),
            price_display      => formatnumber('amount', $order->{local_currency}, $order->{advert_rate} * $order->{amount}),
            rate               => $order->{advert_rate},
            rate_display       => _p2p_rate_format($order->{advert_rate}),
            status             => $order->{status},
            type               => $order->{type},
            chat_channel_url   => $order->{chat_channel_url} // '',
            advertiser_details => {
                id         => $order->{advertiser_id},
                name       => $order->{advertiser_name},
                first_name => $order->{advertiser_first_name},
                last_name  => $order->{advertiser_last_name},
                loginid    => $order->{advertiser_loginid},
            },
            client_details => {
                id   => $order->{client_id}   // '',
                name => $order->{client_name} // '',
                first_name => $order->{client_first_name},
                last_name  => $order->{client_last_name},
                loginid    => $order->{client_loginid},
            },
            advert_details => {
                id             => $order->{advert_id},
                description    => $order->{advert_description} // '',
                type           => $order->{advert_type},
                payment_method => $order->{advert_payment_method},
            },
        };
        push @results, $result;
    }

    return \@results;
}

=head2 _validate_advert_amounts

Validates advert amounts for p2p_advert_create.

=cut

sub _validate_advert_amounts {
    my %param = @_;

    if (my @invalid_fields = grep { ($param{$_} // 0) <= 0 } (qw(amount max_order_amount min_order_amount rate))) {
        die +{
            error_code => 'InvalidNumericValue',
            details    => {fields => \@invalid_fields},
        };
    }

    my $maximum_advert = BOM::Config::Runtime->instance->app_config->payments->p2p->limits->maximum_advert;
    if (in_usd($param{amount}, $param{account_currency}) > $maximum_advert) {
        die +{
            error_code     => 'MaximumExceeded',
            message_params => [$param{account_currency}, convert_currency($maximum_advert, 'USD', $param{account_currency})],
        };
    }

    my $maximum_order = BOM::Config::Runtime->instance->app_config->payments->p2p->limits->maximum_order;
    if (in_usd($param{max_order_amount}, $param{account_currency}) > $maximum_order) {
        die +{
            error_code     => 'MaxPerOrderExceeded',
            message_params => [$param{account_currency}, convert_currency($maximum_order, 'USD', $param{account_currency})],
        };
    }

    die +{error_code => 'InvalidMinMaxAmount'} unless $param{min_order_amount} <= $param{max_order_amount};
    die +{error_code => 'InvalidMaxAmount'}    unless $param{max_order_amount} <= $param{amount};

    return;
}

sub _p2p_rate_format {
    # We take Precision from constant but cut off tailing zeros
    return sprintf('%0.0' . P2P_RATE_PRECISION . 'f', shift()) =~ s/(?<=\.\d{2})(\d*?)0*$/$1/r;
}

=head2 _p2p_order_stats_record

Records P2P advertiser statistics from an order event.

Example usage:

    $self->_p2p_order_stats_record('ORDER_CREATED', $order);

Takes the following arguments as named parameters:

=over 4

=item * C<stat> - name of stat, one of ORDER_CREATED, BUY_CONFIRM, ORDER_COMPLETED or ORDER_REFUNDED

=item * C<order> - hashref of order details as returned from db functions.

No return value.

=back

=cut

sub _p2p_order_stats_record {
    my ($self, $stat, $order) = @_;

    my $redis = BOM::Config::Redis->redis_p2p_write();

    # save order creation time, needed to calculate cancel time
    if ($stat eq 'ORDER_CREATED') {
        $redis->hset(P2P_STATS_REDIS_PREFIX . '::ORDER_CREATION_TIMES', $order->{id}, time);
        return;
    }

    # save confirm time only, needed used to calculate release time
    if ($stat eq 'BUY_CONFIRM') {
        $redis->hset(P2P_STATS_REDIS_PREFIX . '::BUY_CONFIRM_TIMES', $order->{id}, time);
        return;
    }

    # at this point stat must be ORDER_COMPLETED or ORDER_REFUNDED
    my $item        = $order->{id} . '|' . $order->{amount};
    my $creation_ts = $redis->hget(P2P_STATS_REDIS_PREFIX . '::ORDER_CREATION_TIMES', $order->{id})
        // Date::Utility->new($order->{created_time})->epoch;
    my $prune_ts = Date::Utility->new->minus_time_interval(P2P_STATS_TTL_IN_DAYS . 'd')->epoch;
    my $expiry   = P2P_STATS_TTL_IN_DAYS * 24 * 60 * 60;

    my $advertiser_prefix = join '::', (P2P_STATS_REDIS_PREFIX, $order->{advertiser_loginid});
    my $client_prefix     = join '::', (P2P_STATS_REDIS_PREFIX, $order->{client_loginid});

    my $advertiser_key = join '::', ($advertiser_prefix, $stat, uc $order->{advert_type});
    $redis->zadd($advertiser_key, $creation_ts, $item);
    $redis->expire($advertiser_key, $expiry);
    $redis->zremrangebyscore($advertiser_key, '-inf', '(' . $prune_ts);

    my $client_key = join '::', ($client_prefix, $stat, uc $order->{type});
    $redis->zadd($client_key, $creation_ts, $item);
    $redis->expire($client_key, $expiry);
    $redis->zremrangebyscore($client_key, '-inf', '(' . $prune_ts);

    if ($stat eq 'ORDER_COMPLETED') {
        # lifetime totals
        $redis->hincrby(P2P_STATS_REDIS_PREFIX . '::ORDER_COMPLETED_TOTAL', $order->{advertiser_loginid}, 1);
        $redis->hincrby(P2P_STATS_REDIS_PREFIX . '::ORDER_COMPLETED_TOTAL', $order->{client_loginid},     1);

        # average release time
        if (my $buy_confirm_time = $redis->hget(P2P_STATS_REDIS_PREFIX . '::BUY_CONFIRM_TIMES', $order->{id})) {
            my $elapsed      = time - $buy_confirm_time;
            my $prefix       = $order->{type} eq 'sell' ? $client_prefix : $advertiser_prefix;
            my $release_key  = $prefix . '::RELEASE_TIMES';
            my $release_item = $order->{id} . '|' . $elapsed;

            $redis->zadd($release_key, $creation_ts, $release_item);
            $redis->expire($release_key, $expiry);
            $redis->zremrangebyscore($release_key, '-inf', '(' . $prune_ts);
        }
    }

    # average cancellation time
    if ($stat eq 'ORDER_REFUNDED' && $order->{status} eq 'cancelled') {
        my $prefix       = $order->{type} eq 'buy' ? $client_prefix : $advertiser_prefix;
        my $elapsed      = time - $creation_ts;
        my $release_key  = $prefix . '::CANCEL_TIMES';
        my $release_item = $order->{id} . '|' . $elapsed;

        $redis->zadd($release_key, $creation_ts, $release_item);
        $redis->expire($release_key, $expiry);
        $redis->zremrangebyscore($release_key, '-inf', '(' . $prune_ts);
    }

    # clean up time storage, they won't be needed again for this order because it's either compelete or cancelled
    $redis->hdel(P2P_STATS_REDIS_PREFIX . '::ORDER_CREATION_TIMES', $order->{id});
    $redis->hdel(P2P_STATS_REDIS_PREFIX . '::BUY_CONFIRM_TIMES',    $order->{id});

    for my $loginid ($order->{advertiser_loginid}, $order->{client_loginid}) {
        BOM::Platform::Event::Emitter::emit(
            p2p_advertiser_updated => {
                client_loginid => $loginid,
            });
    }

    return;
}

=head2 _p2p_order_stats_get

Returns P2P advertiser statistics

Example usage:

    $self->_p2p_order_stats_get('CR001', 30);

Takes the following arguments as named parameters:

=over 4

=item * C<$loginid> - loginid of advertiser

=item * C<days> - period to generate stats in days

=back

Returns hashref.

=cut

sub _p2p_advertiser_stats_get {
    my ($self, $loginid, $days) = @_;

    my $start_ts   = Date::Utility->new->minus_time_interval($days . 'd')->epoch;
    my $key_prefix = P2P_STATS_REDIS_PREFIX . '::' . $loginid;
    my $redis      = BOM::Config::Redis->redis_p2p();

    my @cancel_times  = map { my $s = $_; $s =~ s/^.*\|//g; $s; } $redis->zrangebyscore($key_prefix . '::CANCEL_TIMES',  $start_ts, '+inf')->@*;
    my @release_times = map { my $s = $_; $s =~ s/^.*\|//g; $s; } $redis->zrangebyscore($key_prefix . '::RELEASE_TIMES', $start_ts, '+inf')->@*;

    my $stats = {
        total_orders_count => $redis->hget(P2P_STATS_REDIS_PREFIX . '::ORDER_COMPLETED_TOTAL', $loginid) // 0,
        buy_orders_count   => $redis->zcount($key_prefix . '::ORDER_COMPLETED::BUY', $start_ts, '+inf'),
        sell_orders_count  => $redis->zcount($key_prefix . '::ORDER_COMPLETED::SELL', $start_ts, '+inf'),
        cancel_time_avg    => @cancel_times ? sprintf("%.0f", List::Util::sum(@cancel_times) / @cancel_times) : undef,
        release_time_avg   => @release_times ? sprintf("%.0f", List::Util::sum(@release_times) / @release_times) : undef,
    };

    my $total = $stats->{buy_orders_count} + $redis->zcount($key_prefix . '::ORDER_REFUNDED::BUY', $start_ts, '+inf');
    $stats->{completion_rate} = $total ? sprintf("%.2f", ($stats->{buy_orders_count} / $total) * 100) : undef;

    return $stats;
}

=head1 METHODS - Payments

=cut

sub validate_payment {
    my ($self, %args) = @_;
    my $currency = $args{currency} || die "no currency\n";
    my $amount   = $args{amount}   || die "no amount\n";
    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->default_account || die "no account\n";
    my $accbal      = $account->balance;
    my $acccur      = $account->currency_code();
    my $absamt      = abs($amount);

    # validate expects 'deposit'/'withdraw' so if action_type is 'withdrawal' should be replaced to 'withdraw'
    my $validation = BOM::Platform::Client::CashierValidation::validate($self->loginid, $action_type =~ s/withdrawal/withdraw/r);
    die "$validation->{error}->{message_to_client}\n" if exists $validation->{error};

    die "Payment currency [$currency] not client currency [$acccur].\n"
        if $currency ne $acccur;

    die "Transfers are not allowed for these accounts.\n" if ($args{internal_transfer} and $self->status->transfers_blocked);

    if ($action_type eq 'deposit') {

        if (    $self->landing_company->short eq 'malta'
            and $self->is_first_deposit_pending
            and ($args{payment_type} // '') eq 'affiliate_reward')
        {
            $self->{mlt_affiliate_first_deposit} = 1;
        }
        my $max_balance = $self->get_limit({'for' => 'account_balance'});
        die sprintf("Balance would exceed limit [%s %s] for [%s] \n", $currency, $max_balance, $self->loginid)
            if ($amount + $accbal) > $max_balance;

        if ($self->landing_company->short eq 'iom') {
            my $max_deposit_limits = $self->get_limits_for_max_deposit();

            # Call get_total_deposit and validate against limits
            if ($max_deposit_limits) {
                my $deposit_over_period = 0;
                my $payment_arrayref    = $self->db->dbic->run(
                    ping => sub {
                        my $sth = $_->prepare('SELECT payment.get_total_deposit(?,?,?,?)');
                        $sth->execute(
                            $self->loginid,
                            $max_deposit_limits->{begin},
                            $max_deposit_limits->{end},
                            "{mt5_transfer}"    # exclude mt5 transfers
                        );
                        return $sth->fetchrow_arrayref;
                    });
                if ($payment_arrayref && $payment_arrayref->[0]) {
                    $deposit_over_period = $payment_arrayref->[0];
                }
                die
                    "Deposit exceeds limit [$max_deposit_limits->{max_deposit}]. Aggregated deposit over period [$deposit_over_period]. Current amount [$amount].\n"
                    if ($deposit_over_period + $amount) > $max_deposit_limits->{max_deposit};
            }
        }
    }

    if ($action_type eq 'withdrawal') {

        my $formatted_accbal = formatnumber('amount', $currency, $accbal);
        die "Withdrawal amount [$currency $absamt] exceeds client balance [$currency $formatted_accbal].\n"
            if financialrounding('amount', $currency, $absamt) > financialrounding('amount', $currency, $accbal);

        if (my $frozen = $self->get_withdrawal_limits->{frozen_free_gift}) {
            my $unfrozen = financialrounding('amount', $currency, $accbal - $frozen);
            die(
                localize(
                    "Withdrawal is [_1] [_2] but balance [_3] includes frozen bonus [_4].",
                    $currency,         formatnumber('amount', $currency, $absamt),
                    $formatted_accbal, formatnumber('amount', $currency, $frozen))
                    . "\n"
            ) if financialrounding('amount', $currency, $absamt) > financialrounding('amount', $currency, $unfrozen);
        }

        return 1 if $self->fully_authenticated;
        # disable withdrawal limit for rpc/internal_transfer_exclude_limit
        return 1 if $args{internal_transfer};

        my $lc = $self->landing_company->short;
        my $lc_limits;
        my $withdrawal_limits = BOM::Config::payment_limits()->{withdrawal_limits};
        $lc_limits = $withdrawal_limits->{$lc};
        die "Invalid landing company - $lc\n" unless $lc_limits;
        my $lc_currency = $lc_limits->{currency};

        if ($self->landing_company->lifetime_withdrawal_limit_check) {
            # Withdrawals to date
            my $wd_epoch = $account->total_withdrawals();

            # If currency is not the same as the lc's currency, convert withdrawals so far and withdrawal amount
            if ($currency ne $lc_currency) {
                $wd_epoch = convert_currency($wd_epoch, $currency, $lc_currency) if $wd_epoch > 0;
                $absamt   = convert_currency($absamt,   $currency, $lc_currency) if $absamt > 0;
            }

            # total withdrawal inclusive of this one
            my $total_wd = financialrounding('amount', $currency, $wd_epoch + $absamt);
            my $wd_left  = financialrounding('amount', $currency, $lc_limits->{lifetime_limit} - $wd_epoch);

            die sprintf("You've reached the maximum withdrawal limit of [%s %s]. Please authenticate your account to make unlimited withdrawals.\n",
                $lc_currency, $lc_limits->{lifetime_limit})
                if $wd_left <= 0;

            if (financialrounding('amount', $currency, $absamt) > financialrounding('amount', $currency, $wd_left)) {
                if ($currency ne $lc_currency) {
                    die sprintf "Withdrawal amount [%s %s] exceeds withdrawal limit [%s %s].\n", $currency,
                        formatnumber('amount', $currency, convert_currency($absamt, $lc_currency, $currency)),
                        $currency, formatnumber('amount', $currency, convert_currency($wd_left, $lc_currency, $currency));
                } else {
                    die sprintf "Withdrawal amount [%s %s] exceeds withdrawal limit [%s %s].\n", $currency,
                        formatnumber('amount', $currency, $absamt),
                        $currency, formatnumber('amount', $currency, $wd_left);
                }
            }

            if ($total_wd >= financialrounding('amount', $currency, $lc_limits->{lifetime_limit})) {
                BOM::Platform::Event::Emitter::emit('withdrawal_limit_reached', {loginid => $self->loginid});
            }

        } else {
            my $for_days = $lc_limits->{for_days};
            my $since    = Date::Utility->new->minus_time_interval("${for_days}d");

            # Obtains limit in EUR
            my $wd_eur_since_limit = $lc_limits->{limit_for_days};
            my $wd_eur_epoch_limit = $lc_limits->{lifetime_limit};

            # Obtains payments over the lifetime of the account
            my $wd_epoch = $account->total_withdrawals();

            # Obtains payments over the last x days
            my $wd_since = $account->total_withdrawals($since);

            # Converts payments over lifetime of the account and the last x days into EUR
            my $wd_eur_since = convert_currency($wd_since, $currency, 'EUR');
            my $wd_eur_epoch = convert_currency($wd_epoch, $currency, 'EUR');

            # Amount withdrawable over the last x days in EUR
            my $wd_eur_since_left = $wd_eur_since_limit - $wd_eur_since;

            # Amount withdrawable over the lifetime of the account in EUR
            my $wd_eur_epoch_left = $wd_eur_epoch_limit - $wd_eur_epoch;

            # Withdrawable amount left between the two amounts - The smaller is used
            my $wd_eur_left = List::Util::min($wd_eur_since_left, $wd_eur_epoch_left);

            die sprintf("You've reached the maximum withdrawal limit of [%s %s]. Please authenticate your account to make unlimited withdrawals.\n",
                $lc_currency, $lc_limits->{lifetime_limit})
                if $wd_eur_epoch_left <= 0;

            die sprintf("You've reached the maximum withdrawal limit of [%s %s]. Please authenticate your account to make unlimited withdrawals.\n",
                $lc_currency, $lc_limits->{limit_for_days})
                if $wd_eur_since_left <= 0;

            # Withdrawable amount is converted from EUR to clients' currency and rounded
            my $wd_left = financialrounding('amount', $currency, convert_currency($wd_eur_left, 'EUR', $currency));

            if (financialrounding('amount', $currency, $absamt) > financialrounding('amount', $currency, $wd_left)) {
                # lock cashier and unwelcome if its MX (as per compliance, check with compliance if you want to remove it)
                if ($lc eq 'iom') {
                    $self->status->multi_set_clear({
                        set        => ['cashier_locked', 'unwelcome'],
                        staff_name => 'system',
                        reason     => 'Exceeds withdrawal limit',
                    });
                }
                my $msg    = "Withdrawal amount [%s %s] exceeds withdrawal limit [EUR %s]";
                my @values = ($currency, formatnumber('amount', $currency, $absamt), formatnumber('amount', $currency, $wd_eur_left));
                if ($currency ne 'EUR') {
                    $msg = "$msg (equivalent to %s %s)";
                    push @values, $currency, formatnumber('amount', $currency, $wd_left);
                }
                die sprintf "$msg.\n", @values;
            }
        }

    }

    return 1;
}

sub deposit_virtual_funds {
    my ($self, $source) = @_;
    $self->is_virtual || die "not a virtual client\n";

    my $landing_company                 = $self->landing_company;
    my $currency                        = $landing_company->legal_default_currency // 'USD';
    my $virtual_account_default_balance = $landing_company->virtual_account_default_balance // 10000;

    # default_account not exists when first time init virtual balance
    my $account = $self->set_default_account($currency);

    my $amount = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare('SELECT (pmnt).amount FROM payment.set_balance($1 ,$2 , $3)');
            $sth->execute($account->id, $virtual_account_default_balance, $source);
            return $sth->fetchrow_array;
        });

    unless (defined $amount) {
        $amount = 0;
        stats_inc('bom_user.deposit_virtual.null');
    }

    return ($currency, $amount);
}

#######################################
# PAYMENT HANDLERS
# These Payment handlers are each named as payment_{payment_gateway_code}
# where each {payment_gateway_code} is a subclass of payment and is a 1-to-1 table.

# 'smart_payment' is a one-stop shop which will validate, and choose the appropriate
# payment_gateway, based on the payment_type.  Its skip_validation flag is only for
# some legacy tests which assume that the balance already got out of range somehow.
#######################################

sub smart_payment {
    my ($self, %args) = @_;
    my $payment_type         = $args{payment_type} || die "no payment_type";
    my $payment_gateway_code = $args{payment_gateway_code};

    $self->validate_payment(%args) unless delete $args{skip_validation};

    # each 'payment_type' implies a 'payment_gateway'..
    my %gateway_map = (
        affiliate_reward    => 'affiliate_reward',
        external_cashier    => 'doughflow',
        free_gift           => 'free_gift',
        adjustment          => 'legacy_payment',
        adjustment_purchase => 'legacy_payment',
        adjustment_sale     => 'legacy_payment',
        crypto_cashier      => 'legacy_payment',
        test_account        => 'legacy_payment',
        commission_paid     => 'legacy_payment',
        dormant_fee         => 'payment_fee',
        payment_fee         => 'payment_fee',
        bank_money_transfer => 'bank_wire',
        arbitrary_markup    => 'arbitrary_markup',
        cash_transfer       => 'western_union',      # ! need to fix in db first
    );

    $payment_gateway_code ||= $gateway_map{$payment_type}
        || die "unsupported payment_type: $payment_type";
    my $payment_handler = "payment_$payment_gateway_code";
    return $self->$payment_handler(%args);
}

sub payment_legacy_payment {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || die "no payment_type";
    my $staff        = $args{staff}        || 'system';

    # these are only here to support some tests which set up historic payments :(
    my $payment_time     = delete $args{payment_time};
    my $transaction_time = delete $args{transaction_time};
    my $source           = delete $args{source};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    die "cannot deal in $currency; clients currency is " . $account->currency_code() if $account->currency_code() ne $currency;

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'legacy_payment',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
            ($payment_time     ? (payment_time     => $payment_time)     : ()),
            ($transaction_time ? (transaction_time => $transaction_time) : ()),
        },
        {});    # <- TODO: legacy_payment table is redundant

    BOM::User::Client::PaymentNotificationQueue->add(
        source        => 'legacy',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );

    return $trx;
}

sub payment_account_transfer {
    my ($fmClient, %args) = @_;

    my $toClient = delete $args{toClient} || die "no toClient";
    my $currency = delete $args{currency} || die "no currency";
    my $amount   = delete $args{amount}   || die "no amount";
    my $to_amount = delete $args{to_amount};
    # fees can be zero as well
    my $fees               = delete $args{fees} // die "no fees";
    my $staff              = delete $args{staff} || 'system';
    my $toStaff            = delete $args{toStaff} || $staff;
    my $fmStaff            = delete $args{fmStaff} || $staff;
    my $remark             = delete $args{remark};
    my $toRemark           = delete $args{toRemark} || $remark || ("Transfer from " . $fmClient->loginid);
    my $fmRemark           = delete $args{fmRemark} || $remark || ("Transfer to " . $toClient->loginid);
    my $source             = delete $args{source};
    my $is_agent_to_client = delete $args{is_agent_to_client} // 0;
    my $lc_lifetime_limit  = delete $args{lc_lifetime_limit};
    my $lc_for_days        = delete $args{lc_for_days};
    my $lc_limit_for_days  = delete $args{lc_limit_for_days};

    # if client has no default account then error out
    my $fmAccount = $fmClient->default_account || die "Client does not have a default account\n";
    my $toAccount = $toClient->default_account || die "toClient does not have a default account\n";

    my $inter_db_transfer;
    $inter_db_transfer = delete $args{inter_db_transfer} if (exists $args{inter_db_transfer});
    my $gateway_code = delete $args{gateway_code} || 'account_transfer';

    my $from_curr = $fmClient->account->currency_code();
    my $to_curr   = $toClient->account->currency_code();

    if ($to_curr ne $from_curr and not defined $to_amount) {
        die "to_amount is required if from_currency and to_currency are different";
    } elsif ($to_curr eq $from_curr) {
        $to_amount = $amount;
    }

    $to_amount = financialrounding('amount', $to_curr, $to_amount);

    my $emit_transfer_event = sub {
        my $args = shift;

        my $event_properties = {
            from_account       => $fmClient->loginid,
            is_from_account_pa => 0 + !!($fmClient->is_pa_and_authenticated),
            to_account         => $toClient->loginid,
            is_to_account_pa   => 0 + !!($toClient->is_pa_and_authenticated),
            from_currency      => $from_curr,
            to_currency        => $to_curr,
            from_amount        => $amount,
            to_amount          => $to_amount,
            source             => $source,
            fees               => $fees,
            gateway_code       => $gateway_code,
            id                 => $args->{id},
            time               => $args->{transaction_time}};

        BOM::Platform::Event::Emitter::emit(
            'transfer_between_accounts',
            {
                loginid    => $fmClient->loginid,
                properties => $event_properties
            });
    };

    my $dbic = $fmClient->db->dbic;
    unless ($inter_db_transfer) {
        # here we rely on ->set_default_account above
        # which makes sure the `write` database is used.
        my $response;
        my $records = $dbic->run(
            # Error handling for code below is tricky; it returns a string for normal DB  errors,
            # and an array ref for custom DB errors (starts with "BI").
            ping => sub {
                my $sth = $_->prepare(
                    'SELECT (v_from_trans).id, (v_from_trans).transaction_time FROM payment.payment_account_transfer(?,?,?,?,?,?,?, ?,?,?,?,?,?, ?,?,?)'
                );
                $sth->execute(
                    $fmClient->loginid,  $toClient->loginid, $currency,    $amount, $to_amount, $fmStaff,
                    $toStaff,            $fmRemark,          $toRemark,    $source, $fees,      $gateway_code,
                    $is_agent_to_client, $lc_lifetime_limit, $lc_for_days, $lc_limit_for_days
                );
                return $sth->fetchall_arrayref({});
            });
        if (scalar @{$records}) {
            $response->{transaction_id} = $records->[0]->{id};

            $emit_transfer_event->($records->[0]);
        }

        return $response;
    }

    # TODO: Interclient transfers ("Transfer Between Accounts") lacks
    #       atomicity and is unsafe; we could potentially debit from one
    #       account and fail to credit into the other. We need to
    #       investigate a safe implementation or drop it altogether.
    my ($fmTrx) = $fmAccount->add_payment_transaction({
        amount               => -$amount,
        payment_gateway_code => $gateway_code,
        payment_type_code    => 'internal_transfer',
        status               => 'OK',
        staff_loginid        => $fmStaff,
        remark               => $fmRemark,
        account_id           => $fmAccount->id,
        staff_loginid        => $fmStaff,
        source               => $source,
        transfer_fees        => $fees,
    });

    # Enforce list context for consistency with the above - for some reason
    # we don't do anything with the result though
    (undef) = $toAccount->add_payment_transaction({
        amount               => $to_amount,
        payment_gateway_code => $gateway_code,
        payment_type_code    => 'internal_transfer',
        status               => 'OK',
        staff_loginid        => $toStaff,
        remark               => $toRemark,
        account_id           => $toAccount->id,
        staff_loginid        => $toStaff,
        source               => $source,
    });

    $emit_transfer_event->($fmTrx);

    return {transaction_id => $fmTrx->transaction_id};
}

sub payment_doughflow {
    # Doughflow payments may charge payment fees in cases where
    # clients deposit, did not trade and want their money back.
    # To ensure the atomicity of both the doughflow payment and its
    # corresponding payment fee, a seperate DB function that makes 2
    # calls to add_payment_transaction is used.
    #
    # add_doughflow_payment returns a superset of add_payment_transaction,
    # adding fee_transaction_id and fee_payment_id, so existing code can
    # expect the same outputs as other payment methods in this file.
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'external_cashier';
    my $staff        = $args{staff}        || 'system';
    my $payment_fee  = $args{payment_fee};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    my %doughflow_values = map { $_ => $args{$_} }
        grep { BOM::Database::AutoGenerated::Rose::Doughflow->meta->column($_) }
        keys %args;
    $doughflow_values{transaction_type}  ||= $action_type;
    $doughflow_values{trace_id}          ||= 0;
    $doughflow_values{created_by}        ||= $staff;
    $doughflow_values{payment_processor} ||= 'unspecified';
    $doughflow_values{payment_method} = $args{payment_method};

    my @bind_params =
        ($account->id, $amount, $payment_type, $staff, $remark, Encode::encode_utf8($json->encode(\%doughflow_values)), $payment_fee,);

    my $trx = $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_hashref("SELECT t.* from payment.add_doughflow_payment(?,?,?,?,?,?,?) t", undef, @bind_params);
        });

    BOM::User::Client::PaymentNotificationQueue->add(
        # Note that this was being passed in as a parameter, but always overridden.
        # This is probably a bug: either the parameter was wrong, or we should
        # use that source to define the gateway.
        source        => 'doughflow',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );
    return BOM::User::Client::PaymentTransaction::Doughflow->new(%$trx);
}

sub payment_free_gift {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'free_gift';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'free_gift',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        {reason => $remark}    # <- TODO: This is redundant; we are already storing remark in payments table.
    );

    return $trx;
}

sub payment_mt5_transfer {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'mt5_transfer';
    my $staff        = $args{staff}        || 'system';
    my $fees         = $args{fees};
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
        amount               => $amount,
        payment_gateway_code => 'account_transfer',
        payment_type_code    => $payment_type,
        status               => 'OK',
        staff_loginid        => $staff,
        remark               => $remark,
        account_id           => $account->id,
        source               => $source,
        transfer_fees        => $fees,
    });

    $self->user->daily_transfer_incr('mt5');

    return $trx;
}

sub payment_payment_fee {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'payment_fee';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'payment_fee',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        {});    # <- TODO: we currently don't charge payment_fee; this table is redundant.

    return $trx;
}

sub payment_bank_wire {
    my ($self, %args) = @_;

    my $currency = delete $args{currency} || die "no currency";
    my $amount   = delete $args{amount}   || die "no amount";
    my $staff    = delete $args{staff}    || 'system';
    my $remark   = delete $args{remark}   || '';
    my $source   = delete $args{source};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    my %bank_wire_values = map { $_ => $args{$_} }
        grep { BOM::Database::AutoGenerated::Rose::BankWire->meta->column($_) }
        keys %args;

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'bank_wire',
            payment_type_code    => 'bank_money_transfer',
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        \%bank_wire_values
    );

    BOM::User::Client::PaymentNotificationQueue->add(
        source        => 'bankwire',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );

    return $trx;
}

sub payment_affiliate_reward {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'affiliate_reward';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'affiliate_reward',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        {});    # <- TODO: affiliate_reward table is redundant

    if (exists $self->{mlt_affiliate_first_deposit} and $self->{mlt_affiliate_first_deposit}) {
        $self->status->setnx('cashier_locked', 'system', 'MLT client received an affiliate reward as first deposit');

        delete $self->{mlt_affiliate_first_deposit};
    }

    return $trx;
}

sub payment_western_union {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'cash_transfer';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $action_type = $amount > 0 ? 'deposit' : 'withdrawal';
    my $account     = $self->set_default_account($currency);

    my %wu_values = map { $_ => $args{$_} }
        grep { BOM::Database::AutoGenerated::Rose::WesternUnion->meta->column($_) }
        keys %args;
    $wu_values{mtcn_number}     ||= '';
    $wu_values{payment_country} ||= '';

    my ($trx) = $account->add_payment_transaction({
            amount               => $amount,
            payment_gateway_code => 'western_union',
            payment_type_code    => $payment_type,
            status               => 'OK',
            staff_loginid        => $staff,
            remark               => $remark,
            account_id           => $account->id,
            source               => $source,
        },
        \%wu_values
    );

    BOM::User::Client::PaymentNotificationQueue->add(
        source        => 'westernunion',
        currency      => $currency,
        loginid       => $self->loginid,
        type          => $action_type,
        amount        => $amount,
        payment_agent => $self->payment_agent ? 1 : 0,
    );

    return $trx;
}

sub payment_arbitrary_markup {
    my ($self, %args) = @_;

    my $currency     = $args{currency}     || die "no currency";
    my $amount       = $args{amount}       || die "no amount";
    my $remark       = $args{remark}       || die "no remark";
    my $payment_type = $args{payment_type} || 'arbitrary_markup';
    my $staff        = $args{staff}        || 'system';
    my $source       = $args{source};

    my $account = $self->set_default_account($currency);

    my ($trx) = $account->add_payment_transaction({
        amount               => $amount,
        payment_gateway_code => 'arbitrary_markup',
        payment_type_code    => $payment_type,
        status               => 'OK',
        staff_loginid        => $staff,
        remark               => $remark,
        account_id           => $account->id,
        source               => $source,
    });

    return $trx;
}

=head2 copy_status_to_siblings

Copies the given status from the current client to its siblings that haven't set with it before and returns the loginid of the updated clients.

Returns an arrayref containing the loginids of the clients that have been updated.

=cut

sub copy_status_to_siblings {
    my ($self, $status_code, $staff_name) = @_;

    $status_code                or die 'No status code provided';
    $staff_name                 or die 'No staff name provided';
    $self->status->$status_code or die $self->loginid . ": Can't copy $status_code to its siblings because it hasn't been set yet";

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_arrayref('SELECT betonmarkets.copy_client_status_to_siblings(?,?,?)', undef, $self->loginid, $status_code, $staff_name);
        })->[0] // [];
}

=head2 clear_status_and_sync_to_siblings

Removes the given status from the current client and from its siblings, and returns the loginid of the updated clients.

Returns an array containing the loginids of the clients that have been updated.

=cut

sub clear_status_and_sync_to_siblings {
    my ($self, $status_code) = @_;

    $status_code or die 'No status code provided';

    return $self->db->dbic->run(
        ping => sub {
            $_->selectrow_arrayref('SELECT betonmarkets.clear_client_status_sync_all(?,?)', undef, $self->loginid, $status_code);
        })->[0] // [];
}

=head2 get_sibling_loginids_without_status

Returns the login id of all landing company siblings of the current client that haven't set with the given status code

=cut

sub get_sibling_loginids_without_status {
    my ($self, $status_code) = @_;

    $status_code or die 'No status code provided';

    return $self->db->dbic->run(
        fixup => sub {
            $_->selectrow_arrayref('SELECT betonmarkets.get_sibling_loginids_without_client_status(?,?)', undef, $self->loginid, $status_code);
        })->[0] // [];
}

=head2 siblings

Returns an array containing all the landing company siblings of the current client. Does NOT include the current one.

=cut

sub siblings {
    my $self     = shift;
    my @siblings = grep { $_->loginid ne $self->loginid } $self->user->clients_for_landing_company($self->landing_company->short);
    return \@siblings;
}

=head2 has_siblings

Returns true if the current client landing company siblings, false otherwise.

=cut

sub has_siblings {
    my $self = shift;

    return scalar(@{$self->siblings()}) > 0;
}

=head2 update_status_after_auth_fa

Checks status of the client after authentication or financial assessment changes, removing B<withdrawal_locked> status if:

=over

=item * client is withdrawal-locked with reason containing: 'Pending authentication or FA'

=item * client's financial assessment is completed

=item * client is fully authenticated without expired documents

=back

=cut

sub update_status_after_auth_fa() {
    my $self = shift;

    for my $sibling ($self->user->clients) {
        if ($sibling->is_financial_assessment_complete && $sibling->fully_authenticated && !$sibling->documents_expired) {
            $sibling->status->clear_withdrawal_locked
                if $sibling->status->withdrawal_locked
                && $sibling->status->withdrawal_locked->{reason} =~ 'Pending authentication or FA';
            $sibling->status->clear_allow_document_upload
                if $sibling->status->allow_document_upload
                && $sibling->status->allow_document_upload->{reason} =~ /BECOME_HIGH_RISK|Pending authentication or FA/;
        }
    }
}

=head2 anonymize_client

Anonymizes the client

=head2 Usage Caution

**NOTE:** Be careful to use this function it clears client data from all databases and it is irreversible action.

=cut

sub anonymize_client {
    my $self = shift;

    $self->db->dbic->run(
        fixup => sub {
            $_->do('SELECT * FROM betonmarkets.client_anonymization(?)', undef, $self->loginid);
        });
}

=head2 remove_client_authentication_docs_from_S3

Removes the client authentication documents from s3

=cut

sub remove_client_authentication_docs_from_S3 {
    my $self = shift;

    my $docs = $self->db->dbic->run(
        fixup => sub {
            $_->selectall_arrayref(<<'SQL', undef, $self->loginid);
SELECT file_name
FROM betonmarkets.client_authentication_document
WHERE client_loginid = ?
SQL
        });
    if ($docs) {
        my $s3_client = BOM::Platform::S3Client->new(BOM::Config::s3()->{document_auth});
        foreach my $doc (@$docs) {
            my $filename = $doc->[0];
            $s3_client->delete($filename);
        }
    }
}

=head2 anonymize_associated_user_return_list_of_siblings

Anonymize the associated user for this client and returns a list of siblings loginids

=head2 Usage Caution

**NOTE:** Be careful to use this function, it clears the client associated user data from all databases and it is irreversible action.

=cut

sub anonymize_associated_user_return_list_of_siblings {
    my $self = shift;

    # Get list of loginids for a userid
    return BOM::Database::UserDB::rose_db()->dbic->run(
        fixup => sub {
            $_->selectall_arrayref("SELECT * FROM users.user_anonymization(?)", {Slice => {}}, $self->loginid);
        })->@*;
}

=head2 get_comments

Returns a list of comments for a given client

=cut

sub get_comments {
    my ($self, $section) = @_;

    $self->set_db('replica');

    my $sql      = q{SELECT * FROM betonmarkets.get_client_comments(?, ?)};
    my $comments = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute($self->loginid, $section);
            return $sth->fetchall_arrayref({});
        });
    return $comments // [];
}

=head2 add_comment

Add a new MLRO comment for a given client

=cut

sub add_comment {
    my ($self, %args) = @_;

    my $old_db = $self->get_db;
    $self->set_db('write') if 'write' ne $old_db;

    die "CommentRequired\n" unless $args{comment};
    die "AuthorRequired\n"  unless $args{author};

    $args{section}       //= '';
    $args{creation_time} //= Date::Utility->new->datetime;

    my $sql    = q{SELECT * FROM betonmarkets.add_client_comment(?,?,?,?,?)};
    my $result = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute($self->loginid, @args{qw(comment author section creation_time)});
            return $sth->fetch->[0];
        });

    $self->set_db($old_db) if 'write' ne $old_db;

    return $result;
}

=head2 edit_comment

Adjust an existing MLRO comment with a specified ID

=cut

sub update_comment {
    my ($self, %args) = @_;

    my $old_db = $self->get_db;
    $self->set_db('write') if 'write' ne $old_db;

    die "CommentRequired\n"   unless $args{comment};
    die "AuthorRequired\n"    unless $args{author};
    die "CommentIDRequired\n" unless $args{id};
    die "ChecksumRequired\n"  unless $args{checksum};

    my $sql    = q{SELECT * FROM betonmarkets.update_client_comment(?,?,?,?)};
    my $result = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute(@args{qw(id comment author checksum)});
            return $sth->fetch->[0];
        });
    $self->set_db($old_db) if 'write' ne $old_db;

    return $result;
}

=head2 delete_comment

Remove a MLRO comment by ID

=cut

sub delete_comment {
    my ($self, $id, $checksum) = @_;

    my $old_db = $self->get_db;
    $self->set_db('write') if 'write' ne $old_db;

    die "CommentIDRequired\n" unless $id;
    die "ChecksumRequired\n"  unless $checksum;

    my $sql    = q{SELECT * FROM betonmarkets.delete_client_comment(?, ?)};
    my $result = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare($sql);
            $sth->execute($id, $checksum);
            return $sth->fetch->[0];
        });
    $self->set_db($old_db) if 'write' ne $old_db;

    return $result;
}

=head2 lifetime_internal_withdrawals

Gets the total amount of internal transfer (withdrawal)
The amount is in the client's currency

=cut

sub lifetime_internal_withdrawals {
    my $self = shift;

    my $lifetime_transfer_amount = $self->db->dbic->run(
        fixup => sub {
            my $sth = $_->prepare("SELECT * FROM payment.get_internal_transfer_withdrawal_amount(?)");
            $sth->execute($self->loginid);
            return $sth->fetchrow_array;
        });

    return $lifetime_transfer_amount // 0;
}

=head2 get_account_details

Prepares a formatted hash for $self

Takes the following arguments as named parameters

=over 4

=item * C<client> - L<BOM::User::Client> object for which formatted details are required

=back

Returns a Hashref of details of client.

=cut

sub get_account_details {
    my ($self) = @_;

    my $exclude_until = $self->get_self_exclusion_until_date;

    return {
        loginid              => $self->loginid,
        currency             => $self->account ? $self->account->currency_code : '',
        landing_company_name => $self->landing_company->short,
        is_disabled          => $self->status->disabled ? 1 : 0,
        is_virtual => $self->is_virtual ? 1 : 0,
        $exclude_until ? (excluded_until => Date::Utility->new($exclude_until)->epoch) : ()};
}

1;
