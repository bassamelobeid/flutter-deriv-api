package BOM::User::LexisNexis;

use strict;
use warnings;
use feature qw(state);
no indirect;

=head1 NAME

A business class for the table B<users.lexis_nexis> in userdb, along with subs for searching in database
and syncing with LexisNexis server.

=head1 DESCRIPTION

Each object of this class represents a summary of user's profile in LexisNexis.

=cut

use LandingCompany::Registry;
use List::Util qw(any none);

use BOM::User;
use BOM::Database::UserDB;

# The following values are related to the LexisNexis alert status
# accepted rejected undetermined open requested

use constant STATUS =>
    ["requested", "accepted", "rejected", "undetermined", "open", "false positive", "positive match", "potential match", "false match config"];
use constant SCREENING_REASON =>
    ('Social Responsibility', 'Payment Agent', 'MT5 Labuan', 'MT5 BVI', 'MT5 Vanuatu', 'Matainvest', 'Affiliate', 'API Developer', 'Others');

=head2 new

Creates a new L<BOM::User::LexisNexis> object by getting the following named arguments:

=over 4

=item * C<binary_user_id> - a user id form B<users.user> database

=item * C<alert_status> - screening status: I<reqested>, I<open>, I<accepted>, I<rejected>,  I<undetermined>

=item * C<client_loginid> - (optional) the id shared between our system and LexisNexis (B<loginid>)

=item * C<alert_id> - (optional) alert id generated by LexisNexis 

=item * C<date_updated> - (optional) the date the LexisNexis match data is updated

=item * C<note> - (optional) custom text supported by the API (used by compliance team to add notes/reason for manual screening requests)

=item * C<date_added> - (optional) the date at which the customer is added to LexisNexis.

=back

Returns a list of matching L<BOM::User::LexisNexis> objects

=cut

sub new {
    my ($class, %args) = @_;

    my $object = bless {%args}, $class;
    $object->validate();

    return $object;
}

use constant INTERFACE => qw(
    binary_user_id
    date_updated
    date_added
    alert_status
    alert_id
    note
    client_loginid
);

for my $field (INTERFACE) {
    no strict "refs";
    *{"BOM::User::LexisNexis::$field"} = sub {
        my ($self) = @_;

        return $self->{$field};
    }
}

=head2 validate

Validates a LexisNexis object's attributes.

=cut

sub validate {
    my ($self) = @_;

    for (qw/binary_user_id client_loginid alert_status/) {
        die "$_ is mandatory" unless $self->{$_};
    }

    die "alert_status '$self->{alert_status}' is invalid." unless any { $self->{alert_status} eq $_ } STATUS->@*;

    die "Invalid user id $self->{binary_user_id}" unless BOM::User->new(id => $self->{binary_user_id});

    die "Invalid screening reason (note): $self->{note}" unless BOM::User::LexisNexis->validate_custom_text1($self->{note});

    return 1;
}

=head2 validate_custom_text1

Compares the custom text against the predefined Screening Reasons (undef is accepted).

Returns 1 if acceptable; 0 otherwise.
=cut

sub validate_custom_text1 {
    my ($self, $text) = @_;

    return 1 unless defined $text;

    return 1 if any { $_ eq $text } SCREENING_REASON;

    return 0;
}

=head2 dbic

Gets a connection to user database.

=cut

sub dbic {
    return BOM::Database::UserDB::rose_db()->dbic;
}

=head2 find

Searches the database for B<lexis_nexis> records by a criteria, provided
by the following named args:

=over 4

=item * C<binary_user_id> - a user id form B<users.user> database

=item * C<alert_id> - an alert id, coming from LexisNexis

=item * C<status> - screening status: I<reqested>, I<open>, I<rejected>, I<undetermined> or I<accepted>

=back

Returns a list of matching L<BOM::User::LexisNexis> objects

=cut

sub find {
    my ($self, %args) = @_;

    my @search_fields = qw/binary_user_id alert_id alert_status/;

    die 'Search criteria is empty' unless any { $args{$_} } @search_fields;

    my $rows = dbic->run(
        fixup => sub {
            return $_->selectall_arrayref('select * from users.get_lexis_nexis(?,?,?)', {Slice => {}}, @args{@search_fields});
        });

    return map { BOM::User::LexisNexis->new(%$_) } @$rows;
}

=head2 save

Saves the current object in database.

=cut

sub save {
    my ($self) = @_;

    return dbic->run(
        fixup => sub {
            return $_->do('select from users.set_lexis_nexis(?,?,?,?,?,?,?)',
                {}, $self->binary_user_id, $self->alert_status, $self->alert_id, $self->client_loginid, $self->date_updated, $self->note,
                $self->date_added);
        });
}

1;
