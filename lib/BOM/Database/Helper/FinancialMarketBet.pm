package BOM::Database::Helper::FinancialMarketBet;

use Moose;
use BOM::Database::AutoGenerated::Rose::FinancialMarketBet;
use BOM::Database::AutoGenerated::Rose::QuantsBetVariable;
use BOM::Database::Model::DataCollection::QuantsBetVariables;
use Rose::DB;
use JSON::XS ();
use Carp;

has 'account_data' => (
    is  => 'rw',
    isa => 'HashRef',
);

has 'bet' => (
    is  => 'rw',
    isa => 'BOM::Database::Model::FinancialMarketBet',
);

has 'bet_data' => (
    is  => 'rw',
    isa => 'HashRef|ArrayRef',
    lazy_build => 1,
);

has 'transaction_data' => (
    is  => 'rw',
    isa => 'Maybe[HashRef|ArrayRef]',
    lazy_build => 1,
);

has 'limits' => (
    is  => 'rw',
    isa => 'Maybe[HashRef]',
);

has 'db' => (
    is  => 'rw',
    isa => 'Rose::DB',
);

has 'quants_bet_variables' => (
    is      => 'rw',
    isa     => 'Maybe[BOM::Database::Model::DataCollection::QuantsBetVariables|ArrayRef[BOM::Database::Model::DataCollection::QuantsBetVariables]]',
    default => undef,
);

sub _build_bet_data {
    my $self = shift;

    my $bd = $self->bet;

    croak "Please specify either bet_data or bet" unless $bd;

    my @fmb_col  = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->columns;
    my @chld_col;
    # if you just want to sell a bet that you don't know the exact type,
    # you can pass it in as BOM::Database::Model::FinancialMarketBet
    @chld_col = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->{relationships}->{$bd->bet_class}->class->meta->columns
        unless ref $bd eq 'BOM::Database::Model::FinancialMarketBet';
    my %bet = map {
        my $v = $bd->$_;
        $_ => eval{$v->can('db_timestamp')} ? $v->db_timestamp : defined $v ? "$v" : undef;
    } @fmb_col, @chld_col;
    return \%bet;
}

sub _build_transaction_data {
    my $self = shift;

    my $bd;
    if ($bd = $self->bet) {
        return $bd->legacy_parameters;
    } elsif ($bd = $self->bet_data and ref($bd) eq 'HASH') {
        return +{
            transaction_time => $bd->{transaction_time},
            staff_loginid    => $bd->{staff_loginid},
        };
    }

    return;
}

sub buy_bet {
    my $self = shift;

    # We want to evaluate the error message from PG.
    # So, don't allow DBD::Pg to mess it up.
    # Same as "\set VERBOSITY terse" in psql.
    local $self->db->dbh->{pg_errorlevel} = 0;

    # NOTE, the parens around v_fmb and v_trans in the SQL statement
    #       are necessary.
    my $stmt = $self->db->dbh->prepare('
SELECT (v_fmb).*, (v_trans).*
  FROM bet.buy_bet($1::VARCHAR(12), $2::VARCHAR(3), $3::TIMESTAMP, $4::VARCHAR(50), $5::NUMERIC,
                   $6::NUMERIC, $7::TIMESTAMP, $8::TIMESTAMP, $9::TIMESTAMP, $10::BOOLEAN,
                   $11::VARCHAR(30), $12::VARCHAR(30), $13::VARCHAR(800), $14::VARCHAR(255), $15::BOOLEAN,
                   $16::INT, $17::JSON, $18::TIMESTAMP, $19::VARCHAR(24), $20::VARCHAR(800),
                   $21::BIGINT, $22::JSON, $23::JSON)');
    my %bet = (
        expiry_daily => 0,
        is_expired   => 0,
        is_sold      => 0,
        %{$self->bet_data},
    );

    my @chld_col = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->{relationships}->{$bet{bet_class}}->class->meta->columns;
    my $qv       = $self->quants_bet_variables;
    my @qv_col   = BOM::Database::AutoGenerated::Rose::QuantsBetVariable->meta->columns;
    my $limits   = $self->limits;

    my @param = (
        # FMB stuff
        @{$self->account_data}{qw/client_loginid currency_code/},
        @bet{qw/purchase_time underlying_symbol
                payout_price buy_price start_time expiry_time
                settlement_time expiry_daily bet_class bet_type
                remark short_code fixed_expiry tick_count/},

        # FMB child table
        JSON::XS::encode_json(+{map {my $v = $bet{$_}; defined $v ? ($_ => $v) : ()} @chld_col}),

        # transaction table
        @{$self->transaction_data || {}}{qw/transaction_time staff_loginid remark source/},

        # data_collection.quants_bet_variables
        $qv ? JSON::XS::encode_json(+{map {my $v = $qv->$_; defined $v ? ($_ => $v) : ()} @qv_col}) : undef,

        # limits
        $limits ? JSON::XS::encode_json($limits) : undef,
    );

    # This can die. The caller is supposed to catch at least the following:
    # * [BIXXX => $string] - where XXX is an arbitrary combination of digits
    #                        and (uppercase?) letters
    $stmt->execute(@param);

    my $row = $stmt->fetchrow_arrayref;
    $stmt->finish;

    my @fmb_col = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->columns;
    my @txn_col = BOM::Database::AutoGenerated::Rose::Transaction->meta->columns;

    my $fmb = {};
    @{$fmb}{@fmb_col} = @{$row}[0 .. $#fmb_col];

    my $txn = {};
    @{$txn}{@txn_col} = @{$row}[@fmb_col .. @fmb_col + $#txn_col];

    $self->bet_data->{id} = $fmb->{id};
    $self->bet->id($fmb->{id}) if $self->bet;

    return wantarray ? ($fmb, $txn) : $txn->{id};
}

sub sell_bet {
    my $self = shift;

    # NOTE, the parens around v_fmb and v_trans in the SQL statement
    #       are necessary.
    my $stmt = $self->db->dbh->prepare('
SELECT (v_fmb).*, (v_trans).*
  FROM bet.sell_bet($1::VARCHAR(12), $2::VARCHAR(3), $3::BIGINT, $4::NUMERIC, $5::TIMESTAMP,
                    $6::JSON, $7::TIMESTAMP, $8::VARCHAR(24), $9::VARCHAR(800), $10::BIGINT,
                    $11::JSON)');
    my @param;

    my $bet    = $self->bet_data;
    my $qv     = $self->quants_bet_variables;
    my @qv_col = BOM::Database::AutoGenerated::Rose::QuantsBetVariable->meta->columns;

    if ($self->bet) {
        $bet->{$_} //= $self->bet->$_ for (qw/id sell_price sell_time/);
    }

    @param = (
        # FMB stuff
        @{$self->account_data}{qw/client_loginid currency_code/},
        @{$bet}{qw/id sell_price sell_time/},

        # FMB child table
        $bet->{absolute_barrier} ? JSON::XS::encode_json(+{absolute_barrier => $bet->{absolute_barrier}}) : undef,

        # transaction table
        @{$self->transaction_data || {}}{qw/transaction_time staff_loginid remark source/},

        # data_collection.quants_bet_variables
        $qv ? JSON::XS::encode_json(+{map {my $v = $qv->$_; defined $v ? ($_ => $v) : ()} @qv_col}) : undef,
    );

    $stmt->execute(@param);

    my $row = $stmt->fetchrow_arrayref;
    $stmt->finish;

    my @fmb_col = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->columns;
    my @txn_col = BOM::Database::AutoGenerated::Rose::Transaction->meta->columns;

    my $fmb = {};
    @{$fmb}{@fmb_col} = @{$row}[0 .. $#fmb_col];

    my $txn = {};
    @{$txn}{@txn_col} = @{$row}[@fmb_col .. @fmb_col + $#txn_col];

    if ($self->bet) {
        $self->bet->sell_price($fmb->{sell_price});
        $self->bet->is_sold($fmb->{is_sold});
        $self->bet->is_expired($fmb->{is_expired});
    }

    return wantarray ? ($fmb, $txn) : $txn->{id};
}

sub batch_sell_bet {
    my $self = shift;

    my $bets = $self->bet_data;
    my $qvs  = $self->quants_bet_variables || [];
    my $txns = $self->transaction_data || [];

    my @qv_col = BOM::Database::AutoGenerated::Rose::QuantsBetVariable->meta->columns;

    # NOTE, this function can only be used to sell multiple contracts for the same account.
    #       If you need to sell contracts for multiple accounts, you can use
    #
    #           bet.sell_bet(loginid, currency, ...)
    #
    #       in a similar way. However, be aware that this can lead to deadlocks because
    #       the order in which the accounts are updated is not determined. If you still
    #       want to go this way, please order the bets by client_loginid and currency_code
    #       before the query. If in doubt, ask your friendly DBA team.

    # NOTE, the parens around s.v_fmb and s.v_trans in the SQL statement
    #       are necessary.
    my $sql = '
WITH
acc(account_id)  AS (SELECT id
                       FROM transaction.account
                      WHERE client_loginid=$1
                        AND currency_code=$2
                        FOR UPDATE),
bets(id, sell_price, sell_time, chld, transaction_time, staff_loginid, remark, source, qv) AS (VALUES
    ' . join(",\n    ",
         map {
             '($' . ($_ * 9 +  3) . '::BIGINT,' .
             ' $' . ($_ * 9 +  4) . '::NUMERIC,' .
             ' $' . ($_ * 9 +  5) . '::TIMESTAMP,' .
             ' $' . ($_ * 9 +  6) . '::JSON,' .
             ' $' . ($_ * 9 +  7) . '::TIMESTAMP,' .
             ' $' . ($_ * 9 +  8) . '::VARCHAR(24),' .
             ' $' . ($_ * 9 +  9) . '::VARCHAR(800),' .
             ' $' . ($_ * 9 + 10) . '::BIGINT,' .
             ' $' . ($_ * 9 + 11) . '::JSON)';
         } 0 .. $#$bets) . ')
SELECT (s.v_fmb).*, (s.v_trans).*
  FROM bets b
 CROSS JOIN acc a
 CROSS JOIN LATERAL bet.sell_bet(a.account_id,
                                 b.id,
                                 b.sell_price,
                                 b.sell_time,
                                 b.chld,
                                 b.transaction_time,
                                 b.staff_loginid,
                                 b.remark,
                                 b.source,
                                 b.qv) s
 ORDER BY (s.v_trans).id DESC';

    my $stmt = $self->db->dbh->prepare($sql);

    my @param = @{$self->account_data}{qw/client_loginid currency_code/};

    for (my $i=0; $i<@$bets; $i++) {
        my $bet       = $bets->[$i];
        my $qv        = $qvs->[$i];
        my $transdata = $txns->[$i];

        push @param, (
            # FMB stuff
            @{$bet}{qw/id sell_price sell_time/},

            # FMB child table
            $bet->{absolute_barrier} ? JSON::XS::encode_json(+{absolute_barrier => $bet->{absolute_barrier}}) : undef,

            # transaction table
            @{$transdata || {}}{qw/transaction_time staff_loginid remark source/},

            # data_collection.quants_bet_variables
            $qv ? JSON::XS::encode_json(+{map {my $v = $qv->$_; defined $v ? ($_ => $v) : ()} @qv_col}) : undef,
        );
    }

    $stmt->execute(@param);

    my @fmb_col = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->columns;
    my @txn_col = BOM::Database::AutoGenerated::Rose::Transaction->meta->columns;

    my @res;
    while (my $row = $stmt->fetchrow_arrayref) {
        my $fmb = {};
        @{$fmb}{@fmb_col} = @{$row}[0 .. $#fmb_col];
        my $txn = {};
        @{$txn}{@txn_col} = @{$row}[@fmb_col .. @fmb_col + $#txn_col];
        push @res, {fmb => $fmb, txn => $txn};
    }

    return \@res;
}

no Moose;
__PACKAGE__->meta->make_immutable;

1;
