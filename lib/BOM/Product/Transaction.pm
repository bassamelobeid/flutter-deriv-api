package BOM::Product::Transaction;

use Moose;
use Data::Dumper;
use Error::Base;
use Path::Tiny;
use Time::HiRes qw(tv_interval gettimeofday time);
use List::Util qw(min max first);
use JSON qw( from_json );
use Date::Utility;
use ExpiryQueue qw( enqueue_new_transaction );
use Format::Util::Numbers qw(roundnear to_monetary_number_format);
use BOM::Platform::Context qw(request localize);
use BOM::Platform::Runtime;
use BOM::Platform::Client;
use BOM::System::Config;
use BOM::Product::ContractFactory qw( produce_contract make_similar_contract );
use BOM::Utility::CurrencyConverter qw(in_USD amount_from_to_currency);
use BOM::Database::DataMapper::Payment;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::FinancialMarketBet;
use DataDog::DogStatsd::Helper qw(stats_inc stats_timing stats_count);
use BOM::Database::ClientDB;
use BOM::Database::Model::Account;
use BOM::Database::Model::DataCollection::QuantsBetVariables;
use BOM::Database::Model::Constants;
use BOM::Platform::CustomClientLimits;
use BOM::Database::Helper::FinancialMarketBet;
use Try::Tiny;
use BOM::Utility::Log4perl qw/get_logger/;
use BOM::Product::Offerings qw/get_offerings_with_filter/;

extends 'BOM::Platform::Transaction';

has client => (
    is  => 'ro',
    isa => 'BOM::Platform::Client',
);

has contract => (
    is => 'rw',
);

has price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has transaction_record => (
    is         => 'ro',
    isa        => 'BOM::Database::AutoGenerated::Rose::Transaction',
    lazy_build => 1,
);

sub _build_transaction_record {
    my $self = shift;
    my $id = $self->transaction_id || die 'transaction not written yet';
    return $self->client->default_account->find_transaction({id => $id})->[0];
}

has balance_after => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has limits => (
    is      => 'rw',
    isa     => 'HashRef',
    default => sub { +{} },
);

has payout => (
    is         => 'rw',
    isa        => 'Num',
    lazy_build => 1,
);

sub _build_payout {
    my $self = shift;
    return $self->contract->is_spread ? $self->contract->amount_per_point * $self->contract->stop_profit : $self->contract->payout;
}

has amount_type => (
    is      => 'rw',
    isa     => 'Str',
    default => 'payout',
);

has comment => (
    is  => 'rw',
    isa => 'Str'
);

has staff => (
    is         => 'rw',
    isa        => 'Str',
    lazy_build => 1,
);

sub _build_staff {
    my $self = shift;
    return $self->client->loginid;
}

has transaction_id => (
    is  => 'rw',
    isa => 'Int',
);

has contract_id => (
    is  => 'rw',
    isa => 'Int',
);

has execute_at_better_price => (
    is      => 'rw',
    isa     => 'Bool',
    default => 0,
);

# calling server should capture time of request
has purchase_date => (
    is         => 'rw',
    isa        => 'bom_date_object',
    coerce     => 1,
    lazy_build => 1,
);

has contract_class => (
    is  => 'rw',
    isa => 'Str',
);

has source => (
    is  => 'ro',
    isa => 'Int',
);

has transaction_parameters => (
    is      => 'ro',
    isa     => 'HashRef',
    default => sub { {}; },
);

sub BUILDARGS {
    my ($class, $args) = @_;

    if (exists $args->{price}) {
        $args->{transaction_parameters}->{price} = $args->{price};
    }
    if (exists $args->{payout}) {
        $args->{transaction_parameters}->{payout} = $args->{payout};
    }
    return $args;
}

sub sell_expired_contracts;    # forward declaration

sub _build_purchase_date {

# Purchase is considered to have happened at time of request; if no such info available, then now.
# Classic case: REQUEST_STARTTIME is present (epoch-style) in the binary.com cgi context.
    return $ENV{REQUEST_STARTTIME} // time;
}

sub stats_start {
    my $self = shift;
    my $what = shift;

    my $broker    = lc($self->client->broker_code);
    my $virtual   = $self->client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::System::Config::env;
    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$self->contract->code};
    my $tags      = {tags => ["broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "contract_class:$bet_class",]};

    if ($what eq 'buy') {
        if ($self->contract->is_spread) {
            push @{$tags->{tags}}, "stop_type:" . lc($self->contract->stop_type);
        } else {
            push @{$tags->{tags}}, "amount_type:" . lc($self->amount_type), "expiry_type:" . ($self->contract->fixed_expiry ? 'fixed' : 'duration');
        }
    } elsif ($what eq 'sell') {
        push @{$tags->{tags}}, "sell_type:manual";
    }
    stats_inc("transaction.$what.attempt", $tags);

    return +{
        start   => [gettimeofday],
        tags    => $tags,
        virtual => $virtual,
        rmgenv  => $rmgenv,
        what    => $what,
    };
}

sub stats_validation_done {
    my $self = shift;
    my $data = shift;

    $data->{validation_done} = [gettimeofday];

    return;
}

sub stats_stop {
    my $self = shift;
    my $data = shift;
    my $what = $data->{what};

    my $tags = $data->{tags};
    my $now  = [gettimeofday];
    stats_timing("transaction.$what.elapsed_time", 1000 * tv_interval($data->{start},           $now), $tags);
    stats_timing("transaction.$what.db_time",      1000 * tv_interval($data->{validation_done}, $now), $tags);
    stats_inc("transaction.$what.success", $tags);

    if ($data->{rmgenv} eq 'production' and $data->{virtual} eq 'no') {
        my $usd_amount = int(in_USD($self->price, $self->contract->currency) * 100);
        if ($what eq 'buy') {
            stats_count('business.turnover_usd',       $usd_amount, $tags);
            stats_count('business.buy_minus_sell_usd', $usd_amount, $tags);
        } elsif ($what eq 'sell') {
            stats_count('business.buy_minus_sell_usd', -$usd_amount, $tags);
        }
    }
    return;
}

sub calculate_limits {
    my $self = shift;

    my $ql = BOM::Platform::Runtime->instance->app_config->quants->client_limits;

    my $contract = $self->contract;
    my $currency = $contract->currency;
    my $client   = $self->client;

    # formerly _validate_account_balance
    $self->limits->{max_balance} = $client->get_limit_for_account_balance;

    # formerly _validate_account_portfolio
    $self->limits->{max_open_bets} = $client->get_limit_for_open_positions;

    $self->limits->{max_payout_open_bets} = $client->get_limit_for_payout;

    $self->limits->{max_payout_per_symbol_and_bet_type} = $ql->payout_per_symbol_and_bet_type_limit;

    # formerly _validate_daily_total_turnover_limit
    $self->limits->{max_turnover} = $client->get_limit_for_daily_turnover;

    my $lim;
    defined($lim = $client->get_limit_for_daily_losses)
        and $self->limits->{max_losses} = $lim;
    defined($lim = $client->get_limit_for_7day_turnover)
        and $self->limits->{max_7day_turnover} = $lim;
    defined($lim = $client->get_limit_for_7day_losses)
        and $self->limits->{max_7day_losses} = $lim;

    if ($client->loginid !~ /^VRT/ and $contract->market->name eq 'forex' and $contract->is_intraday and not $contract->is_atm_bet) {
        $lim = $self->limits->{intraday_forex_iv_action} = from_json($ql->intraday_forex_iv);
        for (keys %$lim) {
            delete $lim->{$_} if $lim->{$_} == 0;
        }
    }

    # formerly _validate_promo_code_limit
    my $cpc = $client->client_promo_code;
    if ($cpc and $cpc->status ne 'CANCEL') {
        my $pc = $cpc->promotion;
        if ($pc->promo_code_type eq 'FREE_BET') {
            # our rule is that a client who use free bet, cannot win an amount more than
            # 25 times the promo code value without any deposit. If the Client already
            # has a balance more than the amount, we do not allow him to trade anymore.
            $self->limits->{max_balance_without_real_deposit} = 25 * from_json($pc->promo_code_config)->{amount};
        }
    }

    if ($contract->is_spread) {
        $self->limits->{spread_bet_profit_limit} = $ql->spreads_daily_profit_limit;
    }

    if ($contract->category_code eq 'digits') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            bet_type    => [map { {n => $_} } 'DIGITMATCH', 'DIGITDIFF'],
            name        => 'digits_turnover_limit',
            limit       => $ql->digits_turnover_limit,
            tick_expiry => 1,
            };
    }

    if ($contract->pricing_engine_name eq 'BOM::Product::Pricing::Engine::TickExpiry') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            bet_type => [map { {n => $_} } 'CALL', 'PUT'],
            name     => 'tick_expiry_engine_turnover_limit',
            limit    => $ql->tick_expiry_engine_turnover_limit,
            symbols  => [
                map { {n => $_} } get_offerings_with_filter(
                    'underlying_symbol',
                    {
                        market      => 'forex',
                        expiry_type => 'tick'
                    })
            ],
            };
    }

    if ($contract->pricing_engine_name eq 'BOM::Product::Pricing::Engine::Intraday::Index') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            bet_type => [map { {n => $_} } 'CALL', 'PUT'],
            name     => 'intraday_spot_index_turnover_limit',
            limit    => $ql->intraday_spot_index_turnover_limit,
            symbols => [map { {n => $_} } get_offerings_with_filter('underlying_symbol', {market => 'indices'})],
            };
    }

    if ($contract->underlying->submarket->name eq 'smart_index' or $contract->underlying->submarket->name eq 'smart_fx') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            name    => 'smarties_turnover_limit',
            limit   => $ql->smarties_turnover_limit,
            symbols => [map { {n => $_} } get_offerings_with_filter('underlying_symbol', {submarket => ['smart_fx', 'smart_index']})],
            };
    }

    if ($contract->market->name eq 'stocks') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            name    => 'stocks_turnover_limit',
            limit   => $ql->stocks_turnover_limit,
            symbols => [map { {n => $_} } get_offerings_with_filter('underlying_symbol', {market => 'stocks'})],
            };
    }

    if ($contract->underlying->submarket->name eq 'smart_index') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            name    => 'smart_index_turnover_limit',
            limit   => $ql->smart_index_turnover_limit,
            symbols => [map { {n => $_} } get_offerings_with_filter('underlying_symbol', {submarket => 'smart_index'})],
            };
    }

    if ($contract->tick_expiry) {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            name        => 'tick_expiry_turnover_limit',
            limit       => $ql->tick_expiry_turnover_limit,
            tick_expiry => 1
            };
    }

    if ($contract->category_code eq 'asian') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            bet_type    => [map { {n => $_} } 'ASIANU', 'ASIAND'],
            name        => 'asian_turnover_limit',
            limit       => $ql->asian_turnover_limit,
            tick_expiry => 1,
            };
    }

    my %euro_pairs = (
        frxEURUSD => 1,
        frxEURJPY => 1,
        frxEURCAD => 1,
        frxEURNZD => 1,
        frxEURGBP => 1,
        frxEURAUD => 1,
    );
    if ($euro_pairs{$contract->underlying->symbol}) {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            name    => 'euro_pairs_turnover_limit',
            limit   => $ql->euro_pairs_turnover_limit,
            symbols => [map { {n => $_} } keys %euro_pairs],
            };
    }

    return;
}

sub prepare_bet_data_for_buy {
    my $self = shift;

    my $client   = $self->client;
    my $contract = $self->contract;
    my $loginid  = $client->loginid;
    my $currency = $contract->currency;

    if ($self->purchase_date->is_after($contract->date_start)) {
        my $d1 = $self->purchase_date->datetime_yyyymmdd_hhmmss;
        my $d2 = $contract->date_start->datetime_yyyymmdd_hhmmss;
        return Error::Base->cuss(
            -type              => 'ContractAlreadyStarted',
            -mesg              => "buy at $d1 too late for $d2 contract",
            -message_to_client => BOM::Platform::Context::localize("Start time is in the past"));
    }

    my $comment = $self->comment // '';

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        loginid           => $loginid,
        currency          => $currency,
        quantity          => 1,
        short_code        => scalar $contract->shortcode,
        buy_price         => $self->price,
        remark            => $comment,
        underlying_symbol => scalar $contract->underlying->symbol,
        bet_type          => scalar $contract->code,
        bet_class         => $bet_class,
        purchase_time     => scalar $self->purchase_date->db_timestamp,
        start_time        => scalar $contract->date_start->db_timestamp,
    };

    if (!$contract->is_spread) {
        $bet_params->{payout_price}    = scalar $self->payout;
        $bet_params->{expiry_time}     = scalar $contract->date_expiry->db_timestamp;
        $bet_params->{settlement_time} = scalar $contract->date_settlement->db_timestamp;
        $bet_params->{expiry_daily}    = 1 if $contract->expiry_daily;
        $bet_params->{fixed_expiry}    = 1 if $contract->fixed_expiry;
        if ($contract->tick_expiry) {
            $bet_params->{tick_expiry} = 1;
            $bet_params->{tick_count}  = scalar $contract->tick_count;
        }
    }

    if ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_SPREAD_BET) {
        $bet_params->{$_} = $contract->$_ for qw(amount_per_point spread stop_profit stop_loss);
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_HIGHER_LOWER_BET) {
        # only store barrier in the database if it is defined.
        # asian contracts have barriers at/after expiry.
        if ($contract->barrier) {
            $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
        }
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_DIGIT_BET) {
        $bet_params->{prediction} = $contract->sentiment;
        $bet_params->{last_digit} = $contract->barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_RANGE_BET) {
        $bet_params->{$contract->high_barrier->barrier_type . '_higher_barrier'} = $contract->high_barrier->supplied_barrier;
        $bet_params->{$contract->low_barrier->barrier_type . '_lower_barrier'}   = $contract->low_barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_TOUCH_BET) {
        $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
    } else {
        return Error::Base->cuss(
            -type              => 'UnsupportedBetClass',
            -mesg              => "Unsupported bet class $bet_params->{bet_class}",
            -message_to_client => BOM::Platform::Context::localize("Unsupported bet class $bet_params->{bet_class}"),
        );
    }

    my $quants_bet_variables;
    my $quants_bet_params = BOM::Database::Model::DataCollection::QuantsBetVariables->extract_parameters_from_line({line => "COMMENT:$comment"});
    if ($quants_bet_params) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $quants_bet_params,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
            },
            bet_data     => $bet_params,
            account_data => {
                client_loginid => $loginid,
                currency_code  => $currency
            },
            quants_bet_variables => $quants_bet_variables,
            limits               => $self->limits,
        });
}

sub buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my %options = @_;

    my $error_status;

    my $stats_data = $self->stats_start('buy');

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        $error_status = $self->$_ and return $error_status
            for (
            qw/_validate_iom_withdrawal_limit
            _validate_payout_limit
            _is_valid_to_buy
            _validate_date_pricing
            _validate_trade_pricing_adjustment
            _validate_stake_limit
            _validate_jurisdictional_restrictions
            _validate_client_status
            _validate_currency/
            );

        $self->calculate_limits;

        $self->comment($self->_build_pricing_comment) unless defined $self->comment;
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_buy;
    return $error_status if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $try   = 0;
    my $error = 1;
    my ($fmb, $txn);
    TRY: {
        try {
            ($fmb, $txn) = $fmb_helper->buy_bet;
            $error = 0;
        }
        catch {
            # $error_status==undef means repeat operation
            # if $error_status is defined, return it
            # otherwise the function re-throws the exception (unrecoverable).
            $error_status = $self->_recover($_, $try);
        };
        return $error_status if $error_status;
        redo TRY if $error and $try++ < 3;
    }

    return Error::Base->cuss(
        -type              => 'GeneralError',
        -mesg              => 'Cannot perform database action',
        -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
    ) if $error;

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});
    $self->contract_id($fmb->{id});

    enqueue_new_transaction($self);    # For soft realtime expiration notification.

    return;
}

sub prepare_bet_data_for_sell {
    my $self = shift;
    my $contract = shift || $self->contract;

    my $client   = $self->client;
    my $loginid  = $client->loginid;
    my $currency = $contract->currency;

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        id         => scalar $self->contract_id,
        sell_price => scalar $self->price,
        sell_time  => scalar $contract->date_pricing->db_timestamp,
        $contract->category_code eq 'asian' && $contract->is_after_expiry
        ? (absolute_barrier => scalar $contract->barrier->as_absolute)
        : (),
    };

    if ($contract->is_spread) {
        $bet_params->{expiry_time} = $bet_params->{settlement_time} = scalar $contract->date_pricing->db_timestamp;
        # payout always equal to sell price for spreads
        # pnl calculation involves buy price and sell price.
        # The sell price here includes the premium paid to enter the contract.
        $bet_params->{payout_price} = $bet_params->{sell_price};
    }

    my $quants_bet_variables;
    if (my $comment = $self->comment) {
        my $quants_bet_params = BOM::Database::Model::DataCollection::QuantsBetVariables->extract_parameters_from_line({line => "COMMENT:$comment"});
        if ($quants_bet_params) {
            $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                data_object_params => $quants_bet_params,
            });
        }
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
            },
            bet_data     => $bet_params,
            account_data => {
                client_loginid => $loginid,
                currency_code  => $currency
            },
            quants_bet_variables => $quants_bet_variables,
        });
}

sub sell {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my %options = @_;

    my $error_status;

    my $stats_data = $self->stats_start('sell');

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        $error_status = $self->$_ and return $error_status
            for (
            qw/_validate_iom_withdrawal_limit
            _validate_payout_limit
            _is_valid_to_sell
            _validate_currency/,
            # always sell at market price -- must be called after _is_valid_to_sell
            sub { $_[0]->price($_[0]->contract->bid_price); return },
            '_validate_date_pricing',
            );

        $self->comment($self->_build_pricing_comment) unless defined $self->comment;
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_sell;
    return $error_status if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $try   = 0;
    my $error = 1;
    my ($fmb, $txn);
    TRY: {
        try {
            ($fmb, $txn) = $fmb_helper->sell_bet;
            $error = 0;
        }
        catch {
            # $error_status==undef means repeat operation
            # if $error_status is defined, return it
            # otherwise the function re-throws the exception (unrecoverable).
            $error_status = $self->_recover($_, $try);
        };
        return $error_status if $error_status;
        redo TRY if $error and $try++ < 3;
    }

    return Error::Base->cuss(
        -type              => 'GeneralError',
        -mesg              => 'Cannot perform database action',
        -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
    ) if $error;

    return Error::Base->cuss(
        -type              => 'NoOpenPosition',
        -mesg              => 'No such open contract.',
        -message_to_client => BOM::Platform::Context::localize('This contract was not found among your open positions.'),
    ) unless defined $txn->{id};

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});

    return;
}

=head2 C<< $self->_recover($error, $retry) >>

This function tries to recover from an unsuccessful buy/sell.
It may decide to retry the operation. And it may decide to
sell expired bets before doing so.

=head4 Parameters

=over 4

=item * C<< $error >>

the error exception thrown by BOM::Platform::Data::Persistence::DB::_handle_errors

=item * C<< $retry >>

an optional count of how many times the operation has been tried before.
Default is 0.

=back

=head3 Return Value

=over 4

=item * the empty list

which means I<please retry the operation, and, in case of an error, get
back with a C<$retry> count incremented by 1>.

=item * an L<Error::Base> object

which means an unrecoverable but expected condition has been found.
Typically that means a precondition, like sufficient balance, was
not met.

The caller should not retry the operation or try to amend the
situation. Instead it should pass on the error to the client.
However, make sure to C<unfreeze_client> before.

=back

Be aware that the function may throw an exception.

=head3 Exceptions

In case of an unexpected error, the exception is re-thrown unmodified.

=cut

my %known_errors = (
    BI001 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit =
            to_monetary_number_format(roundnear(0.01, amount_from_to_currency($client->get_limit_for_daily_turnover, USD => $currency)), 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your daily turnover limit of [_1][_2].',
            $currency, $limit);
        if (not $client->client_fully_authenticated) {
            $error_message .= ' ' . BOM::Platform::Context::localize('If you wish to raise these limits, please authenticate your account.');
        }

        return Error::Base->cuss(
            -type              => 'DailyTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a daily turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI002 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $limit = $self->client->get_limit_for_open_positions;
        return Error::Base->cuss(
            -type              => 'OpenPositionLimit',
            -mesg              => "Client has reached the limit of $limit open positions.",
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, you cannot hold more than [_1] contracts at a given time. Please visit the <a href="[_2]" class="pjaxload">statement</a> page to automatically sell your expired contracts.',
                $limit,
                request()->url_for("/user/statement")
            ),
        );
    },
    BI003 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $currency = $self->contract->currency;
        my $limit =
            to_monetary_number_format(roundnear(0.01, amount_from_to_currency($self->client->get_limit_for_account_balance, USD => $currency)), 1);
        my $account = BOM::Database::DataMapper::Account->new({
            client_loginid => $self->client->loginid,
            currency_code  => $currency,
        });
        my $balance = $account->get_balance();
        my $price   = $self->price;

        return Error::Base->cuss(
            -type              => 'InsufficientBalance',
            -message           => 'Client\'s account balance was insufficient to buy bet.',
            -message_to_client => BOM::Platform::Context::localize(
                'Your account balance ([_1][_2]) is insufficient to buy this contract ([_1][_3]).', $currency,
                to_monetary_number_format($balance),                                                to_monetary_number_format($price)));
    },
    BI004 => Error::Base->cuss(
        -type              => 'IntradayLimitExceeded',
        -mesg              => 'Exceeds intraday limit on turnover',
        -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
    ),
    BI005 => Error::Base->cuss(
        -type              => 'IntradayLimitExceeded',
        -mesg              => 'Exceeds intraday limit on potential_profit',
        -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
    ),
    BI006 => Error::Base->cuss(
        -type              => 'IntradayLimitExceeded',
        -mesg              => 'Exceeds intraday limit on realized_profit',
        -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
    ),
    BI007 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        return Error::Base->cuss(
            -type              => 'PotentialPayoutLimitForSameContractExceeded',
            -mesg              => "Client has exceeded potential payout limit for open contracts with the same symbol and bet_type",
            -message_to_client => BOM::Platform::Context::localize(
                'Purchase of this contract would cause you to exceed our payout limit for open contracts of this type. To continue please consider to sell a few contracts at the market or trade in different contract types.'
            ),
        );
    },
    BI008 => sub {
        my $self  = shift;
        my $retry = shift;

        my $currency = $self->contract->currency;
        my $limit =
            to_monetary_number_format(roundnear(0.01, amount_from_to_currency($self->client->get_limit_for_account_balance, USD => $currency)), 1);

        my $account = BOM::Database::DataMapper::Account->new({
            client_loginid => $self->client->loginid,
            currency_code  => $currency,
        });
        my $balance = $account->get_balance();

        return Error::Base->cuss(
            -type              => 'AccountBalanceExceedsLimit',
            -mesg              => 'Client balance is above the allowed limits',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, your account cash balance is too high ([_1]). <B>Your maximum account balance is [_2] </b>. Please withdraw money from your account to bring down your cash balance under that amount. You may not trade until you do so.',
                "$currency$balance",
                $limit
            ),
        );
    },
    BI009 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $currency = $self->contract->currency;
        my $limit =
            to_monetary_number_format(roundnear(0.01, amount_from_to_currency($self->client->get_limit_for_payout, USD => $currency)), 1);

        return Error::Base->cuss(
            -type              => 'OpenPositionPayoutLimit',
            -mesg              => 'Client has reached maximum net payout for open positions',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, the aggregate payouts of contracts on your account cannot exceed [_2][_1].',
                $limit, $currency
            ),
        );
    },
    BI010 => Error::Base->cuss(
        -type              => 'PromoCodeLimitExceeded',
        -mesg              => 'Client won more than 25 times of the promo code amount',
        -message_to_client => BOM::Platform::Context::localize(
            'Your account has exceeded the trading limit with free promo code, please deposit if you wish to continue trading.'),
    ),
    BI011 => sub {
        my $self  = shift;
        my $retry = shift;
        my $msg   = shift;

        my $limit_name = 'Unknown';
        $msg =~ /^.+: ([^,]+)/ and $limit_name = $1;

        return Error::Base->cuss(
            -type              => $limit_name . 'Exceeded',
            -mesg              => 'Exceeds turnover limit on ' . $limit_name,
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI012 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit =
            to_monetary_number_format(roundnear(0.01, amount_from_to_currency($client->get_limit_for_daily_losses, USD => $currency)), 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your daily limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => 'DailyLossLimitExceeded',
            -mesg              => "Client has exceeded his daily loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI013 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit =
            to_monetary_number_format(roundnear(0.01, amount_from_to_currency($client->get_limit_for_7day_turnover, USD => $currency)), 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your 7-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 7-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI014 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit =
            to_monetary_number_format(roundnear(0.01, amount_from_to_currency($client->get_limit_for_7day_losses, USD => $currency)), 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 7-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 7-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
);

sub _recover {
    my $self  = shift;
    my $err   = shift;
    my $retry = shift // 0;

    if (ref($err) eq 'ARRAY') {    # special BINARY code
        my $ref = $known_errors{$err->[0]};
        return ref $ref eq 'CODE' ? $ref->($self, $retry, $err->[1]) : $ref if $ref;
    } else {
        # TODO: recover from deadlocks & co.
    }
    die $err;
}

sub _validate_currency {
    my $self     = shift;
    my $broker   = $self->client->broker_code;
    my $currency = $self->contract->currency;

    if ($currency ne $self->client->currency) {
        return Error::Base->cuss(
            -type              => 'NotDefaultCurrency',
            -mesg              => "not default currency for client [$currency], client currency[" . $self->client->currency . "]",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is not the default currency", $currency),
        );
    }

    if (not grep { $currency eq $_ } @{request()->available_currencies}) {
        return Error::Base->cuss(
            -type              => 'InvalidCurrency',
            -mesg              => "Invalid $currency",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is invalid.", $currency),
        );
    }

    if (not BOM::Platform::Runtime->instance->broker_codes->get($broker)->landing_company->is_currency_legal($currency)) {
        return Error::Base->cuss(
            -type              => 'IllegalCurrency',
            -mesg              => "Illegal $currency for $broker",
            -message_to_client => BOM::Platform::Context::localize("[_1] transactions may not be performed with this account.", $currency),
        );
    }
    return;
}

sub _build_pricing_comment {
    my $self     = shift;
    my $contract = $self->contract;

    my @comment_fields;
    if ($contract->is_spread) {
        @comment_fields = map { defined $_->[1] ? @$_ : () } (
            [amount_per_point => $contract->amount_per_point],
            [stop_profit      => $contract->stop_profit],
            [stop_loss        => $contract->stop_loss],
            [spread           => $contract->spread],
        );
    } else {
        # This way the order of the fields is well-defined.
        @comment_fields = map { defined $_->[1] ? @$_ : (); } (
            [theo    => $contract->theo_price],
            [trade   => $self->price],
            [iv      => $contract->pricing_vol],
            [win     => $contract->payout],
            [div     => $contract->q_rate],
            [int     => $contract->r_rate],
            [delta   => $contract->delta],
            [gamma   => $contract->gamma],
            [vega    => $contract->vega],
            [theta   => $contract->theta],
            [vanna   => $contract->vanna],
            [volga   => $contract->volga],
            [bs_prob => $contract->bs_probability->amount],
            [spot    => $contract->current_spot]);

        my $news_factor = $contract->ask_probability->peek('news_factor');
        if ($news_factor) {
            push @comment_fields, news_fct => $news_factor->amount;
            my $news_impact = $news_factor->peek('news_impact');
            push @comment_fields, news_impact => $news_impact->amount if $news_impact;
        }

        if (@{$contract->corporate_actions}) {
            push @comment_fields,
                corporate_action => 1,
                actions          => join '|',
                map { $_->{description} . ',' . $_->{modifier} . ',' . $_->{value} } @{$contract->corporate_actions};
        }
    }

    return sprintf join(' ', ('%s[%0.5f]') x (@comment_fields / 2)), @comment_fields;
}

sub _validate_trade_pricing_adjustment {
    my $self = shift;

    # spreads price doesn't jump
    return if $self->contract->is_spread;

    my $stats_name        = 'transaction.buy.';
    my $stats_name_broker = 'transaction.' . lc($self->client->broker) . '.buy.';

    my $amount_type = $self->amount_type;
    my $contract    = $self->contract;
    my $currency    = $contract->currency;

    my $requested         = $self->price / $self->payout;
    my $recomputed        = $contract->ask_probability->amount;
    my $move              = $requested - $recomputed;
    my $commission_markup = 0;
    if (not $contract->is_expired) {
        $commission_markup = $contract->ask_probability->peek_amount('commission_markup') || 0;
    }
    my $allowed_move = $commission_markup * 0.5;
    $allowed_move = 0 if $recomputed == 1;
    my ($amount, $recomputed_amount) = $amount_type eq 'payout' ? ($self->price, $contract->ask_price) : ($self->payout, $contract->payout);

    if ($move != 0) {
        stats_inc($stats_name . 'price_moved');
        stats_inc($stats_name_broker . 'price_moved');
        my $final_value;
        if ($contract->is_expired) {
            return Error::Base->cuss(
                -type              => 'BetExpired',
                -mesg              => 'Bet expired with a new price[' . $recomputed_amount . '] (old price[' . $amount . '])',
                -message_to_client => BOM::Platform::Context::localize('The contract has expired'),
            );
        } elsif ($allowed_move == 0) {
            $final_value = $recomputed_amount;
        } elsif ($move < -$allowed_move) {
            stats_inc($stats_name . 'price_moved_failure');
            stats_inc($stats_name_broker . 'price_moved_failure');
            my $what_changed = $amount_type eq 'payout' ? 'price' : 'payout';
            my $market_moved = BOM::Platform::Context::localize('The underlying market has moved too much since you priced the contract. ');
            $market_moved .= BOM::Platform::Context::localize(
                'The contract [_4] has changed from [_1][_2] to [_1][_3].',
                $currency,
                to_monetary_number_format($amount),
                to_monetary_number_format($recomputed_amount),
                $what_changed
            );

            return Error::Base->cuss(
                -type => 'PriceMoved',
                -mesg =>
                    "Difference between submitted and newly calculated bet price: currency $currency, amount: $amount, recomputed amount: $recomputed_amount",
                -message_to_client => $market_moved,
            );
        } else {
            if ($move <= $allowed_move and $move >= -$allowed_move) {
                $final_value = $amount;
                stats_inc($stats_name . 'absorb_price_move');
                stats_inc($stats_name_broker . 'absorb_price_move');
            } elsif ($move > $allowed_move) {
                $self->execute_at_better_price(1);
                $final_value = $recomputed_amount;
                stats_inc($stats_name . 'better_price_execute');
                stats_inc($stats_name_broker . 'better_price_execute');
            }

        }

        # adjust the value here
        if ($amount_type eq 'payout') {
            $self->price($final_value);
        } else {
            $self->payout($final_value);

            # They are all 'payout'-based when they hit the DB.
            my $new_contract = make_similar_contract(
                $contract,
                {
                    amount_type => 'payout',
                    amount      => $final_value,
                });
            $self->contract($new_contract);
        }
    }

    return;
}

sub _is_valid_to_buy {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_valid_to_buy) {
        return Error::Base->cuss(
            -type              => 'InvalidtoBuy',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }
    return;
}

sub _is_valid_to_sell {
    my $self     = shift;
    my $contract = $self->contract;

    # we shouldn't we recreating contract for spreads.
    if ($contract->date_pricing->is_after($contract->date_start) and not $contract->is_spread) {
        # It's started, get one prepared for sale.
        $contract = make_similar_contract($contract, {for_sale => 1});
        $self->contract($contract);
    }

    if (not $contract->is_valid_to_sell) {
        return Error::Base->cuss(
            -type              => 'InvalidtoSell',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }
    return;
}

sub _validate_date_pricing {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_expired
        and abs(time - $contract->date_pricing->epoch) > 20)
    {
        return Error::Base->cuss(
            -type              => 'InvalidDatePricing',
            -mesg              => 'Bet was validated for a time [' . $contract->date_pricing->epoch . '] too far from now[' . time . ']',
            -message_to_client => BOM::Platform::Context::localize('This contract cannot be properly validated at this time.'));
    }
    return;
}

=head2 $self->_validate_iom_withdrawal_limit

Validate the withdrawal limit for IOM region

=cut

sub _validate_iom_withdrawal_limit {
    my $self   = shift;
    my $client = $self->client;

    return if $client->is_virtual;

    my $landing_company = BOM::Platform::Runtime->instance->broker_codes->landing_company_for($client->broker_code);
    return if ($landing_company->country ne 'Isle of Man');

    my $landing_company_short = $landing_company->short;
    my $numdays               = BOM::Platform::Runtime->instance->app_config->payments->withdrawal_limits->$landing_company_short->for_days;
    my $numdayslimit          = BOM::Platform::Runtime->instance->app_config->payments->withdrawal_limits->$landing_company_short->limit_for_days;
    my $lifetimelimit         = BOM::Platform::Runtime->instance->app_config->payments->withdrawal_limits->$landing_company_short->lifetime_limit;

    if ($client->client_fully_authenticated) {
        $numdayslimit  = 99999999;
        $lifetimelimit = 99999999;
    }

    # withdrawal since $numdays
    my $payment_mapper = BOM::Database::DataMapper::Payment->new({client_loginid => $client->loginid});
    my $withdrawal_in_days = $payment_mapper->get_total_withdrawal({
        start_time => Date::Utility->new(Date::Utility->new->epoch - 86400 * $numdays),
        exclude    => ['currency_conversion_transfer'],
    });
    $withdrawal_in_days = roundnear(0.01, amount_from_to_currency($withdrawal_in_days, $client->currency, 'EUR'));

    # withdrawal since inception
    my $withdrawal_since_inception = $payment_mapper->get_total_withdrawal({exclude => ['currency_conversion_transfer']});
    $withdrawal_since_inception = roundnear(0.01, amount_from_to_currency($withdrawal_since_inception, $client->currency, 'EUR'));

    my $remaining_withdrawal_eur =
        roundnear(0.01, min(($numdayslimit - $withdrawal_in_days), ($lifetimelimit - $withdrawal_since_inception)));

    if ($remaining_withdrawal_eur <= 0) {
        return Error::Base->cuss(
            -type              => 'iomWithdrawalLimit',
            -mesg              => $client->loginid . ' caught in IOM withdrawal limit check',
            -message_to_client => BOM::Platform::Context::localize(
                "Due to regulatory requirements, you are required to authenticate your account in order to continue trading."),
        );
    }
    return;
}

# This validation should always come after _validate_trade_pricing_adjustment
# because we recompute the price and that's the price that we going to transact with!
sub _validate_stake_limit {
    my $self = shift;

    # spread stake validation is within its module.
    # spread bet won't be offered to maltainvest.
    return if $self->contract->is_spread;

    my $client          = $self->client;
    my $contract        = $self->contract;
    my $landing_company = $client->landing_company;
    my $stake_limit     = $landing_company->short eq 'maltainvest' ? 5 : $contract->staking_limits->{stake}->{min};
    my $currency        = $contract->currency;
    if ($contract->ask_price < $stake_limit) {
        return Error::Base->cuss(
            -type => 'StakeTooLow',
            -mesg => $client->loginid . ' stake [' . $contract->ask_price . '] is lower than minimum allowable stake [' . $stake_limit . ']',
            -message_to_client => BOM::Platform::Context::localize(
                "This contract's price is [_1][_2]. Contracts purchased from [_3] must have a purchase price above [_1][_4]. Please accordingly increase the contract amount to meet this minimum stake.",
                $currency,
                to_monetary_number_format($contract->ask_price),
                $landing_company->name,
                to_monetary_number_format($stake_limit)
            ),
        );
    }
    return;
}

=head2 $self->_validate_payout_limit

Validate if payout is not over the client limits

=cut

sub _validate_payout_limit {
    my $self = shift;

    my $client   = $self->client;
    my $contract = $self->contract;
    my $payout   = $contract->is_spread ? $contract->amount_per_point * $contract->stop_profit : $self->payout;

    my $custom_limit = BOM::Platform::CustomClientLimits->new->client_payout_limit_for_contract($client->loginid, $contract);

    if (defined $custom_limit and $payout > $custom_limit) {
        return Error::Base->cuss(
            -type              => 'PayoutLimitExceeded',
            -mesg              => $client->loginid . ' payout [' . $payout . '] over custom limit[' . $custom_limit . ']',
            -message_to_client => ($custom_limit == 0)
            ? BOM::Platform::Context::localize('This contract is unavailable on this account.')
            : BOM::Platform::Context::localize(
                'This contract is limited to ' . to_monetary_number_format($custom_limit) . ' payout on this account.'
            ),
        );
    }
    return;
}

=head2 $self->_validate_jurisdictional_restrictions

Validates whether the client has provided his residence country

=cut

sub _validate_jurisdictional_restrictions {
    my $self        = shift;
    my $client      = $self->client;
    my $contract    = $self->contract;
    my $residence   = $client->residence;
    my $loginid     = $client->loginid;
    my $market_name = $contract->market->name;

    if (!$residence && $loginid !~ /^VRT/) {
        return Error::Base->cuss(
            -type              => 'NoResidenceCountry',
            -mesg              => 'Client cannot place contract as we do not know their residence.',
            -message_to_client => BOM::Platform::Context::localize(
                'In order for you to place contracts, we need to know your Residence (Country). Please update your settings.'),
        );
    }

    if (not grep { $market_name eq $_ } @{BOM::Platform::Runtime->instance->broker_codes->landing_company_for($loginid)->legal_allowed_markets}) {
        return Error::Base->cuss(
            -type              => 'NotLegalMarket',
            -mesg              => 'Clients are not allowed to trade on this markets as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this market.'),
        );
    }

    if ($residence && $market_name eq 'random') {
        foreach my $country_code (map { Locale::Country::country2code($_) }
            @{BOM::Platform::Runtime->instance->app_config->legal->random_restricted_countries})
        {
            if ($residence =~ /$country_code/i) {
                return Error::Base->cuss(
                    -type => 'RandomRestrictedCountry',
                    -mesg => 'Clients are not allowed to place Random contracts as their country is restricted.',
                    -message_to_client =>
                        BOM::Platform::Context::localize('Sorry, contracts on Random Indices are not available in your country of residence'),
                );
            }
        }
    }

    return;
}

=head2 $self->_validate_client_status

Validates to make sure that the client with unwelcome status
is not able to purchase contract

=cut

sub _validate_client_status {
    my $self   = shift;
    my $client = $self->client;

    if ($client->get_status('unwelcome') or $client->get_status('disabled')) {
        return Error::Base->cuss(
            -type              => 'ClientUnwelcome',
            -mesg              => 'your account is not authorised for any further contract purchases.',
            -message_to_client => BOM::Platform::Context::localize('Sorry, your account is not authorised for any further contract purchases.'),
        );
    }

    return;
}

=head2 sell_expired_contracts

Static function: Sells expired contracts.
For contracts with missing market data, settle them manually for real money accounts, but sell with purchase price for virtual account

Returns: HashRef, with:
'total_credited', total amount credited to Client
'skip_contract', count for expired contracts that failed to be sold

=cut

my %source_to_sell_type = (
    1063 => 'expiryd',    # app_id for `binaryexpiryd`, see `expiryd.pl`
);

sub sell_expired_contracts {
    my $args         = shift;
    my $client       = $args->{client};
    my $source       = $args->{source};
    my $contract_ids = $args->{contract_ids};

    my $time_start = Time::HiRes::time;

    my $currency = $client->currency;
    my $loginid  = $client->loginid;

    my $mapper = BOM::Database::DataMapper::FinancialMarketBet->new({
        client_loginid => $loginid,
        currency_code  => $currency,
        broker_code    => $client->broker_code,
        operation      => 'replica',
    });

    my $bets =
          (defined $contract_ids)
        ? [map { $_->financial_market_bet_record } @{$mapper->get_fmb_by_id($contract_ids)}]
        : $mapper->get_fmbs_by_loginid_and_currency({
            exclude_sold => 1,
            only_expired => $args->{only_expired},
        });

    return unless $bets and @$bets;

    my $now = Date::Utility->new;
    my @bets_to_sell;
    my @transdata;
    my %stats_attempt;
    for my $bet (@$bets) {
        my $contract = produce_contract($bet->{short_code}, $currency);
        $stats_attempt{$BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code}}++;
        next if not $contract->is_expired or $contract->category_code eq 'legacy';

        try {
            if ($contract->is_valid_to_sell) {
                @{$bet}{qw/sell_price sell_time/} = ($contract->bid_price, $now->db_timestamp);
                $bet->{absolute_barrier} = $contract->barrier->as_absolute
                    if $contract->category_code eq 'asian' and $contract->is_after_expiry;
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };
            } elsif ($client->is_virtual and ($contract->is_spread or ($now->epoch >= $contract->date_settlement->epoch + 3600))) {
                # for virtual, if can't settle bet due to missing market data, sell contract with buy price
                @{$bet}{qw/sell_price sell_time/} = ($bet->{buy_price}, $now->db_timestamp);
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };
            }
        };
    }

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::System::Config::env;
    my $sell_type = (defined $source and exists $source_to_sell_type{$source}) ? $source_to_sell_type{$source} : 'expired';
    my @tags      = ("broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "sell_type:$sell_type");
    for my $class (keys %stats_attempt) {
        stats_count("transaction.sell.attempt", $stats_attempt{$class}, {tags => [@tags, "contract_class:$class"]});
    }

    return unless @bets_to_sell;    # nothing to do

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        transaction_data => \@transdata,
        bet_data         => \@bets_to_sell,
        account_data     => {
            client_loginid => $loginid,
            currency_code  => $currency
        },
        db => BOM::Database::ClientDB->new({broker_code => $client->broker_code})->db,
    );

    my $sold = try {
        $fmb_helper->batch_sell_bet;
    }
    catch {
        get_logger->warn(ref eq 'ARRAY' ? "@$_" : "$_");
    };

    return unless $sold and @$sold;    # nothing has been sold

    my $skip_contract  = @$bets - @$sold;
    my $total_credited = 0;
    my %stats_success;
    for my $t (@$sold) {
        $total_credited += $t->{txn}->{amount};
        $stats_success{$t->{fmb}->{bet_class}}->[0]++;
        $stats_success{$t->{fmb}->{bet_class}}->[1] += $t->{txn}->{amount};
    }
    for my $class (keys %stats_success) {
        stats_count("transaction.sell.success", $stats_success{$class}->[0], {tags => [@tags, "contract_class:$class"]});
        if ($rmgenv eq 'production' and $virtual eq 'no') {
            my $usd_amount = int(in_USD($stats_success{$class}->[1], $currency) * 100);
            stats_count('business.buy_minus_sell_usd', -$usd_amount, {tags => [@tags, "contract_class:$class"]});
        }
    }

    return {
        skip_contract       => $skip_contract,
        total_credited      => $total_credited,
        number_of_sold_bets => 0 + @$sold,
    };
}

=head2 validate_request_method

Static function: Validate the request method to POST

Returns: Error::Base object with message to client

=cut

sub validate_request_method {
    if (BOM::Platform::Context::request()->http_method ne 'POST') {
        return Error::Base->cuss(
            -type              => 'RequestNotPost',
            -mesg              => 'Sorry, this page cannot be refreshed.',
            -message_to_client => BOM::Platform::Context::localize('Sorry, this page cannot be refreshed.'),
        );
    }
    return;
}

sub report {
    my $self = shift;
    return
          "Transaction Report:\n"
        . sprintf("%30s: %s\n", 'Client',                 $self->client)
        . sprintf("%30s: %s\n", 'Contract',               $self->contract->code)
        . sprintf("%30s: %s\n", 'Price',                  $self->price)
        . sprintf("%30s: %s\n", 'Payout',                 $self->payout)
        . sprintf("%30s: %s\n", 'Amount Type',            $self->amount_type)
        . sprintf("%30s: %s\n", 'Comment',                $self->comment || '')
        . sprintf("%30s: %s\n", 'Staff',                  $self->staff)
        . sprintf("%30s: %s",   'Transaction Parameters', Dumper($self->transaction_parameters))
        . sprintf("%30s: %s\n", 'Transaction ID',         $self->transaction_id || -1)
        . sprintf("%30s: %s\n", 'Purchase Date',          $self->purchase_date->datetime_yyyymmdd_hhmmss);
}

no Moose;

__PACKAGE__->meta->make_immutable;

1;
