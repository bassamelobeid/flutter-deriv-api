package BOM::Product::Transaction;

use Moose;
use Data::Dumper;
use Error::Base;
use Path::Tiny;
use Scalar::Util qw(blessed);
use Time::HiRes qw(tv_interval gettimeofday time);
use List::Util qw(min max first);
use JSON qw( from_json to_json );
use Date::Utility;
use ExpiryQueue qw( enqueue_new_transaction enqueue_multiple_new_transactions );
use Format::Util::Numbers qw(commas roundnear to_monetary_number_format);
use Try::Tiny;
use YAML::XS qw(LoadFile);

use BOM::Platform::Context qw(localize);
use BOM::Platform::Runtime;
use LandingCompany::Countries;
use Client::Account;
use BOM::System::Config;
use BOM::Product::ContractFactory qw( produce_contract make_similar_contract );
use Postgres::FeedDB::CurrencyConverter qw(in_USD amount_from_to_currency);
use BOM::Database::DataMapper::Payment;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::FinancialMarketBet;
use DataDog::DogStatsd::Helper qw(stats_inc stats_timing stats_count);
use BOM::Database::ClientDB;
use BOM::Database::Model::Account;
use BOM::Database::Model::DataCollection::QuantsBetVariables;
use BOM::Database::Model::Constants;
use BOM::Database::Helper::FinancialMarketBet;
use BOM::Database::Helper::RejectedTrade;
use LandingCompany::Registry;
use BOM::Database::ClientDB;
use Finance::Asset::Market::Types;

has client => (
    is  => 'ro',
    isa => 'Client::Account',
);

has multiple => (
    is  => 'ro',
    isa => 'Maybe[ArrayRef]',
);

has contract => (
    is => 'rw',
);

has price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

# price_slippage is the price difference between the requested buy or sell price from the recomputed price.
# If the slippage is within the acceptable amount, 50% of commission then we will honour the requested price.
has price_slippage => (
    is      => 'rw',
    default => 0,
);

# trading period of a contract
has trading_period_start => (
    is     => 'rw',
    isa    => 'date_object',
    coerce => 1,
);

# This is the requested buy or sell price
has requested_price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

# This is the recomputed buy or sell price
has recomputed_price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has transaction_record => (
    is         => 'ro',
    isa        => 'BOM::Database::AutoGenerated::Rose::Transaction',
    lazy_build => 1,
);

sub _build_transaction_record {
    my $self = shift;
    my $id = $self->transaction_id || die 'transaction not written yet';
    return $self->client->default_account->find_transaction({id => $id})->[0];
}

has balance_after => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has limits => (
    is      => 'rw',
    isa     => 'HashRef',
    default => sub { +{} },
);

has payout => (
    is         => 'rw',
    isa        => 'Num',
    lazy_build => 1,
);

sub _build_payout {
    my $self = shift;
    return $self->contract->payout;
}

has amount_type => (
    is      => 'rw',
    isa     => 'Str',
    default => 'payout',
);

has comment => (
    is      => 'rw',
    isa     => 'ArrayRef',
    default => sub { [] },
);

has staff => (
    is         => 'rw',
    isa        => 'Str',
    lazy_build => 1,
);

sub _build_staff {
    my $self = shift;
    return $self->client->loginid;
}

has transaction_id => (
    is  => 'rw',
    isa => 'Int',
);

has contract_id => (
    is  => 'rw',
    isa => 'Int',
);

has execute_at_better_price => (
    is      => 'rw',
    isa     => 'Bool',
    default => 0,
);

# calling server should capture time of request
has purchase_date => (
    is         => 'rw',
    isa        => 'date_object',
    coerce     => 1,
    lazy_build => 1,
);

has contract_class => (
    is  => 'rw',
    isa => 'Str',
);

has source => (
    is  => 'ro',
    isa => 'Maybe[Int]',
);

has transaction_parameters => (
    is      => 'ro',
    isa     => 'HashRef',
    default => sub { {}; },
);

has app_markup => (
    is         => 'ro',
    isa        => 'Maybe[Num]',
    lazy_build => 1
);

sub _build_app_markup {
    my $self = shift;

    return 0 if $self->contract->is_spread;
    return $self->contract->app_markup_dollar_amount;
}

sub BUILDARGS {
    my ($class, $args) = @_;

    if (exists $args->{price}) {
        $args->{transaction_parameters}->{price} = $args->{price};
    }
    if (exists $args->{payout}) {
        $args->{transaction_parameters}->{payout} = $args->{payout};
    }
    return $args;
}

my $payment_limits = LoadFile(File::ShareDir::dist_file('Client-Account', 'payment_limits.yml'));

my %known_errors;              # forward declaration
sub sell_expired_contracts;    # forward declaration

sub _build_purchase_date {

# Purchase is considered to have happened at time of request; if no such info available, then now.
# Classic case: REQUEST_STARTTIME is present (epoch-style) in the binary.com cgi context.
    return $ENV{REQUEST_STARTTIME} // time;
}

sub stats_start {
    my $self = shift;
    my $what = shift;

    my $client   = $self->client;
    my $contract = $self->contract;

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::System::Config::env;
    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    my $tags      = {tags => ["broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "contract_class:$bet_class",]};

    if ($what eq 'buy' or $what eq 'batch_buy') {
        if ($self->contract->is_spread) {
            push @{$tags->{tags}}, "stop_type:" . lc($contract->stop_type);
        } else {
            push @{$tags->{tags}}, "amount_type:" . lc($self->amount_type), "expiry_type:" . ($contract->fixed_expiry ? 'fixed' : 'duration');
        }
    } elsif ($what eq 'sell') {
        push @{$tags->{tags}}, "sell_type:manual";
    }
    stats_inc("transaction.$what.attempt", $tags);

    return +{
        start   => [gettimeofday],
        tags    => $tags,
        virtual => $virtual,
        rmgenv  => $rmgenv,
        what    => $what,
    };
}

sub stats_validation_done {
    my $self = shift;
    my $data = shift;

    $data->{validation_done} = [gettimeofday];

    return;
}

# Given a generic error, try to turn it into a tag-friendly string which
# might be the same across multiple failures.
sub _normalize_error {
    my $error = shift;

    if (my $whatsit = blessed $error) {
        if ($whatsit eq 'Error::Base') {
            my $type = $error->get_type;    # These are nice short camelCase descriptions
            $error = (
                       $type eq 'InvalidtoBuy'
                    or $type eq 'InvalidtoSell'
            ) ? $error->get_mesg : $type;    # In these special cases, we'd like to get the underlying contract message, instead.
        } elsif ($whatsit eq 'MooseX::Role::Validatable::Error') {
            $error = $error->message;        # These should be sentence-like.
        } else {
            $error = "$error";               # Assume it's stringifiable.
        }
    }

    $error =~ s/(?<=[^A-Z])([A-Z])/ $1/g;    # camelCase to words
    $error =~ s/\[[^\]]+\]//g;               # Bits between [] should be dynamic
    $error = join('_', split /\s+/, lc $error);

    return $error;
}

sub stats_stop {
    my ($self, $data, $error, $extra) = @_;

    my $what = $data->{what};
    my $tags = $data->{tags};

    if ($error) {
        stats_inc("transaction.$what.failure", {tags => [@{$tags->{tags}}, 'reason:' . _normalize_error($error)]});

        return $error;
    }

    my $now = [gettimeofday];
    stats_timing("transaction.$what.elapsed_time", 1000 * tv_interval($data->{start},           $now), $tags);
    stats_timing("transaction.$what.db_time",      1000 * tv_interval($data->{validation_done}, $now), $tags);
    stats_inc("transaction.$what.success", $tags);

    if ($what eq 'batch_buy') {
        my @tags = grep { !/^(?:broker|virtual):/ } @{$tags->{tags}};
        for my $broker (keys %$extra) {
            my $xd = $extra->{$broker};
            my $tags = {tags => ["broker:" . lc($broker), "virtual:" . ($broker =~ /^VR/ ? "yes" : "no"), @tags]};
            stats_count("transaction.buy.attempt", $xd->{attempt}, $tags);
            stats_count("transaction.buy.success", $xd->{success}, $tags);

            next if $broker =~ /^VR/ or $data->{rmgenv} ne 'production';

            my $usd_amount = $xd->{success} * int(in_USD($self->price, $self->contract->currency) * 100);
            stats_count('business.turnover_usd',       $usd_amount, $tags);
            stats_count('business.buy_minus_sell_usd', $usd_amount, $tags);
        }
        return;
    }

    if ($data->{rmgenv} eq 'production' and $data->{virtual} eq 'no') {
        my $usd_amount = int(in_USD($self->price, $self->contract->currency) * 100);
        if ($what eq 'buy') {
            stats_count('business.turnover_usd',       $usd_amount, $tags);
            stats_count('business.buy_minus_sell_usd', $usd_amount, $tags);
        } elsif ($what eq 'sell') {
            stats_count('business.buy_minus_sell_usd', -$usd_amount, $tags);
        }
    }

    return;
}

sub calculate_limits {
    my $self = shift;
    my $client = shift || $self->client;

    my %limits;

    my $static_config = BOM::System::Config::quants;

    my $contract = $self->contract;
    my $currency = $contract->currency;

    $limits{max_balance} = $client->get_limit_for_account_balance;

    if (not $contract->tick_expiry) {
        $limits{max_open_bets}        = $client->get_limit_for_open_positions;
        $limits{max_payout_open_bets} = $client->get_limit_for_payout;
        $limits{max_payout_per_symbol_and_bet_type} =
            $static_config->{bet_limits}->{open_positions_payout_per_symbol_and_bet_type_limit}->{$currency};
    }

    my $lim;
    defined($lim = $client->get_limit_for_daily_losses)
        and $limits{max_losses} = $lim;
    defined($lim = $client->get_limit_for_7day_turnover)
        and $limits{max_7day_turnover} = $lim;
    defined($lim = $client->get_limit_for_7day_losses)
        and $limits{max_7day_losses} = $lim;
    defined($lim = $client->get_limit_for_30day_turnover)
        and $limits{max_30day_turnover} = $lim;
    defined($lim = $client->get_limit_for_30day_losses)
        and $limits{max_30day_losses} = $lim;

    $limits{max_turnover} = $client->get_limit_for_daily_turnover;

    my $rp    = $contract->risk_profile;
    my @cl_rp = $rp->get_client_profiles($client);
    if ($contract->is_spread) {
        # limits are calculated differently for spreads
        $limits{spread_bet_profit_limit} = $static_config->{risk_profile}{$rp->get_risk_profile(\@cl_rp)}{turnover}{$currency};
    } else {
        push @{$limits{specific_turnover_limits}}, @{$rp->get_turnover_limit_parameters(\@cl_rp)};
    }

    return \%limits;
}

sub prepare_bet_data_for_buy {
    my $self = shift;

    my $client   = $self->client;
    my $contract = $self->contract;

    if ($self->purchase_date->is_after($contract->date_start)) {
        my $d1 = $self->purchase_date->datetime_yyyymmdd_hhmmss;
        my $d2 = $contract->date_start->datetime_yyyymmdd_hhmmss;
        return Error::Base->cuss(
            -type              => 'ContractAlreadyStarted',
            -mesg              => "buy at $d1 too late for $d2 contract",
            -message_to_client => BOM::Platform::Context::localize("Start time is in the past"));
    }

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        quantity          => 1,
        short_code        => scalar $contract->shortcode,
        buy_price         => $self->price,
        remark            => $self->comment->[0] || '',
        underlying_symbol => scalar $contract->underlying->symbol,
        bet_type          => scalar $contract->code,
        bet_class         => $bet_class,
        purchase_time     => scalar $self->purchase_date->db_timestamp,
        start_time        => scalar $contract->date_start->db_timestamp,
        expiry_time       => scalar $contract->date_expiry->db_timestamp,
        settlement_time   => scalar $contract->date_settlement->db_timestamp,
        payout_price      => scalar $self->payout,
    };

    $bet_params->{expiry_daily} = 1 if $contract->expiry_daily;
    $bet_params->{fixed_expiry} = 1 if $contract->fixed_expiry;
    if ($contract->tick_expiry) {
        $bet_params->{tick_expiry} = 1;
        $bet_params->{tick_count}  = scalar $contract->tick_count;
    }

    if ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_SPREAD_BET) {
        $bet_params->{$_} = $contract->$_ for qw(amount_per_point spread stop_type spread_divisor);
        $bet_params->{stop_loss}   = $contract->supplied_stop_loss;
        $bet_params->{stop_profit} = $contract->supplied_stop_profit;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_HIGHER_LOWER_BET) {
        # only store barrier in the database if it is defined.
        # asian contracts have barriers at/after expiry.
        if ($contract->barrier) {
            $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
        }
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_DIGIT_BET) {
        $bet_params->{prediction} = $contract->sentiment;
        $bet_params->{last_digit} = $contract->barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_RANGE_BET) {
        $bet_params->{$contract->high_barrier->barrier_type . '_higher_barrier'} = $contract->high_barrier->supplied_barrier;
        $bet_params->{$contract->low_barrier->barrier_type . '_lower_barrier'}   = $contract->low_barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_TOUCH_BET) {
        $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
    } else {
        return Error::Base->cuss(
            -type              => 'UnsupportedBetClass',
            -mesg              => "Unsupported bet class $bet_params->{bet_class}",
            -message_to_client => BOM::Platform::Context::localize("Unsupported bet class $bet_params->{bet_class}"),
        );
    }

    my $quants_bet_variables;
    if (my $comment_hash = $self->comment->[1]) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $comment_hash,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
                app_markup    => $self->app_markup
            },
            bet_data             => $bet_params,
            quants_bet_variables => $quants_bet_variables,
        });
}

sub prepare_buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my %options = @_;

    my $error_status;

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        #
        # Keep the transaction rate test first to limit the impact of abusive buyers
        $error_status = $self->$_ and return $error_status
            for (
            qw/
            _validate_iom_withdrawal_limit
            _validate_available_currency
            _validate_currency
            _validate_jurisdictional_restrictions
            _validate_client_status
            _validate_client_self_exclusion

            _is_valid_to_buy
            _validate_date_pricing
            _validate_trade_pricing_adjustment

            _validate_payout_limit
            _validate_stake_limit/
            );

        if ($self->multiple) {
            for my $m (@{$self->multiple}) {
                next if $m->{code};
                $m->{limits} = $self->calculate_limits($m->{client});
            }
        } else {
            $self->limits($self->calculate_limits);
        }

        $self->comment(
            _build_pricing_comment({
                    contract         => $self->contract,
                    price            => $self->price,
                    requested_price  => $self->requested_price,
                    recomputed_price => $self->recomputed_price,
                    ($self->price_slippage) ? (price_slippage => $self->price_slippage) : (),
                    ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                    action => 'buy'
                })) unless @{$self->comment};
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_buy;
    return $error_status if $error_status;

    return $error_status, $bet_data;
}

sub buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my @options = @_;

    my $stats_data = $self->stats_start('buy');

    my ($error_status, $bet_data) = $self->prepare_buy(@options);
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        account_data => {
            client_loginid => $self->client->loginid,
            currency_code  => $self->contract->currency,
        },
        limits => $self->limits,
        db     => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $try   = 0;
    my $error = 1;
    my ($fmb, $txn);
    TRY: {
        try {
            ($fmb, $txn) = $fmb_helper->buy_bet;
            $error = 0;
        }
        catch {
            # $error_status==undef means repeat operation
            # if $error_status is defined, return it
            # otherwise the function re-throws the exception (unrecoverable).
            $error_status = $self->_recover($_, $try);
        };
        return $self->stats_stop($stats_data, $error_status) if $error_status;
        redo TRY if $error and $try++ < 3;
    }

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});
    $self->contract_id($fmb->{id});

    enqueue_new_transaction($self);    # For soft realtime expiration notification.

    return;
}

# expected parameters:
# $self->multiple
#   an array of hashes. Elements with a key "code" are ignored. They are
#   thought to be already erroneous. Otherwise the element should contain
#   a "loginid" key.
#   The following keys are added:
#   * client: the Client::Account object corresponding to the loginid
#   * limits: a hash representing the betting limits of this client
#   * fmb and txn: the FMB and transaction records that have been written
#     to the database in case of success
#   * code and error: in case of an error during the transaction these keys
#     contain the error description corresponding to the usual -type and
#     -message_to_client members of an Error::Base object.
# $self->contract
#   the contract
# $self->staff
# $self->source
# ...
#
# set or modified during operation:
# $self->price
#   the price
# @{$self->multiple}
#   see above
#
# return value:
#   - empty list on success. Success means the database function has been called.
#     It does not mean any contract has been bought.
#   - an Error::Base object indicates that something more fundamental went wrong.
#     For instance the contract's start date may be in the past.
#
# Exceptions:
#   The function may throw exceptions. However, it is guaranteed that after
#   contract validation no exception whatsoever is thrown. That means there
#   is no way for a contract to be bought but not reported back to the caller.

sub batch_buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my @options = @_;

    # TODO: shall we allow this operation only if $self->client is real-money?
    #       Or allow virtual $self->client only if all other clients are also
    #       virtual?

    my $stats_data = $self->stats_start('batch_buy');

    for my $m (@{$self->multiple}) {
        next if $m->{code};
        my $c = try { Client::Account->new({loginid => $m->{loginid}}) };
        unless ($c) {
            $m->{code}  = 'InvalidLoginid';
            $m->{error} = BOM::Platform::Context::localize('Invalid loginid');
            next;
        }

        $m->{client} = $c;
    }

    my ($error_status, $bet_data) = $self->prepare_buy(@options);
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my %per_broker;
    for my $m (@{$self->multiple}) {
        next if $m->{code};
        push @{$per_broker{$m->{client}->broker_code}}, $m;
    }

    my %stat = map { $_ => {attempt => 0 + @{$per_broker{$_}}} } keys %per_broker;

    for my $broker (keys %per_broker) {
        my $list = $per_broker{$broker};
        # with hash key caching introduced in recent perl versions
        # the "map sort map" pattern does not make sense anymore.

        # this sorting is to prevent deadlocks in the database
        @$list = sort { $a->{loginid} cmp $b->{loginid} } @$list;

        my @general_error = ('UnexpectedError', BOM::Platform::Context::localize('An unexpected error occurred'));

        try {
            my $currency   = $self->contract->currency;
            my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
                %$bet_data,
                # great readablility provided by our tidy rules
                account_data => [map                                      { +{client_loginid => $_->{loginid}, currency_code => $currency} } @$list],
                limits       => [map                                      { $_->{limits} } @$list],
                db           => BOM::Database::ClientDB->new({broker_code => $broker})->db,
            );

            my $success = 0;
            my $result  = $fmb_helper->batch_buy_bet;
            for my $el (@$list) {
                my $res = shift @$result;
                if (my $ecode = $res->{e_code}) {
                    # map DB errors to client messages
                    if (my $ref = $known_errors{$ecode}) {
                        my $error = (
                            ref $ref eq 'CODE'
                            ? $ref->(
                                $self, $el->{client},
                                1_000_000,    # fake an insanely high retry count
                                $res->{e_description})
                            : $ref
                        );
                        $el->{code}  = $error->{-type};
                        $el->{error} = $error->{-message_to_client};
                    } else {
                        @{$el}{qw/code error/} = @general_error;
                    }
                } else {
                    $el->{fmb} = $res->{fmb};
                    $el->{txn} = $res->{txn};
                    $success++;
                }
            }
            $stat{$broker}->{success} = $success;
            enqueue_multiple_new_transactions $self, [grep { !$_->{code} } @$list];
        }
        catch {
            warn __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it

            for my $el (@$list) {
                @{$el}{qw/code error/} = @general_error unless $el->{code} or $el->{fmb};
            }
        };
    }

    $self->stats_stop($stats_data, undef, \%stat);

    return;
}

sub prepare_bet_data_for_sell {
    my $self = shift;
    my $contract = shift || $self->contract;

    my $client   = $self->client;
    my $loginid  = $client->loginid;
    my $currency = $contract->currency;

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        id         => scalar $self->contract_id,
        sell_price => scalar $self->price,
        sell_time  => scalar $contract->date_pricing->db_timestamp,
        $contract->category_code eq 'asian' && $contract->is_after_settlement
        ? (absolute_barrier => scalar $contract->barrier->as_absolute)
        : (),
    };

    my $quants_bet_variables;
    if (my $comment_hash = $self->comment->[1]) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $comment_hash,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
            },
            bet_data     => $bet_params,
            account_data => {
                client_loginid => $loginid,
                currency_code  => $currency
            },
            quants_bet_variables => $quants_bet_variables,
        });
}

sub sell {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my %options = @_;

    my $error_status;

    my $stats_data = $self->stats_start('sell');

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        $error_status = $self->$_ and return $self->stats_stop($stats_data, $error_status)
            for (
            qw/
            _validate_iom_withdrawal_limit
            _is_valid_to_sell
            _validate_available_currency
            _validate_currency
            _validate_sell_pricing_adjustment
            _validate_date_pricing/
            );

        $self->comment(
            _build_pricing_comment({
                    contract         => $self->contract,
                    price            => $self->price,
                    requested_price  => $self->requested_price,
                    recomputed_price => $self->recomputed_price,
                    ($self->price_slippage) ? (price_slippage => $self->price_slippage) : (),
                    ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                    action => 'sell'
                })) unless @{$self->comment};
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_sell;
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $try   = 0;
    my $error = 1;
    my ($fmb, $txn);
    TRY: {
        try {
            ($fmb, $txn) = $fmb_helper->sell_bet;
            $error = 0;
        }
        catch {
            # $error_status==undef means repeat operation
            # if $error_status is defined, return it
            # otherwise the function re-throws the exception (unrecoverable).
            $error_status = $self->_recover($_, $try);
        };
        return $self->stats_stop($stats_data, $error_status) if $error_status;
        redo TRY if $error and $try++ < 3;
    }

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'NoOpenPosition',
            -mesg              => 'No such open contract.',
            -message_to_client => BOM::Platform::Context::localize('This contract was not found among your open positions.'),
        )) unless defined $txn->{id};

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});

    return;
}

=head2 C<< $self->_recover($error, $retry) >>

This function tries to recover from an unsuccessful buy/sell.
It may decide to retry the operation. And it may decide to
sell expired bets before doing so.

=head4 Parameters

=over 4

=item * C<< $error >>

the error exception thrown by BOM::Platform::Data::Persistence::DB::_handle_errors

=item * C<< $retry >>

an optional count of how many times the operation has been tried before.
Default is 0.

=back

=head3 Return Value

=over 4

=item * the empty list

which means I<please retry the operation, and, in case of an error, get
back with a C<$retry> count incremented by 1>.

=item * an L<Error::Base> object

which means an unrecoverable but expected condition has been found.
Typically that means a precondition, like sufficient balance, was
not met.

The caller should not retry the operation or try to amend the
situation. Instead it should pass on the error to the client.

=back

Be aware that the function may throw an exception.

=head3 Exceptions

In case of an unexpected error, the exception is re-thrown unmodified.

=cut

%known_errors = (
    BI001 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_daily_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your daily turnover limit of [_1][_2].',
            $currency, $limit);
        if (not $client->client_fully_authenticated) {
            $error_message .= ' ' . BOM::Platform::Context::localize('If you wish to raise these limits, please authenticate your account.');
        }

        return Error::Base->cuss(
            -type              => 'DailyTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a daily turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI002 => sub {
        my $self   = shift;
        my $client = shift;
        my $retry  = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $limit = $client->get_limit_for_open_positions;
        return Error::Base->cuss(
            -type              => 'OpenPositionLimit',
            -mesg              => "Client has reached the limit of $limit open positions.",
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, you cannot hold more than [_1] contracts at a given time. Please visit the statement page to automatically sell your expired contracts.',
                $limit
            ),
        );
    },
    BI003 => sub {
        my $self   = shift;
        my $client = shift;
        my $retry  = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $currency = $self->contract->currency;
        my $account  = BOM::Database::DataMapper::Account->new({
            client_loginid => $client->loginid,
            currency_code  => $currency,
        });
        my $balance = $currency eq 'JPY' ? commas($account->get_balance(), 0) : to_monetary_number_format($account->get_balance());
        my $price   = $currency eq 'JPY' ? commas($self->price,            0) : to_monetary_number_format($self->price);

        return Error::Base->cuss(
            -type              => 'InsufficientBalance',
            -message           => 'Client\'s account balance was insufficient to buy bet.',
            -message_to_client => BOM::Platform::Context::localize(
                'Your account balance ([_1][_2]) is insufficient to buy this contract ([_1][_3]).',
                $currency, $balance, $price
            ));
    },
    BI007 => sub {
        my $self   = shift;
        my $client = shift;
        my $retry  = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        return Error::Base->cuss(
            -type              => 'PotentialPayoutLimitForSameContractExceeded',
            -mesg              => "Client has exceeded potential payout limit for open contracts with the same symbol and bet_type",
            -message_to_client => BOM::Platform::Context::localize(
                'Purchase of this contract would cause you to exceed our payout limit for open contracts of this type. To continue please consider to sell a few contracts at the market or trade in different contract types.'
            ),
        );
    },
    BI008 => sub {
        my $self   = shift;
        my $client = shift;
        my $retry  = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_account_balance, 1);

        my $account = BOM::Database::DataMapper::Account->new({
            client_loginid => $client->loginid,
            currency_code  => $currency,
        });
        my $balance = $account->get_balance();

        return Error::Base->cuss(
            -type              => 'AccountBalanceExceedsLimit',
            -mesg              => 'Client balance is above the allowed limits',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, your account cash balance is too high ([_1]). Your maximum account balance is [_2].', "$currency$balance",
                "$currency$limit"
            ),
        );
    },
    BI009 => sub {
        my $self   = shift;
        my $client = shift;
        my $retry  = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_payout, 1);

        return Error::Base->cuss(
            -type              => 'OpenPositionPayoutLimit',
            -mesg              => 'Client has reached maximum net payout for open positions',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, the aggregate payouts of contracts on your account cannot exceed [_1][_2].',
                $currency, $limit
            ),
        );
    },
    BI010 => Error::Base->cuss(
        -type              => 'PromoCodeLimitExceeded',
        -mesg              => 'Client won more than 25 times of the promo code amount',
        -message_to_client => BOM::Platform::Context::localize(
            'Your account has exceeded the trading limit with free promo code, please deposit if you wish to continue trading.'),
    ),
    BI011 => sub {
        my $self   = shift;
        my $client = shift;
        my $retry  = shift;
        my $msg    = shift;

        my $limit_name = 'Unknown';
        $msg =~ /^.+: ([^,]+)/ and $limit_name = $1;

        return Error::Base->cuss(
            -type              => $limit_name . 'Exceeded',
            -mesg              => 'Exceeds turnover limit on ' . $limit_name,
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI012 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_daily_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your daily limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => 'DailyLossLimitExceeded',
            -mesg              => "Client has exceeded his daily loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI013 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_7day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your 7-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 7-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI014 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_7day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 7-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 7-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI015 => sub {
        my $self = shift;

        return Error::Base->cuss(
            -type              => 'SpreadDailyProfitLimitExceeded',
            -mesg              => 'Exceeds profit limit on spread',
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI016 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_30day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your 30-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 30-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI017 => sub {
        my $self   = shift;
        my $client = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($client->get_limit_for_30day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 30-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 30-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI018 => sub {
        my $self   = shift;
        my $client = shift;

        return Error::Base->cuss(
            -type              => 'DailyProfitLimitExceeded',
            -mesg              => 'Exceeds daily profit limit',
            -message_to_client => BOM::Platform::Context::localize('No further trading is allowed for the current trading session.'),
        );
    },
);

sub _recover {
    my $self  = shift;
    my $err   = shift;
    my $retry = shift // 0;

    if (ref($err) eq 'ARRAY') {    # special BINARY code
        my $ref = $known_errors{$err->[0]};
        return ref $ref eq 'CODE' ? $ref->($self, $self->client, $retry, $err->[1]) : $ref if $ref;
    } else {
        # TODO: recover from deadlocks & co.
    }
    die $err;
}

sub _validate_available_currency {
    my $self     = shift;
    my $currency = $self->contract->currency;

    if (not grep { $currency eq $_ } @{LandingCompany::Registry::get_by_broker($self->client->broker_code)->legal_allowed_currencies}) {
        return Error::Base->cuss(
            -type              => 'InvalidCurrency',
            -mesg              => "Invalid $currency",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is invalid.", $currency),
        );
    }
    return;
}

sub _create_validator {
    my $name   = shift;
    my $method = "_$name";

    my $sub = sub {
        my $self = shift;

        if ($self->multiple) {
            for my $m (@{$self->multiple}) {
                next if $m->{code};
                my $res = $self->$method($m->{client});
                if ($res) {
                    $m->{code}  = $res->{-type};
                    $m->{error} = $res->{-message_to_client};
                }
            }
            return;
        } else {
            return $self->$method($self->client);
        }
    };

    no warnings 'redefine';    ## no critic
    no strict 'refs';
    *{$name} = $sub;

    return;
}

sub __validate_currency {
    my $self     = shift;
    my $client   = shift;
    my $broker   = $client->broker_code;
    my $currency = $self->contract->currency;

    if ($currency ne $client->currency) {
        return Error::Base->cuss(
            -type              => 'NotDefaultCurrency',
            -mesg              => "not default currency for client [$currency], client currency[" . $client->currency . "]",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is not the default currency", $currency),
        );
    }

    if (not LandingCompany::Registry::get_by_broker($broker)->is_currency_legal($currency)) {
        return Error::Base->cuss(
            -type              => 'IllegalCurrency',
            -mesg              => "Illegal $currency for $broker",
            -message_to_client => BOM::Platform::Context::localize("[_1] transactions may not be performed with this account.", $currency),
        );
    }
    return;
}
BEGIN { _create_validator '_validate_currency' }

sub _build_pricing_comment {
    my $args = shift;

    my ($contract, $price, $action, $price_slippage, $requested_price, $recomputed_price, $trading_period_start) =
        @{$args}{'contract', 'price', 'action', 'price_slippage', 'requested_price', 'recomputed_price', 'trading_period_start'};

    my @comment_fields;
    if ($contract->is_spread) {
        @comment_fields = map { defined $_->[1] ? @$_ : () } (
            [amount_per_point => $contract->amount_per_point],
            [stop_profit      => $contract->stop_profit],
            [stop_loss        => $contract->stop_loss],
            [spread           => $contract->spread],
        );
    } else {
        # This way the order of the fields is well-defined.
        @comment_fields = map { defined $_->[1] ? @$_ : (); } (
            [theo    => $contract->theo_price],
            [iv      => $contract->pricing_vol],
            [win     => $contract->payout],
            [div     => $contract->q_rate],
            [int     => $contract->r_rate],
            [delta   => $contract->delta],
            [gamma   => $contract->gamma],
            [vega    => $contract->vega],
            [theta   => $contract->theta],
            [vanna   => $contract->vanna],
            [volga   => $contract->volga],
            [bs_prob => $contract->bs_probability->amount],
            [spot    => $contract->current_spot]);

        # only manual sell and buy has a price
        if ($price) {
            push @comment_fields, (trade => $price);
        }

        if ($contract->entry_tick) {
            push @comment_fields, (entry_spot       => $contract->entry_tick->quote);
            push @comment_fields, (entry_spot_epoch => $contract->entry_tick->epoch);
        }

        # Record price slippage in quants bet variable.
        # To always reproduce ask price, we would want to record the slippage allowed during transaction.
        if (defined $price_slippage) {
            push @comment_fields, (price_slippage => $price_slippage);
        }

        # Record requested price in quants bet variable.
        if (defined $requested_price) {
            push @comment_fields, (requested_price => $requested_price);
        }

        # Record recomputed price in quants bet variable.
        if (defined $recomputed_price) {
            push @comment_fields, (recomputed_price => $recomputed_price);
        }

        my $tick;
        if ($action eq 'sell') {
            # current tick is lazy, even though the realtime cache might have changed during the course of the transaction.
            $tick = $contract->current_tick;
        } elsif ($action eq 'autosell_expired_contract') {
            $tick = ($contract->is_path_dependent and $contract->hit_tick) ? $contract->hit_tick : $contract->exit_tick;
        }

        if ($tick) {
            push @comment_fields, (exit_spot       => $tick->quote);
            push @comment_fields, (exit_spot_epoch => $tick->epoch);
            if ($contract->two_barriers) {
                push @comment_fields, (high_barrier => $contract->high_barrier->as_absolute) if $contract->high_barrier;
                push @comment_fields, (low_barrier  => $contract->low_barrier->as_absolute)  if $contract->low_barrier;
            } else {
                push @comment_fields, (barrier => $contract->barrier->as_absolute) if $contract->barrier;
            }
        }

        my $news_factor = $contract->ask_probability->peek('news_factor');
        if ($news_factor) {
            push @comment_fields, news_fct => $news_factor->amount;
            my $news_impact = $news_factor->peek('news_impact');
            push @comment_fields, news_impact => $news_impact->amount if $news_impact;
        }

        if (@{$contract->corporate_actions}) {
            push @comment_fields,
                corporate_action => 1,
                actions          => join '|',
                map { $_->{description} . ',' . $_->{modifier} . ',' . $_->{value} } @{$contract->corporate_actions};
        }
    }

    my $comment_str = sprintf join(' ', ('%s[%0.5f]') x (@comment_fields / 2)), @comment_fields;

    if (defined $trading_period_start) {
        push @comment_fields, (trading_period_start => $trading_period_start);
    }

    my %comment_hash = map { $_ } @comment_fields;

    return [$comment_str, \%comment_hash];
}

sub _validate_sell_pricing_adjustment {
    my $self = shift;

    # always sell at recomputed bid price for spreads.
    if ($self->contract->is_spread or not defined $self->price) {
        $self->price($self->contract->bid_price);
        return;
    }

    if ($self->contract->is_expired) {
        return Error::Base->cuss(
            -type              => 'BetExpired',
            -mesg              => 'Contract expired with a new price',
            -message_to_client => BOM::Platform::Context::localize('The contract has expired'),
        );
    }

    my $contract = $self->contract;
    my $currency = $contract->currency;

    my $requested = $self->price / $self->payout;
    # set the requested price and recomputed  price to be store in db
    $self->requested_price($self->price);
    $self->recomputed_price($contract->bid_price);
    my $recomputed        = $contract->bid_probability->amount;
    my $move              = $recomputed - $requested;
    my $slippage          = $contract->bid_price - $self->price;
    my $commission_markup = 0;
    if (not $contract->is_expired) {
        $commission_markup = $contract->opposite_contract->commission_markup->amount || 0;
    }
    my $allowed_move = $commission_markup * 0.5;
    $allowed_move = 0 if $recomputed == 1;
    my ($amount, $recomputed_amount) = ($self->price, $contract->bid_price);

    if ($move != 0) {
        my $final_value;
        if ($allowed_move == 0) {
            $final_value = $recomputed_amount;
        } elsif ($move < -$allowed_move) {
            my $market_moved = BOM::Platform::Context::localize('The underlying market has moved too much since you priced the contract. ');
            $market_moved .= BOM::Platform::Context::localize(
                'The contract [_4] has changed from [_1][_2] to [_1][_3].',
                $currency,
                to_monetary_number_format($amount),
                to_monetary_number_format($recomputed_amount),
                'sell price'
            );

            #Record failed transaction here.
            my $rejected_trade = BOM::Database::Helper::RejectedTrade->new({
                    login_id                => $self->client->loginid,
                    financial_market_bet_id => $self->contract_id,
                    shortcode               => $self->contract->shortcode,
                    action_type             => 'sell',
                    reason                  => 'SLIPPAGE',
                    details                 => JSON::to_json({
                            order_price      => $self->price,
                            recomputed_price => $contract->bid_price,
                            slippage         => $slippage,
                            option_type      => $contract->code,
                            currency_pair    => $contract->underlying->symbol,
                            ($contract->two_barriers)
                            ? (barriers => $contract->low_barrier->as_absolute . "," . $contract->high_barrier->as_absolute)
                            : (barriers => $contract->barrier->as_absolute),
                            expiry => $contract->date_expiry->db_timestamp,
                            payout => $contract->payout
                        }
                    ),
                    db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
                });
            $rejected_trade->record_fail_txn();

            return Error::Base->cuss(
                -type => 'PriceMoved',
                -mesg =>
                    "Difference between submitted and newly calculated bet price: currency $currency, amount: $amount, recomputed amount: $recomputed_amount",
                -message_to_client => $market_moved,
            );
        } else {
            if ($move <= $allowed_move and $move >= -$allowed_move) {
                $final_value = $amount;
                # We absorbed the price difference here and we want to keep it in our book.
                $self->price_slippage($slippage);
            } elsif ($move > $allowed_move) {
                $self->execute_at_better_price(1);
                # We need to keep record of slippage even it is executed at better price
                $self->price_slippage($slippage);
                $final_value = $recomputed_amount;
            }
        }

        $self->price($final_value);
    }

    return;
}

sub _validate_trade_pricing_adjustment {
    my $self = shift;

    # always buy at recomputed ask price for spreads.
    if ($self->contract->is_spread) {
        $self->price($self->contract->ask_price);
        return;
    }

    my $amount_type = $self->amount_type;
    my $contract    = $self->contract;
    my $currency    = $contract->currency;

    my $requested = $self->price / $self->payout;
    # set the requested price and recomputed price to be store in db
    $self->requested_price($self->price);
    $self->recomputed_price($contract->ask_price);
    my $recomputed        = $contract->ask_probability->amount;
    my $move              = $requested - $recomputed;
    my $slippage          = $self->price - $contract->ask_price;
    my $commission_markup = 0;
    if (not $contract->is_expired) {
        $commission_markup = $contract->commission_markup->amount || 0;
    }
    my $allowed_move = ($self->contract->category->code eq 'digits') ? $commission_markup : ($commission_markup * 0.5);
    $allowed_move = 0 if $recomputed == 1;
    my ($amount, $recomputed_amount) = $amount_type eq 'payout' ? ($self->price, $contract->ask_price) : ($self->payout, $contract->payout);

    if ($move != 0) {
        my $final_value;
        if ($contract->is_expired) {
            return Error::Base->cuss(
                -type              => 'BetExpired',
                -mesg              => 'Bet expired with a new price[' . $recomputed_amount . '] (old price[' . $amount . '])',
                -message_to_client => BOM::Platform::Context::localize('The contract has expired'),
            );
        } elsif ($allowed_move == 0) {
            $final_value = $recomputed_amount;
        } elsif ($move < -$allowed_move) {
            my $what_changed = $amount_type eq 'payout' ? 'price' : 'payout';
            my $market_moved = BOM::Platform::Context::localize('The underlying market has moved too much since you priced the contract. ');
            $market_moved .= BOM::Platform::Context::localize(
                'The contract [_4] has changed from [_1][_2] to [_1][_3].',
                $currency,
                to_monetary_number_format($amount),
                to_monetary_number_format($recomputed_amount),
                $what_changed
            );

            #Record failed transaction here.
            my $rejected_trade = BOM::Database::Helper::RejectedTrade->new({
                    login_id    => $self->client->loginid,
                    shortcode   => $self->contract->shortcode,
                    action_type => 'buy',
                    reason      => 'SLIPPAGE',
                    details     => JSON::to_json({
                            order_price      => $self->price,
                            recomputed_price => $contract->ask_price,
                            slippage         => $slippage,
                            option_type      => $contract->code,
                            currency_pair    => $contract->underlying->symbol,
                            ($self->trading_period_start) ? (trading_period_start => $self->trading_period_start->db_timestamp) : (),
                            ($contract->two_barriers)
                            ? (barriers => $contract->low_barrier->as_absolute . "," . $contract->high_barrier->as_absolute)
                            : (barriers => $contract->barrier->as_absolute),
                            expiry => $contract->date_expiry->db_timestamp,
                            payout => $contract->payout
                        }
                    ),
                    db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
                });
            $rejected_trade->record_fail_txn();

            return Error::Base->cuss(
                -type => 'PriceMoved',
                -mesg =>
                    "Difference between submitted and newly calculated bet price: currency $currency, amount: $amount, recomputed amount: $recomputed_amount",
                -message_to_client => $market_moved,
            );
        } else {
            if ($move <= $allowed_move and $move >= -$allowed_move) {
                $final_value = $amount;
                # We absorbed the price difference here and we want to keep it in our book.
                $self->price_slippage($slippage);
            } elsif ($move > $allowed_move) {
                $self->execute_at_better_price(1);
                # We need to keep record of slippage even it is executed at better price
                $self->price_slippage($slippage);
                $final_value = $recomputed_amount;
            }
        }

        # adjust the value here
        if ($amount_type eq 'payout') {
            $self->price($final_value);
        } else {
            $self->payout($final_value);

            # They are all 'payout'-based when they hit the DB.
            my $new_contract = make_similar_contract(
                $contract,
                {
                    amount_type => 'payout',
                    amount      => $final_value,
                });
            $self->contract($new_contract);
        }
    }

    return;
}

sub _is_valid_to_buy {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_valid_to_buy) {
        return Error::Base->cuss(
            -type              => 'InvalidtoBuy',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }

    return;
}

sub _is_valid_to_sell {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_valid_to_sell) {
        return Error::Base->cuss(
            -type              => 'InvalidtoSell',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }

    return;
}

sub _validate_date_pricing {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_expired
        and abs(time - $contract->date_pricing->epoch) > 20)
    {
        return Error::Base->cuss(
            -type              => 'InvalidDatePricing',
            -mesg              => 'Bet was validated for a time [' . $contract->date_pricing->epoch . '] too far from now[' . time . ']',
            -message_to_client => BOM::Platform::Context::localize('This contract cannot be properly validated at this time.'));
    }
    return;
}

=head2 $self->_validate_iom_withdrawal_limit

Validate the withdrawal limit for IOM region

=cut

sub __validate_iom_withdrawal_limit {
    my $self   = shift;
    my $client = shift;

    return if $client->is_virtual;

    my $landing_company = LandingCompany::Registry::get_by_broker($client->broker_code);
    return if ($landing_company->country ne 'Isle of Man');

    my $landing_company_short = $landing_company->short;
    my $withdrawal_limits     = $payment_limits->{withdrawal_limits};
    my $numdays               = $withdrawal_limits->{$landing_company_short}->{for_days};
    my $numdayslimit          = $withdrawal_limits->{$landing_company_short}->{limit_for_days};
    my $lifetimelimit         = $withdrawal_limits->{$landing_company_short}->{lifetime_limit};

    if ($client->client_fully_authenticated) {
        $numdayslimit  = 99999999;
        $lifetimelimit = 99999999;
    }

    # withdrawal since $numdays
    my $payment_mapper = BOM::Database::DataMapper::Payment->new({client_loginid => $client->loginid});
    my $withdrawal_in_days = $payment_mapper->get_total_withdrawal({
        start_time => Date::Utility->new(Date::Utility->new->epoch - 86400 * $numdays),
        exclude    => ['currency_conversion_transfer'],
    });
    $withdrawal_in_days = roundnear(0.01, amount_from_to_currency($withdrawal_in_days, $client->currency, 'EUR'));

    # withdrawal since inception
    my $withdrawal_since_inception = $payment_mapper->get_total_withdrawal({exclude => ['currency_conversion_transfer']});
    $withdrawal_since_inception = roundnear(0.01, amount_from_to_currency($withdrawal_since_inception, $client->currency, 'EUR'));

    my $remaining_withdrawal_eur =
        roundnear(0.01, min(($numdayslimit - $withdrawal_in_days), ($lifetimelimit - $withdrawal_since_inception)));

    if ($remaining_withdrawal_eur <= 0) {
        return Error::Base->cuss(
            -type              => 'iomWithdrawalLimit',
            -mesg              => $client->loginid . ' caught in IOM withdrawal limit check',
            -message_to_client => BOM::Platform::Context::localize(
                "Due to regulatory requirements, you are required to authenticate your account in order to continue trading."),
        );
    }
    return;
}
BEGIN { _create_validator '_validate_iom_withdrawal_limit' }

# This validation should always come after _validate_trade_pricing_adjustment
# because we recompute the price and that's the price that we going to transact with!
sub ___validate_stake_limit {
    my $self   = shift;
    my $client = shift;

    my $contract        = $self->contract;
    my $landing_company = $client->landing_company;
    my $currency        = $contract->currency;

    my $stake_limit =
        $landing_company->short eq 'maltainvest'
        ? BOM::System::Config::quants->{bet_limits}->{min_stake}->{maltainvest}->{$currency}
        : $contract->staking_limits->{min};    # minimum is always a stake check

    if ($contract->ask_price < $stake_limit) {
        return Error::Base->cuss(
            -type => 'StakeTooLow',
            -mesg => $client->loginid . ' stake [' . $contract->ask_price . '] is lower than minimum allowable stake [' . $stake_limit . ']',
            -message_to_client => BOM::Platform::Context::localize(
                "This contract's price is [_1][_2]. Contracts purchased from [_3] must have a purchase price above [_1][_4]. Please accordingly increase the contract amount to meet this minimum stake.",
                $currency,
                to_monetary_number_format($contract->ask_price),
                $landing_company->name,
                to_monetary_number_format($stake_limit)
            ),
        );
    }
    return;
}
BEGIN { _create_validator '__validate_stake_limit' }

sub _validate_stake_limit {
    my $self = shift;

    # spread stake validation is within its module.
    # spread bet won't be offered to maltainvest.
    return if $self->contract->is_spread;
    return $self->__validate_stake_limit;
}

=head2 $self->_validate_payout_limit

Validate if payout is not over the client limits

=cut

sub __validate_payout_limit {
    my $self   = shift;
    my $client = shift;

    my $contract = $self->contract;

    return if $contract->is_spread;

    my $rp    = $self->contract->risk_profile;
    my @cl_rp = $rp->get_client_profiles($client);

    # setups client specific payout and turnover limits, if any.
    if (@cl_rp) {
        my $custom_profile = $rp->get_risk_profile(\@cl_rp);
        if ($custom_profile eq 'no_business') {
            return Error::Base->cuss(
                -type              => 'NoBusiness',
                -mesg              => $client->loginid . ' manually disabled by quants',
                -message_to_client => BOM::Platform::Context::localize('This contract is unavailable on this account.'),
            );
        }

        my $custom_limit = BOM::System::Config::quants->{risk_profile}{$custom_profile}{payout}{$contract->currency};
        if (defined $custom_limit and (my $payout = $self->payout) > $custom_limit) {
            return Error::Base->cuss(
                -type              => 'PayoutLimitExceeded',
                -mesg              => $client->loginid . ' payout [' . $payout . '] over custom limit[' . $custom_limit . ']',
                -message_to_client => ($custom_limit == 0)
                ? BOM::Platform::Context::localize('This contract is unavailable on this account.')
                : BOM::Platform::Context::localize(
                    'This contract is limited to ' . to_monetary_number_format($custom_limit) . ' payout on this account.'
                ),
            );
        }
    }

    return;
}
BEGIN { _create_validator '_validate_payout_limit' }

=head2 $self->_validate_jurisdictional_restrictions

Validates whether the client has provided his residence country

=cut

sub __validate_jurisdictional_restrictions {
    my $self   = shift;
    my $client = shift;

    my $contract    = $self->contract;
    my $residence   = $client->residence;
    my $loginid     = $client->loginid;
    my $market_name = $contract->market->name;

    if (!$residence && $loginid !~ /^VRT/) {
        return Error::Base->cuss(
            -type              => 'NoResidenceCountry',
            -mesg              => 'Client cannot place contract as we do not know their residence.',
            -message_to_client => BOM::Platform::Context::localize(
                'In order for you to place contracts, we need to know your Residence (Country). Please update your settings.'),
        );
    }

    my $lc = LandingCompany::Registry::get_by_broker($loginid);

    my %legal_allowed_ct = map { $_ => 1 } @{$lc->legal_allowed_contract_types};
    if (not $legal_allowed_ct{$contract->code}) {
        return Error::Base->cuss(
            -type              => 'NotLegalContractCategory',
            -mesg              => 'Clients are not allowed to trade on this contract category as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this contract.'),
        );
    }

    if (not grep { $market_name eq $_ } @{$lc->legal_allowed_markets}) {
        return Error::Base->cuss(
            -type              => 'NotLegalMarket',
            -mesg              => 'Clients are not allowed to trade on this markets as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this market.'),
        );
    }

    if ($residence && $market_name eq 'volidx' && LandingCompany::Countries->instance->volidx_restricted_country($residence)) {
        return Error::Base->cuss(
            -type => 'RandomRestrictedCountry',
            -mesg => 'Clients are not allowed to place Volatility Index contracts as their country is restricted.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, contracts on Volatility Indices are not available in your country of residence'),
        );
    }

    # For certain countries such as Belgium, we are not allow to sell financial product to them.
    if ($residence && $market_name ne 'volidx' && LandingCompany::Countries->instance->financial_binaries_restricted_country($residence)) {
        return Error::Base->cuss(
            -type => 'FinancialBinariesRestrictedCountry',
            -mesg => 'Clients are not allowed to place financial products contracts as their country is restricted.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, contracts on Financial Products are not available in your country of residence'),
        );
    }

    my %legal_allowed_underlyings = map { $_ => 1 } @{$lc->legal_allowed_underlyings};
    if (not $legal_allowed_underlyings{all} and not $legal_allowed_underlyings{$contract->underlying->symbol}) {
        return Error::Base->cuss(
            -type              => 'NotLegalUnderlying',
            -mesg              => 'Clients are not allowed to trade on this underlying as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this underlying.'),
        );
    }

    return;
}
BEGIN { _create_validator '_validate_jurisdictional_restrictions' }

=head2 $self->_validate_client_status

Validates to make sure that the client with unwelcome status
is not able to purchase contract

=cut

sub __validate_client_status {
    my $self   = shift;
    my $client = shift;

    if ($client->get_status('unwelcome') or $client->get_status('disabled')) {
        return Error::Base->cuss(
            -type              => 'ClientUnwelcome',
            -mesg              => 'your account is not authorised for any further contract purchases.',
            -message_to_client => BOM::Platform::Context::localize('Sorry, your account is not authorised for any further contract purchases.'),
        );
    }

    return;
}
BEGIN { _create_validator '_validate_client_status' }

=head2 $self->_validate_client_self_exclusion

Validates to make sure that the client with self exclusion
is not able to purchase contract

=cut

sub __validate_client_self_exclusion {
    my $self   = shift;
    my $client = shift;

    if (my $limit_excludeuntil = $client->get_self_exclusion_until_dt) {
        return Error::Base->cuss(
            -type => 'ClientSelfExcluded',
            -mesg => 'your account is not authorised for any further contract purchases.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, you have excluded yourself from the website until [_1].', $limit_excludeuntil),
        );
    }

    return;
}
BEGIN { _create_validator '_validate_client_self_exclusion' }

=head2 sell_expired_contracts

Static function: Sells expired contracts.
For contracts with missing market data, settle them manually for real money accounts, but sell with purchase price for virtual account

Returns: HashRef, with:
'total_credited', total amount credited to Client
'skip_contract', count for expired contracts that failed to be sold
'failures', the failure information

=cut

my %source_to_sell_type = (
    2 => 'expiryd',    # app id for `Binary.com expiryd.pl` in auth db => oauth.apps table
);

sub sell_expired_contracts {
    my $args         = shift;
    my $client       = $args->{client};
    my $source       = $args->{source};
    my $contract_ids = $args->{contract_ids};

    my $time_start = Time::HiRes::time;

    my $currency = $client->currency;
    my $loginid  = $client->loginid;

    my $result = {
        skip_contract => $contract_ids ? (scalar @$contract_ids) : 0,
        total_credited      => 0,
        number_of_sold_bets => 0,
        failures            => [],
    };

    my $mapper = BOM::Database::DataMapper::FinancialMarketBet->new({
        client_loginid => $loginid,
        currency_code  => $currency,
        broker_code    => $client->broker_code,
        operation      => 'replica',
    });

    my $clientdb = BOM::Database::ClientDB->new({
        broker_code => $client->broker_code,
        operation   => 'replica',
    });

    my $bets =
          (defined $contract_ids)
        ? [map { $_->financial_market_bet_record } @{$mapper->get_fmb_by_id($contract_ids)}]
        : $clientdb->getall_arrayref('select * from bet.get_open_bets_of_account(?,?,?)',
        [$client->loginid, $client->currency, ($args->{only_expired} ? 'true' : 'false')]);

    return $result unless $bets and @$bets;

    my $now = Date::Utility->new;
    my @bets_to_sell;
    my @quants_bet_variables;
    my @transdata;
    my %stats_attempt;
    my %stats_failure;
    for my $bet (@$bets) {
        my $contract;
        my $error;
        my $failure = {fmb_id => $bet->{id}};
        try { $contract = produce_contract($bet->{short_code}, $currency); } catch { $error = 1; };
        if ($error) {
            $failure->{reason} = 'Could not instantiate contract object';
            push @{$result->{failures}}, $failure;
            next;
        }

        my $logging_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
        $stats_attempt{$logging_class}++;
        if (not $contract->is_settleable) {
            $stats_failure{$logging_class}{'NotExpired'}++;
            $failure->{reason} = 'not expired';
            push @{$result->{failures}}, $failure;
            next;
        } elsif ($contract->category_code eq 'legacy') {
            $stats_failure{$logging_class}{Legacy}++;
            $failure->{reason} = 'legacy';
            push @{$result->{failures}}, $failure;
            next;
        }

        try {
            if ($contract->is_valid_to_sell) {
                @{$bet}{qw/sell_price sell_time/} = ($contract->bid_price, $contract->date_pricing->db_timestamp);
                $bet->{absolute_barrier} = $contract->barrier->as_absolute
                    if $contract->category_code eq 'asian' and $contract->is_after_settlement;
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };

                # price_slippage will not happen to expired contract, hence not needed.
                my $comment_hash = _build_pricing_comment({
                        contract => $contract,
                        action   => 'autosell_expired_contract',
                    })->[1];
                my $quants_bet_variables;
                if ($comment_hash) {
                    $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                        data_object_params => $comment_hash,
                    });
                }
                push @quants_bet_variables, $quants_bet_variables;

            } elsif ($client->is_virtual and $now->epoch >= $contract->date_settlement->epoch + 3600) {
                # for virtual, if can't settle bet due to missing market data, sell contract with buy price
                @{$bet}{qw/sell_price sell_time/} = ($bet->{buy_price}, $now->db_timestamp);
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };
                #empty list for virtual
                my $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                    data_object_params => {},
                });

                push @quants_bet_variables, $quants_bet_variables;
            } else {
                $stats_failure{$logging_class}{_normalize_error($contract->primary_validation_error)}++;
                $failure->{reason} = $contract->primary_validation_error->message;
                push @{$result->{failures}}, $failure;
            }
        }
        catch {
            warn 'SellExpiredContract Exception: ' . __PACKAGE__ . ':(' . __LINE__ . '): ' . $_;    # log it
        };
    }

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::System::Config::env;
    my $sell_type = (defined $source and exists $source_to_sell_type{$source}) ? $source_to_sell_type{$source} : 'expired';
    my @tags      = ("broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "sell_type:$sell_type");

    for my $class (keys %stats_attempt) {
        stats_count("transaction.sell.attempt", $stats_attempt{$class}, {tags => [@tags, "contract_class:$class"]});
    }
    for my $class (keys %stats_failure) {
        for my $reason (keys %{$stats_failure{$class}}) {
            stats_count(
                "transaction.sell.failure",
                $stats_failure{$class}{$reason},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error($reason)]});
        }
    }

    return $result unless @bets_to_sell;    # nothing to do

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        transaction_data => \@transdata,
        bet_data         => \@bets_to_sell,
        account_data     => {
            client_loginid => $loginid,
            currency_code  => $currency
        },
        db                   => BOM::Database::ClientDB->new({broker_code => $client->broker_code})->db,
        quants_bet_variables => \@quants_bet_variables,
    );

    my $sold = try {
        $fmb_helper->batch_sell_bet;
    }
    catch {
        warn(ref eq 'ARRAY' ? "@$_" : "$_");
        return 0;
    };

    if (not $sold or @bets_to_sell > @$sold) {
        # We missed some, let's figure out which ones they are.
        my %sold_fmbs = map { $_->{fmb}->{id} => 1 } @{$sold // []};
        my %missed;
        foreach my $bet (@bets_to_sell) {
            next if $sold_fmbs{$bet->{id}};    # Was not missed.
            $missed{$bet->{bet_class}}++;
            push @{$result->{failures}},
                {
                fmb_id => $bet->{id},
                reason => _normalize_error("TransactionFailure")};
        }
        foreach my $class (keys %missed) {
            stats_count("transaction.sell.failure", $missed{$class},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error("TransactionFailure")]});

        }
    }

    return $result unless $sold and @$sold;    # nothing has been sold

    my $skip_contract  = @$bets - @$sold;
    my $total_credited = 0;
    my %stats_success;
    for my $t (@$sold) {
        $total_credited += $t->{txn}->{amount};
        $stats_success{$t->{fmb}->{bet_class}}->[0]++;
        $stats_success{$t->{fmb}->{bet_class}}->[1] += $t->{txn}->{amount};
    }
    for my $class (keys %stats_success) {
        stats_count("transaction.sell.success", $stats_success{$class}->[0], {tags => [@tags, "contract_class:$class"]});
        if ($rmgenv eq 'production' and $virtual eq 'no') {
            my $usd_amount = int(in_USD($stats_success{$class}->[1], $currency) * 100);
            stats_count('business.buy_minus_sell_usd', -$usd_amount, {tags => [@tags, "contract_class:$class"]});
        }
    }

    $result->{skip_contract}       = $skip_contract;
    $result->{total_credited}      = $total_credited;
    $result->{number_of_sold_bets} = 0 + @$sold;
    return $result;
}

sub report {
    my $self = shift;
    return
          "Transaction Report:\n"
        . sprintf("%30s: %s\n", 'Client',                 $self->client)
        . sprintf("%30s: %s\n", 'Contract',               $self->contract->code)
        . sprintf("%30s: %s\n", 'Price',                  $self->price)
        . sprintf("%30s: %s\n", 'Payout',                 $self->payout)
        . sprintf("%30s: %s\n", 'Amount Type',            $self->amount_type)
        . sprintf("%30s: %s\n", 'Comment',                $self->comment->[0] || '')
        . sprintf("%30s: %s\n", 'Staff',                  $self->staff)
        . sprintf("%30s: %s",   'Transaction Parameters', Dumper($self->transaction_parameters))
        . sprintf("%30s: %s\n", 'Transaction ID',         $self->transaction_id || -1)
        . sprintf("%30s: %s\n", 'Purchase Date',          $self->purchase_date->datetime_yyyymmdd_hhmmss);
}

no Moose;

__PACKAGE__->meta->make_immutable;

1;
