package BOM::Product::Transaction;

use Moose;
use Data::Dumper;
use Error::Base;
use Path::Tiny;
use Scalar::Util qw(blessed);
use Time::HiRes qw(tv_interval gettimeofday time);
use List::Util qw(min max first);
use JSON qw( from_json );
use Date::Utility;
use ExpiryQueue qw( enqueue_new_transaction );
use Format::Util::Numbers qw(roundnear to_monetary_number_format);
use RateLimitations qw(within_rate_limits);
use Try::Tiny;

use BOM::Platform::Context qw(request localize);
use BOM::Platform::Runtime;
use BOM::Platform::Client;
use BOM::System::Config;
use BOM::Product::ContractFactory qw( produce_contract make_similar_contract );
use BOM::Utility::CurrencyConverter qw(in_USD amount_from_to_currency);
use BOM::Utility::ErrorStrings qw( normalize_error_string );
use BOM::Database::DataMapper::Payment;
use BOM::Database::DataMapper::Transaction;
use BOM::Database::DataMapper::Account;
use BOM::Database::DataMapper::FinancialMarketBet;
use DataDog::DogStatsd::Helper qw(stats_inc stats_timing stats_count);
use BOM::Database::ClientDB;
use BOM::Database::Model::Account;
use BOM::Database::Model::DataCollection::QuantsBetVariables;
use BOM::Database::Model::Constants;
use BOM::Product::CustomClientLimits;
use BOM::Database::Helper::FinancialMarketBet;
use BOM::Utility::Log4perl qw/get_logger/;
use BOM::Product::Offerings qw/get_offerings_with_filter/;
use BOM::Platform::Static::Config;

extends 'BOM::Platform::Transaction';

has client => (
    is  => 'ro',
    isa => 'BOM::Platform::Client',
);

has contract => (
    is => 'rw',
);

has price => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has transaction_record => (
    is         => 'ro',
    isa        => 'BOM::Database::AutoGenerated::Rose::Transaction',
    lazy_build => 1,
);

sub _build_transaction_record {
    my $self = shift;
    my $id = $self->transaction_id || die 'transaction not written yet';
    return $self->client->default_account->find_transaction({id => $id})->[0];
}

has balance_after => (
    is  => 'rw',
    isa => 'Maybe[Num]',
);

has limits => (
    is      => 'rw',
    isa     => 'HashRef',
    default => sub { +{} },
);

has payout => (
    is         => 'rw',
    isa        => 'Num',
    lazy_build => 1,
);

sub _build_payout {
    my $self = shift;
    return $self->contract->payout;
}

has amount_type => (
    is      => 'rw',
    isa     => 'Str',
    default => 'payout',
);

has comment => (
    is  => 'rw',
    isa => 'Str'
);

has staff => (
    is         => 'rw',
    isa        => 'Str',
    lazy_build => 1,
);

sub _build_staff {
    my $self = shift;
    return $self->client->loginid;
}

has transaction_id => (
    is  => 'rw',
    isa => 'Int',
);

has contract_id => (
    is  => 'rw',
    isa => 'Int',
);

has execute_at_better_price => (
    is      => 'rw',
    isa     => 'Bool',
    default => 0,
);

# calling server should capture time of request
has purchase_date => (
    is         => 'rw',
    isa        => 'bom_date_object',
    coerce     => 1,
    lazy_build => 1,
);

has contract_class => (
    is  => 'rw',
    isa => 'Str',
);

has source => (
    is  => 'ro',
    isa => 'Int',
);

has transaction_parameters => (
    is      => 'ro',
    isa     => 'HashRef',
    default => sub { {}; },
);

sub BUILDARGS {
    my ($class, $args) = @_;

    if (exists $args->{price}) {
        $args->{transaction_parameters}->{price} = $args->{price};
    }
    if (exists $args->{payout}) {
        $args->{transaction_parameters}->{payout} = $args->{payout};
    }
    return $args;
}

sub sell_expired_contracts;    # forward declaration

sub _build_purchase_date {

# Purchase is considered to have happened at time of request; if no such info available, then now.
# Classic case: REQUEST_STARTTIME is present (epoch-style) in the binary.com cgi context.
    return $ENV{REQUEST_STARTTIME} // time;
}

sub stats_start {
    my $self = shift;
    my $what = shift;

    my $client   = $self->client;
    my $contract = $self->contract;

    my $loginid   = lc($client->loginid);
    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::System::Config::env;
    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    my $tags      = {tags => ["broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "contract_class:$bet_class",]};

    if ($what eq 'buy') {
        if ($self->contract->is_spread) {
            push @{$tags->{tags}}, "stop_type:" . lc($contract->stop_type);
        } else {
            push @{$tags->{tags}}, "amount_type:" . lc($self->amount_type), "expiry_type:" . ($contract->fixed_expiry ? 'fixed' : 'duration');
        }
    } elsif ($what eq 'sell') {
        push @{$tags->{tags}}, "sell_type:manual";
    }
    stats_inc("transaction.$what.attempt", $tags);

    return +{
        start   => [gettimeofday],
        tags    => $tags,
        virtual => $virtual,
        rmgenv  => $rmgenv,
        what    => $what,
    };
}

sub stats_validation_done {
    my $self = shift;
    my $data = shift;

    $data->{validation_done} = [gettimeofday];

    return;
}

# Given a generic error, try to turn it into a tag-friendly string which
# might be the same across multiple failures.
sub _normalize_error {
    my $error = shift;

    if (my $whatsit = blessed $error) {
        if ($whatsit eq 'Error::Base') {
            my $type = $error->get_type;    # These are nice short camelCase descriptions
            $error = (
                       $type eq 'InvalidtoBuy'
                    or $type eq 'InvalidtoSell'
            ) ? $error->get_mesg : $type;    # In these special cases, we'd like to get the underlying contract message, instead.
        } elsif ($whatsit eq 'MooseX::Role::Validatable::Error') {
            $error = $error->message;        # These should be sentence-like.
        } else {
            $error = "$error";               # Assume it's stringifiable.
        }
    }

    return normalize_error_string($error);
}

sub stats_stop {
    my ($self, $data, $error) = @_;

    my $what = $data->{what};
    my $tags = $data->{tags};

    if ($error) {
        stats_inc("transaction.$what.failure", {tags => [@{$tags->{tags}}, 'reason:' . _normalize_error($error),]});
    } else {
        my $now = [gettimeofday];
        stats_timing("transaction.$what.elapsed_time", 1000 * tv_interval($data->{start},           $now), $tags);
        stats_timing("transaction.$what.db_time",      1000 * tv_interval($data->{validation_done}, $now), $tags);
        stats_inc("transaction.$what.success", $tags);

        if ($data->{rmgenv} eq 'production' and $data->{virtual} eq 'no') {
            my $usd_amount = int(in_USD($self->price, $self->contract->currency) * 100);
            if ($what eq 'buy') {
                stats_count('business.turnover_usd',       $usd_amount, $tags);
                stats_count('business.buy_minus_sell_usd', $usd_amount, $tags);
            } elsif ($what eq 'sell') {
                stats_count('business.buy_minus_sell_usd', -$usd_amount, $tags);
            }
        }
    }

    return $error;
}

sub calculate_limits {
    my $self = shift;

    my $app_config    = BOM::Platform::Runtime->instance->app_config->quants->client_limits;
    my $static_config = BOM::Platform::Static::Config::quants->{client_limits};

    my $contract = $self->contract;
    my $currency = $contract->currency;
    my $client   = $self->client;

    $self->limits->{max_balance} = $client->get_limit_for_account_balance;

    if (not $contract->tick_expiry) {
        $self->limits->{max_open_bets}                      = $client->get_limit_for_open_positions;
        $self->limits->{max_payout_open_bets}               = $client->get_limit_for_payout;
        $self->limits->{max_payout_per_symbol_and_bet_type} = $static_config->{payout_per_symbol_and_bet_type_limit}->{$currency};
    }

    $self->limits->{max_turnover} = $client->get_limit_for_daily_turnover;

    my $lim;
    defined($lim = $client->get_limit_for_daily_losses)
        and $self->limits->{max_losses} = $lim;
    defined($lim = $client->get_limit_for_7day_turnover)
        and $self->limits->{max_7day_turnover} = $lim;
    defined($lim = $client->get_limit_for_7day_losses)
        and $self->limits->{max_7day_losses} = $lim;
    defined($lim = $client->get_limit_for_30day_turnover)
        and $self->limits->{max_30day_turnover} = $lim;
    defined($lim = $client->get_limit_for_30day_losses)
        and $self->limits->{max_30day_losses} = $lim;

    if ($client->loginid !~ /^VRT/ and $contract->market->name eq 'forex' and $contract->is_intraday and not $contract->is_atm_bet) {
        $lim = $self->limits->{intraday_forex_iv_action} = {
            turnover         => $app_config->intraday_forex_iv_turnover->$currency,
            realized_profit  => $app_config->intraday_forex_iv_realized_profit->$currency,
            potential_profit => $app_config->intraday_forex_iv_potential_profit->$currency,
        };
        for (keys %$lim) {
            delete $lim->{$_} if $lim->{$_} == 0;
        }
    }

    if ($contract->is_spread) {
        $self->limits->{spread_bet_profit_limit} = $app_config->spreads_daily_profit->$currency;
    }

    if ($contract->pricing_engine_name eq 'Pricing::Engine::TickExpiry') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            bet_type => [map { {n => $_} } 'CALL', 'PUT'],
            name     => 'tick_expiry_engine_turnover_limit',
            limit    => $app_config->tick_expiry_engine_daily_turnover->$currency,
            symbols  => [
                map { {n => $_} } get_offerings_with_filter(
                    'underlying_symbol',
                    {
                        market      => 'forex',
                        expiry_type => 'tick'
                    })
            ],
            };
    }

    if ($contract->pricing_engine_name eq 'BOM::Product::Pricing::Engine::Intraday::Index') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            bet_type => [map { {n => $_} } 'CALL', 'PUT'],
            name     => 'intraday_spot_index_turnover_limit',
            limit    => $static_config->{intraday_spot_index_turnover_limit}->{$currency},
            symbols => [map { {n => $_} } get_offerings_with_filter('underlying_symbol', {market => 'indices'})],
            };
    }

    if ($contract->underlying->submarket->name eq 'smart_fx') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            name    => 'smartfx_turnover_limit',
            limit   => $static_config->{smartfx_turnover_limit}->{$currency},
            symbols => [map { {n => $_} } get_offerings_with_filter('underlying_symbol', {submarket => 'smart_fx'})],
            };
    }

    if ($contract->market->name eq 'stocks') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            name    => 'stocks_turnover_limit',
            limit   => $static_config->{stocks_turnover_limit}->{$currency},
            symbols => [map { {n => $_} } get_offerings_with_filter('underlying_symbol', {market => 'stocks'})],
            };
    }

    if ($contract->category_code eq 'asian') {
        push @{$self->limits->{specific_turnover_limits}},
            +{
            bet_type    => [map { {n => $_} } 'ASIANU', 'ASIAND'],
            name        => 'asian_turnover_limit',
            limit       => $app_config->asian_daily_turnover->$currency,
            tick_expiry => 1,
            };
    }

    return;
}

sub prepare_bet_data_for_buy {
    my $self = shift;

    my $client   = $self->client;
    my $contract = $self->contract;
    my $loginid  = $client->loginid;
    my $currency = $contract->currency;

    if ($self->purchase_date->is_after($contract->date_start)) {
        my $d1 = $self->purchase_date->datetime_yyyymmdd_hhmmss;
        my $d2 = $contract->date_start->datetime_yyyymmdd_hhmmss;
        return Error::Base->cuss(
            -type              => 'ContractAlreadyStarted',
            -mesg              => "buy at $d1 too late for $d2 contract",
            -message_to_client => BOM::Platform::Context::localize("Start time is in the past"));
    }

    my $comment = $self->comment // '';

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        loginid           => $loginid,
        currency          => $currency,
        quantity          => 1,
        short_code        => scalar $contract->shortcode,
        buy_price         => $self->price,
        remark            => $comment,
        underlying_symbol => scalar $contract->underlying->symbol,
        bet_type          => scalar $contract->code,
        bet_class         => $bet_class,
        purchase_time     => scalar $self->purchase_date->db_timestamp,
        start_time        => scalar $contract->date_start->db_timestamp,
        expiry_time       => scalar $contract->date_expiry->db_timestamp,
        settlement_time   => scalar $contract->date_settlement->db_timestamp,
        payout_price      => scalar $self->payout,
    };

    $bet_params->{expiry_daily} = 1 if $contract->expiry_daily;
    $bet_params->{fixed_expiry} = 1 if $contract->fixed_expiry;
    if ($contract->tick_expiry) {
        $bet_params->{tick_expiry} = 1;
        $bet_params->{tick_count}  = scalar $contract->tick_count;
    }

    if ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_SPREAD_BET) {
        $bet_params->{$_} = $contract->$_ for qw(amount_per_point spread stop_type spread_divisor);
        $bet_params->{stop_loss}   = $contract->supplied_stop_loss;
        $bet_params->{stop_profit} = $contract->supplied_stop_profit;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_HIGHER_LOWER_BET) {
        # only store barrier in the database if it is defined.
        # asian contracts have barriers at/after expiry.
        if ($contract->barrier) {
            $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
        }
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_DIGIT_BET) {
        $bet_params->{prediction} = $contract->sentiment;
        $bet_params->{last_digit} = $contract->barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_RANGE_BET) {
        $bet_params->{$contract->high_barrier->barrier_type . '_higher_barrier'} = $contract->high_barrier->supplied_barrier;
        $bet_params->{$contract->low_barrier->barrier_type . '_lower_barrier'}   = $contract->low_barrier->supplied_barrier;
    } elsif ($bet_params->{bet_class} eq $BOM::Database::Model::Constants::BET_CLASS_TOUCH_BET) {
        $bet_params->{$contract->barrier->barrier_type . '_barrier'} = $contract->barrier->supplied_barrier;
    } else {
        return Error::Base->cuss(
            -type              => 'UnsupportedBetClass',
            -mesg              => "Unsupported bet class $bet_params->{bet_class}",
            -message_to_client => BOM::Platform::Context::localize("Unsupported bet class $bet_params->{bet_class}"),
        );
    }

    my $quants_bet_variables;
    my $quants_bet_params = BOM::Database::Model::DataCollection::QuantsBetVariables->extract_parameters_from_line({line => "COMMENT:$comment"});
    if ($quants_bet_params) {
        $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
            data_object_params => $quants_bet_params,
        });
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
            },
            bet_data     => $bet_params,
            account_data => {
                client_loginid => $loginid,
                currency_code  => $currency
            },
            quants_bet_variables => $quants_bet_variables,
            limits               => $self->limits,
        });
}

sub buy {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my %options = @_;

    my $error_status;

    my $stats_data = $self->stats_start('buy');

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        #
        # Keep the transaction rate test first to limit the impact of abusive buyers
        $error_status = $self->$_ and return $self->stats_stop($stats_data, $error_status)
            for (
            qw/
            _validate_buy_transaction_rate
            _validate_iom_withdrawal_limit
            _validate_payout_limit
            _is_valid_to_buy
            _validate_date_pricing
            _validate_trade_pricing_adjustment
            _validate_stake_limit
            _validate_jurisdictional_restrictions
            _validate_client_status
            _validate_client_self_exclusion
            _validate_currency/
            );

        $self->calculate_limits;

        $self->comment($self->_build_pricing_comment) unless defined $self->comment;
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_buy;
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $try   = 0;
    my $error = 1;
    my ($fmb, $txn);
    TRY: {
        try {
            ($fmb, $txn) = $fmb_helper->buy_bet;
            $error = 0;
        }
        catch {
            # $error_status==undef means repeat operation
            # if $error_status is defined, return it
            # otherwise the function re-throws the exception (unrecoverable).
            $error_status = $self->_recover($_, $try);
        };
        return $self->stats_stop($stats_data, $error_status) if $error_status;
        redo TRY if $error and $try++ < 3;
    }

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});
    $self->contract_id($fmb->{id});

    enqueue_new_transaction($self);    # For soft realtime expiration notification.

    return;
}

sub prepare_bet_data_for_sell {
    my $self = shift;
    my $contract = shift || $self->contract;

    my $client   = $self->client;
    my $loginid  = $client->loginid;
    my $currency = $contract->currency;

    my $bet_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
    $self->contract_class($bet_class);

    $self->price(Format::Util::Numbers::roundnear(0.01, $self->price));

    my $bet_params = {
        id         => scalar $self->contract_id,
        sell_price => scalar $self->price,
        sell_time  => scalar $contract->date_pricing->db_timestamp,
        $contract->category_code eq 'asian' && $contract->is_after_expiry
        ? (absolute_barrier => scalar $contract->barrier->as_absolute)
        : (),
    };

    my $quants_bet_variables;
    if (my $comment = $self->comment) {
        my $quants_bet_params = BOM::Database::Model::DataCollection::QuantsBetVariables->extract_parameters_from_line({line => "COMMENT:$comment"});
        if ($quants_bet_params) {
            $quants_bet_variables = BOM::Database::Model::DataCollection::QuantsBetVariables->new({
                data_object_params => $quants_bet_params,
            });
        }
    }

    return (
        undef,
        {
            transaction_data => {
                staff_loginid => $self->staff,
                source        => $self->source,
            },
            bet_data     => $bet_params,
            account_data => {
                client_loginid => $loginid,
                currency_code  => $currency
            },
            quants_bet_variables => $quants_bet_variables,
        });
}

sub sell {    ## no critic (RequireArgUnpacking)
    my $self    = shift;
    my %options = @_;

    my $error_status;

    my $stats_data = $self->stats_start('sell');

    unless ($options{skip_validation}) {
        # all these validations MUST NOT use the database
        # database related validations MUST be implemented in the database
        # ask your friendly DBA team if in doubt
        $error_status = $self->$_ and return $self->stats_stop($stats_data, $error_status)
            for (
            qw/
            _validate_sell_transaction_rate
            _validate_iom_withdrawal_limit
            _validate_payout_limit
            _is_valid_to_sell
            _validate_currency
            _validate_sell_pricing_adjustment
            _validate_date_pricing/
            );

        $self->comment($self->_build_pricing_comment) unless defined $self->comment;
    }

    ($error_status, my $bet_data) = $self->prepare_bet_data_for_sell;
    return $self->stats_stop($stats_data, $error_status) if $error_status;

    $self->stats_validation_done($stats_data);

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        %$bet_data,
        db => BOM::Database::ClientDB->new({broker_code => $self->client->broker_code})->db,
    );

    my $try   = 0;
    my $error = 1;
    my ($fmb, $txn);
    TRY: {
        try {
            ($fmb, $txn) = $fmb_helper->sell_bet;
            $error = 0;
        }
        catch {
            # $error_status==undef means repeat operation
            # if $error_status is defined, return it
            # otherwise the function re-throws the exception (unrecoverable).
            $error_status = $self->_recover($_, $try);
        };
        return $self->stats_stop($stats_data, $error_status) if $error_status;
        redo TRY if $error and $try++ < 3;
    }

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'GeneralError',
            -mesg              => 'Cannot perform database action',
            -message_to_client => BOM::Platform::Context::localize('A general error has occurred.'),
        )) if $error;

    return $self->stats_stop(
        $stats_data,
        Error::Base->cuss(
            -type              => 'NoOpenPosition',
            -mesg              => 'No such open contract.',
            -message_to_client => BOM::Platform::Context::localize('This contract was not found among your open positions.'),
        )) unless defined $txn->{id};

    $self->stats_stop($stats_data);

    $self->balance_after($txn->{balance_after});
    $self->transaction_id($txn->{id});

    return;
}

=head2 C<< $self->_recover($error, $retry) >>

This function tries to recover from an unsuccessful buy/sell.
It may decide to retry the operation. And it may decide to
sell expired bets before doing so.

=head4 Parameters

=over 4

=item * C<< $error >>

the error exception thrown by BOM::Platform::Data::Persistence::DB::_handle_errors

=item * C<< $retry >>

an optional count of how many times the operation has been tried before.
Default is 0.

=back

=head3 Return Value

=over 4

=item * the empty list

which means I<please retry the operation, and, in case of an error, get
back with a C<$retry> count incremented by 1>.

=item * an L<Error::Base> object

which means an unrecoverable but expected condition has been found.
Typically that means a precondition, like sufficient balance, was
not met.

The caller should not retry the operation or try to amend the
situation. Instead it should pass on the error to the client.
However, make sure to C<unfreeze_client> before.

=back

Be aware that the function may throw an exception.

=head3 Exceptions

In case of an unexpected error, the exception is re-thrown unmodified.

=cut

my %known_errors = (
    BI001 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit    = to_monetary_number_format($client->get_limit_for_daily_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your daily turnover limit of [_1][_2].',
            $currency, $limit);
        if (not $client->client_fully_authenticated) {
            $error_message .= ' ' . BOM::Platform::Context::localize('If you wish to raise these limits, please authenticate your account.');
        }

        return Error::Base->cuss(
            -type              => 'DailyTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a daily turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI002 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $limit = $self->client->get_limit_for_open_positions;
        return Error::Base->cuss(
            -type              => 'OpenPositionLimit',
            -mesg              => "Client has reached the limit of $limit open positions.",
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, you cannot hold more than [_1] contracts at a given time. Please visit the statement page to automatically sell your expired contracts.',
                $limit
            ),
        );
    },
    BI003 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $currency = $self->contract->currency;
        my $account  = BOM::Database::DataMapper::Account->new({
            client_loginid => $self->client->loginid,
            currency_code  => $currency,
        });
        my $balance = $account->get_balance();
        my $price   = $self->price;

        return Error::Base->cuss(
            -type              => 'InsufficientBalance',
            -message           => 'Client\'s account balance was insufficient to buy bet.',
            -message_to_client => BOM::Platform::Context::localize(
                'Your account balance ([_1][_2]) is insufficient to buy this contract ([_1][_3]).', $currency,
                to_monetary_number_format($balance),                                                to_monetary_number_format($price)));
    },
    BI004 => Error::Base->cuss(
        -type              => 'IntradayLimitExceeded',
        -mesg              => 'Exceeds intraday limit on turnover',
        -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
    ),
    BI005 => Error::Base->cuss(
        -type              => 'IntradayLimitExceeded',
        -mesg              => 'Exceeds intraday limit on potential_profit',
        -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
    ),
    BI006 => Error::Base->cuss(
        -type              => 'IntradayLimitExceeded',
        -mesg              => 'Exceeds intraday limit on realized_profit',
        -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
    ),
    BI007 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        return Error::Base->cuss(
            -type              => 'PotentialPayoutLimitForSameContractExceeded',
            -mesg              => "Client has exceeded potential payout limit for open contracts with the same symbol and bet_type",
            -message_to_client => BOM::Platform::Context::localize(
                'Purchase of this contract would cause you to exceed our payout limit for open contracts of this type. To continue please consider to sell a few contracts at the market or trade in different contract types.'
            ),
        );
    },
    BI008 => sub {
        my $self  = shift;
        my $retry = shift;

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($self->client->get_limit_for_account_balance, 1);

        my $account = BOM::Database::DataMapper::Account->new({
            client_loginid => $self->client->loginid,
            currency_code  => $currency,
        });
        my $balance = $account->get_balance();

        return Error::Base->cuss(
            -type              => 'AccountBalanceExceedsLimit',
            -mesg              => 'Client balance is above the allowed limits',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, your account cash balance is too high ([_1]). Your maximum account balance is [_2].', "$currency$balance",
                "$currency$limit"
            ),
        );
    },
    BI009 => sub {
        my $self  = shift;
        my $retry = shift;

        unless ($retry) {
            my $res = sell_expired_contracts +{
                client       => $self->client,
                source       => $self->source,
                only_expired => 1
            };
            return if $res and $res->{number_of_sold_bets} > 0;    # retry
        }

        my $currency = $self->contract->currency;
        my $limit = to_monetary_number_format($self->client->get_limit_for_payout, 1);

        return Error::Base->cuss(
            -type              => 'OpenPositionPayoutLimit',
            -mesg              => 'Client has reached maximum net payout for open positions',
            -message_to_client => BOM::Platform::Context::localize(
                'Sorry, the aggregate payouts of contracts on your account cannot exceed [_1][_2].',
                $currency, $limit
            ),
        );
    },
    BI010 => Error::Base->cuss(
        -type              => 'PromoCodeLimitExceeded',
        -mesg              => 'Client won more than 25 times of the promo code amount',
        -message_to_client => BOM::Platform::Context::localize(
            'Your account has exceeded the trading limit with free promo code, please deposit if you wish to continue trading.'),
    ),
    BI011 => sub {
        my $self  = shift;
        my $retry = shift;
        my $msg   = shift;

        my $limit_name = 'Unknown';
        $msg =~ /^.+: ([^,]+)/ and $limit_name = $1;

        return Error::Base->cuss(
            -type              => $limit_name . 'Exceeded',
            -mesg              => 'Exceeds turnover limit on ' . $limit_name,
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI012 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit    = to_monetary_number_format($client->get_limit_for_daily_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your daily limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => 'DailyLossLimitExceeded',
            -mesg              => "Client has exceeded his daily loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI013 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit    = to_monetary_number_format($client->get_limit_for_7day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your 7-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 7-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI014 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit    = to_monetary_number_format($client->get_limit_for_7day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 7-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '7DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 7-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI015 => sub {
        my $self = shift;

        return Error::Base->cuss(
            -type              => 'SpreadDailyProfitLimitExceeded',
            -mesg              => 'Exceeds profit limit on spread',
            -message_to_client => BOM::Platform::Context::localize('You have exceeded the daily limit for contracts of this type.'),
        );
    },
    BI016 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit    = to_monetary_number_format($client->get_limit_for_30day_turnover, 1);

        my $error_message =
            BOM::Platform::Context::localize('Purchase of this contract would cause you to exceed your 30-day turnover limit of [_1][_2].',
            $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayTurnoverLimitExceeded',
            -mesg              => "Client has exceeded a 30-day turnover of $currency$limit",
            -message_to_client => $error_message,
        );
    },
    BI017 => sub {
        my $self = shift;

        my $client   = $self->client;
        my $currency = $self->contract->currency;
        my $limit    = to_monetary_number_format($client->get_limit_for_30day_losses, 1);

        my $error_message = BOM::Platform::Context::localize('You have exceeded your 30-day limit on losses of [_1][_2].', $currency, $limit);

        return Error::Base->cuss(
            -type              => '30DayLossLimitExceeded',
            -mesg              => "Client has exceeded his 30-day loss limit of $currency$limit",
            -message_to_client => $error_message,
        );
    },
);

sub _recover {
    my $self  = shift;
    my $err   = shift;
    my $retry = shift // 0;

    if (ref($err) eq 'ARRAY') {    # special BINARY code
        my $ref = $known_errors{$err->[0]};
        return ref $ref eq 'CODE' ? $ref->($self, $retry, $err->[1]) : $ref if $ref;
    } else {
        # TODO: recover from deadlocks & co.
    }
    die $err;
}

sub _validate_currency {
    my $self     = shift;
    my $broker   = $self->client->broker_code;
    my $currency = $self->contract->currency;

    if ($currency ne $self->client->currency) {
        return Error::Base->cuss(
            -type              => 'NotDefaultCurrency',
            -mesg              => "not default currency for client [$currency], client currency[" . $self->client->currency . "]",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is not the default currency", $currency),
        );
    }

    if (not grep { $currency eq $_ } @{request()->available_currencies}) {
        return Error::Base->cuss(
            -type              => 'InvalidCurrency',
            -mesg              => "Invalid $currency",
            -message_to_client => BOM::Platform::Context::localize("The provided currency [_1] is invalid.", $currency),
        );
    }

    if (not BOM::Platform::Runtime->instance->broker_codes->get($broker)->landing_company->is_currency_legal($currency)) {
        return Error::Base->cuss(
            -type              => 'IllegalCurrency',
            -mesg              => "Illegal $currency for $broker",
            -message_to_client => BOM::Platform::Context::localize("[_1] transactions may not be performed with this account.", $currency),
        );
    }
    return;
}

sub _build_pricing_comment {
    my $self     = shift;
    my $contract = $self->contract;

    my @comment_fields;
    if ($contract->is_spread) {
        @comment_fields = map { defined $_->[1] ? @$_ : () } (
            [amount_per_point => $contract->amount_per_point],
            [stop_profit      => $contract->stop_profit],
            [stop_loss        => $contract->stop_loss],
            [spread           => $contract->spread],
        );
    } else {
        # This way the order of the fields is well-defined.
        @comment_fields = map { defined $_->[1] ? @$_ : (); } (
            [theo    => $contract->theo_price],
            [trade   => $self->price],
            [iv      => $contract->pricing_vol],
            [win     => $contract->payout],
            [div     => $contract->q_rate],
            [int     => $contract->r_rate],
            [delta   => $contract->delta],
            [gamma   => $contract->gamma],
            [vega    => $contract->vega],
            [theta   => $contract->theta],
            [vanna   => $contract->vanna],
            [volga   => $contract->volga],
            [bs_prob => $contract->bs_probability->amount],
            [spot    => $contract->current_spot]);

        my $news_factor = $contract->ask_probability->peek('news_factor');
        if ($news_factor) {
            push @comment_fields, news_fct => $news_factor->amount;
            my $news_impact = $news_factor->peek('news_impact');
            push @comment_fields, news_impact => $news_impact->amount if $news_impact;
        }

        if (@{$contract->corporate_actions}) {
            push @comment_fields,
                corporate_action => 1,
                actions          => join '|',
                map { $_->{description} . ',' . $_->{modifier} . ',' . $_->{value} } @{$contract->corporate_actions};
        }
    }

    return sprintf join(' ', ('%s[%0.5f]') x (@comment_fields / 2)), @comment_fields;
}

sub _validate_sell_pricing_adjustment {
    my $self = shift;

    # always sell at recomputed bid price for spreads.
    if ($self->contract->is_spread or not defined $self->price) {
        $self->price($self->contract->bid_price);
        return;
    }

    my $contract = $self->contract;
    my $currency = $contract->currency;

    my $requested         = $self->price / $self->payout;
    my $recomputed        = $contract->bid_probability->amount;
    my $move              = $recomputed - $requested;
    my $commission_markup = 0;
    if (not $contract->is_expired) {
        if ($contract->new_interface_engine) {
            $commission_markup = $contract->pricing_engine->commission_markup;
        } else {
            $commission_markup = $contract->bid_probability->peek_amount('commission_markup') || 0;
        }
    }
    my $allowed_move = $commission_markup * 0.8;
    $allowed_move = 0 if $recomputed == 1;
    my ($amount, $recomputed_amount) = ($self->price, $contract->bid_price);

    if ($move != 0) {
        my $final_value;
        if ($contract->is_expired) {
            return Error::Base->cuss(
                -type              => 'BetExpired',
                -mesg              => 'Bet expired with a new price[' . $recomputed_amount . '] (old price[' . $amount . '])',
                -message_to_client => BOM::Platform::Context::localize('The contract has expired'),
            );
        } elsif ($allowed_move == 0) {
            $final_value = $recomputed_amount;
        } elsif ($move < -$allowed_move) {
            my $market_moved = BOM::Platform::Context::localize('The underlying market has moved too much since you priced the contract. ');
            $market_moved .= BOM::Platform::Context::localize(
                'The contract [_4] has changed from [_1][_2] to [_1][_3].',
                $currency,
                to_monetary_number_format($amount),
                to_monetary_number_format($recomputed_amount),
                'sell price'
            );

            return Error::Base->cuss(
                -type => 'PriceMoved',
                -mesg =>
                    "Difference between submitted and newly calculated bet price: currency $currency, amount: $amount, recomputed amount: $recomputed_amount",
                -message_to_client => $market_moved,
            );
        } else {
            if ($move <= $allowed_move and $move >= -$allowed_move) {
                $final_value = $amount;
            } elsif ($move > $allowed_move) {
                $self->execute_at_better_price(1);
                $final_value = $recomputed_amount;
            }
        }

        $self->price($final_value);
    }

    return;
}

sub _validate_trade_pricing_adjustment {
    my $self = shift;

    # always buy at recomputed ask price for spreads.
    if ($self->contract->is_spread) {
        $self->price($self->contract->ask_price);
        return;
    }

    my $amount_type = $self->amount_type;
    my $contract    = $self->contract;
    my $currency    = $contract->currency;

    my $requested         = $self->price / $self->payout;
    my $recomputed        = $contract->ask_probability->amount;
    my $move              = $requested - $recomputed;
    my $commission_markup = 0;
    if (not $contract->is_expired) {
        if ($contract->new_interface_engine) {
            $commission_markup = $contract->pricing_engine->commission_markup;
        } else {
            $commission_markup = $contract->ask_probability->peek_amount('commission_markup') || 0;
        }
    }
    my $allowed_move = ($self->contract->category->code eq 'digits') ? $commission_markup : ($commission_markup * 0.5);
    $allowed_move = 0 if $recomputed == 1;
    my ($amount, $recomputed_amount) = $amount_type eq 'payout' ? ($self->price, $contract->ask_price) : ($self->payout, $contract->payout);

    if ($move != 0) {
        my $final_value;
        if ($contract->is_expired) {
            return Error::Base->cuss(
                -type              => 'BetExpired',
                -mesg              => 'Bet expired with a new price[' . $recomputed_amount . '] (old price[' . $amount . '])',
                -message_to_client => BOM::Platform::Context::localize('The contract has expired'),
            );
        } elsif ($allowed_move == 0) {
            $final_value = $recomputed_amount;
        } elsif ($move < -$allowed_move) {
            my $what_changed = $amount_type eq 'payout' ? 'price' : 'payout';
            my $market_moved = BOM::Platform::Context::localize('The underlying market has moved too much since you priced the contract. ');
            $market_moved .= BOM::Platform::Context::localize(
                'The contract [_4] has changed from [_1][_2] to [_1][_3].',
                $currency,
                to_monetary_number_format($amount),
                to_monetary_number_format($recomputed_amount),
                $what_changed
            );

            return Error::Base->cuss(
                -type => 'PriceMoved',
                -mesg =>
                    "Difference between submitted and newly calculated bet price: currency $currency, amount: $amount, recomputed amount: $recomputed_amount",
                -message_to_client => $market_moved,
            );
        } else {
            if ($move <= $allowed_move and $move >= -$allowed_move) {
                $final_value = $amount;
            } elsif ($move > $allowed_move) {
                $self->execute_at_better_price(1);
                $final_value = $recomputed_amount;
            }
        }

        # adjust the value here
        if ($amount_type eq 'payout') {
            $self->price($final_value);
        } else {
            $self->payout($final_value);

            # They are all 'payout'-based when they hit the DB.
            my $new_contract = make_similar_contract(
                $contract,
                {
                    amount_type => 'payout',
                    amount      => $final_value,
                });
            $self->contract($new_contract);
        }
    }

    return;
}

sub _is_valid_to_buy {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_valid_to_buy) {
        return Error::Base->cuss(
            -type              => 'InvalidtoBuy',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }

    return;
}

sub _is_valid_to_sell {
    my $self     = shift;
    my $contract = $self->contract;

    # we shouldn't we recreating contract for spreads.
    if ($contract->date_pricing->is_after($contract->date_start) and not $contract->is_spread) {
        # It's started, get one prepared for sale.
        $contract = make_similar_contract($contract, {for_sale => 1});
        $self->contract($contract);
    }

    if (not $contract->is_valid_to_sell) {
        return Error::Base->cuss(
            -type              => 'InvalidtoSell',
            -mesg              => $contract->primary_validation_error->message,
            -message_to_client => $contract->primary_validation_error->message_to_client
        );
    }

    return;
}

sub _validate_date_pricing {
    my $self     = shift;
    my $contract = $self->contract;

    if (not $contract->is_expired
        and abs(time - $contract->date_pricing->epoch) > 20)
    {
        return Error::Base->cuss(
            -type              => 'InvalidDatePricing',
            -mesg              => 'Bet was validated for a time [' . $contract->date_pricing->epoch . '] too far from now[' . time . ']',
            -message_to_client => BOM::Platform::Context::localize('This contract cannot be properly validated at this time.'));
    }
    return;
}

=head2 $self->_validate_buy_transaction_rate

Validate the client's buy transaction rate does not exceed our limits

=cut

sub _validate_buy_transaction_rate {
    my $self = shift;

    return $self->__validate_transaction_rate_limit('buy');
}

=head2 $self->_validate_sell_transaction_rate

Validate the client's sell transaction rate does not exceed our limits

=cut

sub _validate_sell_transaction_rate {
    my $self = shift;

    return $self->__validate_transaction_rate_limit('sell');
}

sub __validate_transaction_rate_limit {
    my ($self, $what) = @_;
    my $client = $self->client;
    $what = lc $what;

    # Define the appropriate rates in `bom-platform/config/environments/*/perl_rate_limitations.yml`
    # before attempting to apply them here.

    return unless $client->is_virtual;    # We only limit virtual accounts at this point

    my $service = 'virtual_' . $what . '_transaction';
    my $loginid = $client->loginid;

    if (
        not within_rate_limits({
                service  => $service,
                consumer => $loginid,
            }))
    {
        return Error::Base->cuss(
            -type              => ucfirst($what) . 'RateExceeded',
            -mesg              => $loginid . ' request exceeds rate limits for ' . $service,
            -message_to_client => BOM::Platform::Context::localize('Too many recent attempts. Try again later.'));
    }

    return;
}

=head2 $self->_validate_iom_withdrawal_limit

Validate the withdrawal limit for IOM region

=cut

sub _validate_iom_withdrawal_limit {
    my $self   = shift;
    my $client = $self->client;

    return if $client->is_virtual;

    my $landing_company = BOM::Platform::Runtime->instance->broker_codes->landing_company_for($client->broker_code);
    return if ($landing_company->country ne 'Isle of Man');

    my $landing_company_short = $landing_company->short;
    my $numdays               = BOM::Platform::Runtime->instance->app_config->payments->withdrawal_limits->$landing_company_short->for_days;
    my $numdayslimit          = BOM::Platform::Runtime->instance->app_config->payments->withdrawal_limits->$landing_company_short->limit_for_days;
    my $lifetimelimit         = BOM::Platform::Runtime->instance->app_config->payments->withdrawal_limits->$landing_company_short->lifetime_limit;

    if ($client->client_fully_authenticated) {
        $numdayslimit  = 99999999;
        $lifetimelimit = 99999999;
    }

    # withdrawal since $numdays
    my $payment_mapper = BOM::Database::DataMapper::Payment->new({client_loginid => $client->loginid});
    my $withdrawal_in_days = $payment_mapper->get_total_withdrawal({
        start_time => Date::Utility->new(Date::Utility->new->epoch - 86400 * $numdays),
        exclude    => ['currency_conversion_transfer'],
    });
    $withdrawal_in_days = roundnear(0.01, amount_from_to_currency($withdrawal_in_days, $client->currency, 'EUR'));

    # withdrawal since inception
    my $withdrawal_since_inception = $payment_mapper->get_total_withdrawal({exclude => ['currency_conversion_transfer']});
    $withdrawal_since_inception = roundnear(0.01, amount_from_to_currency($withdrawal_since_inception, $client->currency, 'EUR'));

    my $remaining_withdrawal_eur =
        roundnear(0.01, min(($numdayslimit - $withdrawal_in_days), ($lifetimelimit - $withdrawal_since_inception)));

    if ($remaining_withdrawal_eur <= 0) {
        return Error::Base->cuss(
            -type              => 'iomWithdrawalLimit',
            -mesg              => $client->loginid . ' caught in IOM withdrawal limit check',
            -message_to_client => BOM::Platform::Context::localize(
                "Due to regulatory requirements, you are required to authenticate your account in order to continue trading."),
        );
    }
    return;
}

# This validation should always come after _validate_trade_pricing_adjustment
# because we recompute the price and that's the price that we going to transact with!
sub _validate_stake_limit {
    my $self = shift;

    # spread stake validation is within its module.
    # spread bet won't be offered to maltainvest.
    return if $self->contract->is_spread;

    my $client          = $self->client;
    my $contract        = $self->contract;
    my $landing_company = $client->landing_company;
    my $currency        = $contract->currency;

    my $stake_limit =
        $landing_company->short eq 'maltainvest'
        ? BOM::Platform::Static::Config::quants->{bet_limits}->{min_stake}->{maltainvest}->{$currency}
        : $contract->staking_limits->{stake}->{min};

    if ($contract->ask_price < $stake_limit) {
        return Error::Base->cuss(
            -type => 'StakeTooLow',
            -mesg => $client->loginid . ' stake [' . $contract->ask_price . '] is lower than minimum allowable stake [' . $stake_limit . ']',
            -message_to_client => BOM::Platform::Context::localize(
                "This contract's price is [_1][_2]. Contracts purchased from [_3] must have a purchase price above [_1][_4]. Please accordingly increase the contract amount to meet this minimum stake.",
                $currency,
                to_monetary_number_format($contract->ask_price),
                $landing_company->name,
                to_monetary_number_format($stake_limit)
            ),
        );
    }
    return;
}

=head2 $self->_validate_payout_limit

Validate if payout is not over the client limits

=cut

# TODO: Checked with Quants, this is unused. Can be removed.
sub _validate_payout_limit {
    my $self = shift;

    my $client   = $self->client;
    my $contract = $self->contract;
    my $payout   = $self->payout;

    my $custom_limit = BOM::Product::CustomClientLimits->new->client_payout_limit_for_contract($client->loginid, $contract);

    if (defined $custom_limit and $payout > $custom_limit) {
        return Error::Base->cuss(
            -type              => 'PayoutLimitExceeded',
            -mesg              => $client->loginid . ' payout [' . $payout . '] over custom limit[' . $custom_limit . ']',
            -message_to_client => ($custom_limit == 0)
            ? BOM::Platform::Context::localize('This contract is unavailable on this account.')
            : BOM::Platform::Context::localize(
                'This contract is limited to ' . to_monetary_number_format($custom_limit) . ' payout on this account.'
            ),
        );
    }
    return;
}

=head2 $self->_validate_jurisdictional_restrictions

Validates whether the client has provided his residence country

=cut

sub _validate_jurisdictional_restrictions {
    my $self        = shift;
    my $client      = $self->client;
    my $contract    = $self->contract;
    my $residence   = $client->residence;
    my $loginid     = $client->loginid;
    my $market_name = $contract->market->name;

    if (!$residence && $loginid !~ /^VRT/) {
        return Error::Base->cuss(
            -type              => 'NoResidenceCountry',
            -mesg              => 'Client cannot place contract as we do not know their residence.',
            -message_to_client => BOM::Platform::Context::localize(
                'In order for you to place contracts, we need to know your Residence (Country). Please update your settings.'),
        );
    }

    my $lc = BOM::Platform::Runtime->instance->broker_codes->landing_company_for($loginid);

    my %legal_allowed_ct = map { $_ => 1 } @{$lc->legal_allowed_contract_types};
    if (not $legal_allowed_ct{$contract->code}) {
        return Error::Base->cuss(
            -type              => 'NotLegalContractCategory',
            -mesg              => 'Clients are not allowed to trade on this contract category as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this contract.'),
        );
    }

    if (not grep { $market_name eq $_ } @{$lc->legal_allowed_markets}) {
        return Error::Base->cuss(
            -type              => 'NotLegalMarket',
            -mesg              => 'Clients are not allowed to trade on this markets as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this market.'),
        );
    }

    if ($residence && $market_name eq 'random' && BOM::Platform::Runtime->instance->random_restricted_country($residence)) {
        return Error::Base->cuss(
            -type => 'RandomRestrictedCountry',
            -mesg => 'Clients are not allowed to place Random contracts as their country is restricted.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, contracts on Random Indices are not available in your country of residence'),
        );
    }

    my %legal_allowed_underlyings = map { $_ => 1 } @{$lc->legal_allowed_underlyings};
    if (not $legal_allowed_underlyings{all} and not $legal_allowed_underlyings{$contract->underlying->symbol}) {
        return Error::Base->cuss(
            -type              => 'NotLegalUnderlying',
            -mesg              => 'Clients are not allowed to trade on this underlying as its restricted for this landing company',
            -message_to_client => BOM::Platform::Context::localize('Please switch accounts to trade this underlying.'),
        );
    }

    return;
}

=head2 $self->_validate_client_status

Validates to make sure that the client with unwelcome status
is not able to purchase contract

=cut

sub _validate_client_status {
    my $self   = shift;
    my $client = $self->client;

    if ($client->get_status('unwelcome') or $client->get_status('disabled')) {
        return Error::Base->cuss(
            -type              => 'ClientUnwelcome',
            -mesg              => 'your account is not authorised for any further contract purchases.',
            -message_to_client => BOM::Platform::Context::localize('Sorry, your account is not authorised for any further contract purchases.'),
        );
    }

    return;
}

=head2 $self->_validate_client_self_exclusion

Validates to make sure that the client with self exclusion
is not able to purchase contract

=cut

sub _validate_client_self_exclusion {
    my $self   = shift;
    my $client = $self->client;

    my $limit_excludeuntil;
    if (    $limit_excludeuntil = $client->get_self_exclusion
        and $limit_excludeuntil = $limit_excludeuntil->exclude_until
        and Date::Utility->new->is_before(Date::Utility->new($limit_excludeuntil)))
    {
        return Error::Base->cuss(
            -type => 'ClientSelfExcluded',
            -mesg => 'your account is not authorised for any further contract purchases.',
            -message_to_client =>
                BOM::Platform::Context::localize('Sorry, you have excluded yourself from the website until [_1].', $limit_excludeuntil),
        );
    }

    return;
}

=head2 sell_expired_contracts

Static function: Sells expired contracts.
For contracts with missing market data, settle them manually for real money accounts, but sell with purchase price for virtual account

Returns: HashRef, with:
'total_credited', total amount credited to Client
'skip_contract', count for expired contracts that failed to be sold

=cut

my %source_to_sell_type = (
    1063 => 'expiryd',    # app_id for `binaryexpiryd`, see `expiryd.pl`
);

sub sell_expired_contracts {
    my $args         = shift;
    my $client       = $args->{client};
    my $source       = $args->{source};
    my $contract_ids = $args->{contract_ids};

    my $time_start = Time::HiRes::time;

    my $currency = $client->currency;
    my $loginid  = $client->loginid;

    # Apply rate limits before doing the full lookup
    return
        if (
        $client->is_virtual              # Only virtuals
        and not defined $contract_ids    # who are just selling "whatever"
        and not within_rate_limits({
                service  => 'virtual_batch_sell',
                consumer => $loginid
            }));

    my $mapper = BOM::Database::DataMapper::FinancialMarketBet->new({
        client_loginid => $loginid,
        currency_code  => $currency,
        broker_code    => $client->broker_code,
        operation      => 'replica',
    });

    my $bets =
          (defined $contract_ids)
        ? [map { $_->financial_market_bet_record } @{$mapper->get_fmb_by_id($contract_ids)}]
        : $mapper->get_fmbs_by_loginid_and_currency({
            exclude_sold => 1,
            only_expired => $args->{only_expired},
        });

    return unless $bets and @$bets;

    my $now = Date::Utility->new;
    my @bets_to_sell;
    my @transdata;
    my %stats_attempt;
    my %stats_failure;
    for my $bet (@$bets) {
        my $contract;
        my $error;
        try { $contract = produce_contract($bet->{short_code}, $currency); } catch { $error = 1; };
        next if $error;

        my $logging_class = $BOM::Database::Model::Constants::BET_TYPE_TO_CLASS_MAP->{$contract->code};
        $stats_attempt{$logging_class}++;
        if (not $contract->is_expired) {
            $stats_failure{$logging_class}{'NotExpired'}++;
            next;
        } elsif ($contract->category_code eq 'legacy') {
            $stats_failure{$logging_class}{Legacy}++;
            next;
        }

        try {
            if ($contract->is_valid_to_sell) {
                @{$bet}{qw/sell_price sell_time/} = ($contract->bid_price, $now->db_timestamp);
                $bet->{absolute_barrier} = $contract->barrier->as_absolute
                    if $contract->category_code eq 'asian' and $contract->is_after_expiry;
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };
            } elsif ($client->is_virtual and $now->epoch >= $contract->date_settlement->epoch + 3600) {
                # for virtual, if can't settle bet due to missing market data, sell contract with buy price
                @{$bet}{qw/sell_price sell_time/} = ($bet->{buy_price}, $now->db_timestamp);
                push @bets_to_sell, $bet;
                push @transdata,
                    {
                    staff_loginid => 'AUTOSELL',
                    source        => $source,
                    };
            } else {
                $stats_failure{$logging_class}{_normalize_error($contract->primary_validation_error)}++;
            }
        };
    }

    my $broker    = lc($client->broker_code);
    my $virtual   = $client->is_virtual ? 'yes' : 'no';
    my $rmgenv    = BOM::System::Config::env;
    my $sell_type = (defined $source and exists $source_to_sell_type{$source}) ? $source_to_sell_type{$source} : 'expired';
    my @tags      = ("broker:$broker", "virtual:$virtual", "rmgenv:$rmgenv", "sell_type:$sell_type",);

    for my $class (keys %stats_attempt) {
        stats_count("transaction.sell.attempt", $stats_attempt{$class}, {tags => [@tags, "contract_class:$class"]});
    }
    for my $class (keys %stats_failure) {
        for my $reason (keys %{$stats_failure{$class}}) {
            stats_count(
                "transaction.sell.failure",
                $stats_failure{$class}{$reason},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error($reason)]});
        }
    }

    return unless @bets_to_sell;    # nothing to do

    my $fmb_helper = BOM::Database::Helper::FinancialMarketBet->new(
        transaction_data => \@transdata,
        bet_data         => \@bets_to_sell,
        account_data     => {
            client_loginid => $loginid,
            currency_code  => $currency
        },
        db => BOM::Database::ClientDB->new({broker_code => $client->broker_code})->db,
    );

    my $sold = try {
        $fmb_helper->batch_sell_bet;
    }
    catch {
        get_logger->warn(ref eq 'ARRAY' ? "@$_" : "$_");
    };

    if (not $sold or @bets_to_sell > @$sold) {
        # We missed some, let's figure out which ones they are.
        my %sold_fmbs = map { $_->{fmb}->{id} => 1 } @{$sold // []};
        my %missed;
        foreach my $bet (@bets_to_sell) {
            next if $sold_fmbs{$bet->{id}};    # Was not missed.
            $missed{$bet->{bet_class}}++;
        }
        foreach my $class (keys %missed) {
            stats_count("transaction.sell.failure", $missed{$class},
                {tags => [@tags, "contract_class:$class", "reason:" . _normalize_error("TransactionFailure")]});
        }
    }

    return unless $sold and @$sold;            # nothing has been sold

    my $skip_contract  = @$bets - @$sold;
    my $total_credited = 0;
    my %stats_success;
    for my $t (@$sold) {
        $total_credited += $t->{txn}->{amount};
        $stats_success{$t->{fmb}->{bet_class}}->[0]++;
        $stats_success{$t->{fmb}->{bet_class}}->[1] += $t->{txn}->{amount};
    }
    for my $class (keys %stats_success) {
        stats_count("transaction.sell.success", $stats_success{$class}->[0], {tags => [@tags, "contract_class:$class"]});
        if ($rmgenv eq 'production' and $virtual eq 'no') {
            my $usd_amount = int(in_USD($stats_success{$class}->[1], $currency) * 100);
            stats_count('business.buy_minus_sell_usd', -$usd_amount, {tags => [@tags, "contract_class:$class"]});
        }
    }

    return {
        skip_contract       => $skip_contract,
        total_credited      => $total_credited,
        number_of_sold_bets => 0 + @$sold,
    };
}

=head2 validate_request_method

Static function: Validate the request method to POST

Returns: Error::Base object with message to client

=cut

sub validate_request_method {
    if (BOM::Platform::Context::request()->http_method ne 'POST') {
        return Error::Base->cuss(
            -type              => 'RequestNotPost',
            -mesg              => 'Sorry, this page cannot be refreshed.',
            -message_to_client => BOM::Platform::Context::localize('Sorry, this page cannot be refreshed.'),
        );
    }
    return;
}

sub report {
    my $self = shift;
    return
          "Transaction Report:\n"
        . sprintf("%30s: %s\n", 'Client',                 $self->client)
        . sprintf("%30s: %s\n", 'Contract',               $self->contract->code)
        . sprintf("%30s: %s\n", 'Price',                  $self->price)
        . sprintf("%30s: %s\n", 'Payout',                 $self->payout)
        . sprintf("%30s: %s\n", 'Amount Type',            $self->amount_type)
        . sprintf("%30s: %s\n", 'Comment',                $self->comment || '')
        . sprintf("%30s: %s\n", 'Staff',                  $self->staff)
        . sprintf("%30s: %s",   'Transaction Parameters', Dumper($self->transaction_parameters))
        . sprintf("%30s: %s\n", 'Transaction ID',         $self->transaction_id || -1)
        . sprintf("%30s: %s\n", 'Purchase Date',          $self->purchase_date->datetime_yyyymmdd_hhmmss);
}

no Moose;

__PACKAGE__->meta->make_immutable;

1;
