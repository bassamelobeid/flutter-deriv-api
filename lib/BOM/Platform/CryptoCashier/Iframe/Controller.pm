package BOM::Platform::CryptoCashier::Iframe::Controller;

use v5.10;
use Mojo::Base 'Mojolicious::Controller';
use List::Util qw( first any );
use Text::Trim;
use Date::Utility;

use BOM::User::Client;
use BOM::Platform::Context qw( localize );
use BOM::Platform::Client::CashierValidation;
use BOM::Platform::CryptoCashier::API;
use BOM::Database::ClientDB;
use BOM::Database::Model::HandoffToken;
use BOM::Database::AutoGenerated::Rose::HandoffToken::Manager;
use BOM::Config;
use BOM::Config::CurrencyConfig;
use BOM::Config::Runtime;
use BOM::Rules::Engine;
use BOM::Config::Redis;

use LandingCompany::Registry;
use Log::Any qw( $log );

use constant {
    ACTION_TYPE_CANCEL_WITHDRAWAL             => 'cancel_withdraw',
    ACTION_TYPE_DEPOSIT                       => 'deposit',
    ACTION_TYPE_WITHDRAW                      => 'withdraw',
    CRYPTO_CONFIG_REDIS_CLIENT_MIN_AMOUNT     => "rpc::cryptocurrency::crypto_config::client_min_amount::",
    CRYPTO_CONFIG_REDIS_CLIENT_MIN_AMOUNT_TTL => 120,
};

# Fix for Cryptocashier Page.
my %crypto_symbols = (
    UST => 'USDT',
);

# this is sub to validate if current session is valid
# our RPC sends handshake url back with token
# this sub validates that token so that no one else should
# call our cashier directly

sub handshake {
    my $c = shift;

    my $currency = $c->stash('currency');
    my ($token, $loginid, $action) = map { $c->param($_) } qw/token loginid action/;
    my $client = BOM::User::Client->new({
        loginid      => $loginid,
        db_operation => 'replica'
    });

    return $c->_render_error(localize("Invalid request.")) unless $currency;

    # validations
    return $c->_render_error(localize("Invalid request.")) if (not $token   or $token   !~ /^[a-zA-Z0-9]{40}$/);
    return $c->_render_error(localize("Invalid request.")) if (not $loginid or $loginid !~ /^[A-Z]{2,4}\d{1,10}+$/);
    return $c->_render_error(localize("Invalid request.")) if (not $action  or $action  !~ /^[a-zA-Z]{1,20}$/);

    # case-insensitive check because we'll have currency codes mixed of lower and upper case
    return $c->_render_error(localize("Invalid currency.")) if ($client->currency !~ /^$currency$/i);

    my $rule_engine = BOM::Rules::Engine->new(client => $client);
    my $validation  = BOM::Platform::Client::CashierValidation::validate(
        loginid     => $loginid,
        action      => $action,
        is_internal => 0,
        is_cashier  => 1,
        rule_engine => $rule_engine
    );
    return $c->_render_error($validation->{error}{message_to_client}) if $validation->{error};

    my $res = _check_handoff_token_key($loginid, $token);

    # no handshake or wrong session
    return $c->_render_error(localize('Invalid request.')) if $res->{is_invalid};

    my $request    = $c->stash('request');
    my $brand      = $request->brand;
    my $brand_name = eval { $brand->name };
    my $app_id     = $request->app_id;

    $c->session($brand_name . '__loginid'   => $loginid);
    $c->session($brand_name . '__handshake' => 1);

    # when we redirect the mojo request parameters are not passed too
    # so we need manually pass the language parameter
    my $language = $c->req->param('l');
    unless ($language && first { $_ eq uc $language } BOM::Config::Runtime->instance->app_config->cgi->allowed_languages->@*) {
        $language = 'EN';
    }

    my $theme = $brand->theme($c->req->param('theme'));
    return $c->redirect_to("/cryptocurrency/$currency/$action?l=$language&brand=$brand_name&theme=$theme&app_id=$app_id");
}

sub deposit {
    return (shift)->_act(ACTION_TYPE_DEPOSIT);
}

sub withdraw {
    return (shift)->_act(ACTION_TYPE_WITHDRAW);
}

sub cancel_withdraw {
    return (shift)->_act(ACTION_TYPE_CANCEL_WITHDRAWAL);
}

sub _act {
    my ($c, $action) = @_;

    return $c->_render_error(localize('Sorry, cashier is temporarily unavailable due to system maintenance.'))
        if BOM::Config::CurrencyConfig::is_crypto_cashier_suspended();

    my $request   = $c->stash('request');
    my $brand_obj = $request->brand;
    my $brand     = eval { $brand_obj->name };

    if (not $brand or not $c->session($brand . '__loginid') or (not $c->session($brand . '__handshake') and not $c->session->{$brand . '__session'}))
    {
        return $c->_render_error(localize('Your current cashier session has expired. Please start again.'));
    }

    my $loginid = $c->session($brand . '__loginid');
    # we cannot use replica mode here as helper performs
    # ID authentication that modifies the client state
    my $client = BOM::User::Client->new({
        loginid => $loginid,
    });

    return $c->_render_error(localize('Invalid request.')) unless $client;
    return $c->_render_error(localize('Invalid request.')) unless $client->default_account;

    my $rule_engine = BOM::Rules::Engine->new(client => $client);
    my $validation  = BOM::Platform::Client::CashierValidation::validate(
        loginid     => $loginid,
        action      => $action,
        is_internal => 0,
        is_cashier  => 1,
        rule_engine => $rule_engine
    );
    # this validation is also done in RPC but better to be done here as well to be double sure
    return $c->_render_error($validation->{error}{message_to_client}) if exists $validation->{error};

    if ($c->session($brand . '__handshake')) {
        # first time on this page from /handshake, generate action dependant session
        $c->session($brand . '__session' => $action . _get_handoff_token_key($loginid));
        delete $c->session->{$brand . '__handshake'};
    } else {
        my $session_action = $action eq ACTION_TYPE_CANCEL_WITHDRAWAL ? ACTION_TYPE_WITHDRAW : $action;
        # session should exist and belong to this action
        my $res = _check_handoff_token_key($loginid, substr((($c->session($brand . '__session') // '') =~ s/^$session_action//r), 0, 40));
        if ($res->{is_valid}) {
            $c->session($brand . '__session' => $session_action . _get_handoff_token_key($loginid));
        } else {
            # no handshake or wrong session
            return $c->_render_error(localize('Invalid request.'));
        }
    }

    my %params     = map { $_ => $c->param($_) } qw/l app_id brand/;
    my $crypto_api = BOM::Platform::CryptoCashier::API->new(\%params);

    return $c->_withdraw($crypto_api, $client)        if $action eq ACTION_TYPE_WITHDRAW;
    return $c->_deposit($crypto_api, $client)         if $action eq ACTION_TYPE_DEPOSIT;
    return $c->_cancel_withdraw($crypto_api, $client) if $action eq ACTION_TYPE_CANCEL_WITHDRAWAL;
}

sub _deposit {
    my ($c, $crypto_api, $client) = @_;

    my $currency_code = $client->account->currency_code;

    my $deposit_response = $crypto_api->deposit($client->loginid, $currency_code);
    return $c->_render_error($deposit_response->{error}->{message_to_client}) if $deposit_response->{error};

    my $deposit_address = $deposit_response->{deposit}{address};

    my $transaction_response = $crypto_api->transactions($client->loginid, 'deposit', $currency_code);
    return $c->_render_error($transaction_response->{error}->{message_to_client}) if $transaction_response->{error};

    my $trxs = $transaction_response->{crypto} || [];
    # Formate the transactions dates
    my @transactions = map { format_transaction_date($_) } $trxs->@*;

    my $currency_name    = LandingCompany::Registry::get_currency_definition($currency_code)->{name};
    my $currency_display = $crypto_symbols{$currency_code} // $currency_code;

    return $c->render(
        template       => ACTION_TYPE_DEPOSIT,
        layout         => 'default',
        theme          => $c->_get_theme,
        website_domain => $c->_website_domain,
        trxs           => \@transactions,
        currency       => {
            code => $currency_display,
            name => $currency_name
        },
        deposit_page_warning_message => deposit_page_warning_message($currency_code) // '',
        deposit_address              => $deposit_address,
        csrf_token                   => $c->csrf_token,
        loginid                      => $client->loginid,
    );
}

sub _withdraw {
    my ($c, $crypto_api, $client) = @_;

    my $currency_code            = $client->account->currency_code;
    my $currency_name            = LandingCompany::Registry::get_currency_definition($currency_code)->{name};
    my $currency_display         = $crypto_symbols{$currency_code} // $currency_code;
    my $redis_read               = BOM::Config::Redis::redis_replicated_read();
    my $client_min_locked_amount = $redis_read->get(CRYPTO_CONFIG_REDIS_CLIENT_MIN_AMOUNT . $client->loginid) // undef;

    if (my $address = trim($c->param('address'))) {
        if ($c->csrf_token ne $c->param('csrf_token')) {
            return $c->_render_error(localize('Invalid session.'));
        }

        my $amount = $c->param('amount');

        my $rule_engine = BOM::Rules::Engine->new(client => $client);
        my $cashier_validation_error =
            BOM::Platform::Client::CashierValidation::validate_crypto_withdrawal_request($client, $address, $amount, $rule_engine);

        if ($cashier_validation_error) {
            $c->stash(
                error   => $cashier_validation_error->{error}->{message_to_client},
                address => $address,
            );
        } else {
            my $withdraw_response = $crypto_api->withdraw($client->loginid, $address, $amount, 0, $currency_code, $client_min_locked_amount);
            if ($withdraw_response->{error}) {
                $c->stash(
                    error   => $withdraw_response->{error}->{message_to_client},
                    address => $address,
                );
            }
        }

    }

    my $transaction_response = $crypto_api->transactions($client->loginid, 'withdrawal', $currency_code);
    return $c->_render_error($transaction_response->{error}->{message_to_client}) if $transaction_response->{error};

    my $trxs = $transaction_response->{crypto} || [];
    # Formate the transactions dates
    my @transactions = map { format_transaction_date($_) } $trxs->@*;

    my $min_withdrawal;
    # check if locked minimum withdrawal amount is still there?
    if ($client_min_locked_amount) {
        $min_withdrawal = $client_min_locked_amount;
    } else {
        my $crypto_config = $crypto_api->crypto_config($currency_code);
        if ($crypto_config->{currencies_config}{$currency_code}) {
            $min_withdrawal = $crypto_config->{currencies_config}{$currency_code}{minimum_withdrawal};
            my $redis_write = BOM::Config::Redis::redis_replicated_write();
            $redis_write->setex(CRYPTO_CONFIG_REDIS_CLIENT_MIN_AMOUNT . $client->loginid, CRYPTO_CONFIG_REDIS_CLIENT_MIN_AMOUNT_TTL, $min_withdrawal)
                if $min_withdrawal;
        }
    }
    return $c->render(
        template       => ACTION_TYPE_WITHDRAW,
        layout         => 'default',
        theme          => $c->_get_theme,
        website_domain => $c->_website_domain,
        language       => $c->req->param('l'),
        brand          => $c->req->param('brand'),
        app_id         => $c->req->param('app_id'),
        currency       => {
            code     => $currency_display,
            name     => $currency_name,
            url_code => $currency_code
        },
        trxs           => \@transactions,
        csrf_token     => $c->csrf_token,
        min_withdrawal => $min_withdrawal // 0,
        loginid        => $client->loginid,
        precision      => Format::Util::Numbers::get_precision_config()->{amount}->{$currency_code},
    );
}

sub _cancel_withdraw {
    my ($c, $crypto_api, $client) = @_;

    my $currency_code = $client->account->currency_code;
    my $param         = $c->stash('request')->params;
    my $address       = $param->{address};
    my $database_id   = $param->{id};
    $c->_render_error(localize("Invalid request.")) unless $address and $database_id;

    my $withdrawal_cancel_response = $crypto_api->withdrawal_cancel($client->loginid, $database_id, $currency_code);

    my $result_message = localize("Your withdrawal transaction for address: [_1] has been cancelled.", $address);
    my $is_successful  = 1;

    if ($withdrawal_cancel_response->{error}) {
        $result_message = $withdrawal_cancel_response->{error}->{message_to_client};
        $is_successful  = 0;
    }

    $c->flash(
        code    => $is_successful,
        message => $result_message
    );

    my $url = $c->url_for("/cryptocurrency/" . lc $currency_code . "/withdraw");
    $c->redirect_to(
        $url->query(
            l      => $param->{l},
            brand  => $param->{brand},
            theme  => $param->{theme},
            app_id => $param->{app_id}));
}

sub _render_error {
    my ($c, $err) = @_;

    return $c->render(
        template       => 'error',
        layout         => 'default',
        theme          => $c->_get_theme,
        website_domain => $c->_website_domain,
        error          => $err,
    );
}

sub _get_handoff_token_key {
    my $loginid = shift;

    # create handoff token
    my $cb = BOM::Database::ClientDB->new({
        client_loginid => $loginid,
    });

    BOM::Database::AutoGenerated::Rose::HandoffToken::Manager->delete_handoff_token(
        db    => $cb->db,
        where => [
            expires => {lt => time},
        ]);

    my $handoff_token = BOM::Database::Model::HandoffToken->new(
        db                 => $cb->db,
        data_object_params => {
            key            => BOM::Database::Model::HandoffToken::generate_session_key,
            client_loginid => $loginid,
            expires        => time + 600,
        });
    $handoff_token->save;

    return $handoff_token->key;
}

sub _check_handoff_token_key {
    my ($loginid, $token) = @_;

    my $clientdb_dbic = BOM::Database::ClientDB->new({
            client_loginid => $loginid,
        })->db->dbic;

    my $handoff_token = $clientdb_dbic->run(
        fixup => sub {
            my $sth = $_->prepare('select * from betonmarkets.get_handoff_token(?::VARCHAR, ?::VARCHAR)');
            $sth->execute($token, $loginid);
            return $sth->fetchrow_hashref();
        });

    return {is_invalid => 1} if !$handoff_token;

    my $handoff_token_id = $handoff_token->{id};
    # delete token so that it cannot be used more than once
    $clientdb_dbic->run(
        fixup => sub {
            my $sth = $_->prepare('select from betonmarkets.delete_handoff_token_by_id(?::BIGINT)');
            $sth->execute($handoff_token_id);
        });

    return {is_valid => 1};
}

sub notfound {
    my ($c) = @_;

    return $c->_render_error(localize('Invalid request.'));
}

=head2 _get_theme

Returns the theme selection from the request, defaults to C<light>.

=cut

sub _get_theme {
    return shift->req->param('theme') || 'light';
}

=head2 _website_domain

Returns the domain per brand and app_id.

=cut

sub _website_domain {
    my $c     = shift;
    my $brand = BOM::Config->brand();
    my $host  = $c->req->url->to_abs->host // '';
    # 15284: binary.me  1: binary.com
    # TODO I know it is very ugly. Please tell me if you have better idea
    my $domain = ($host =~ /\.me/) ? $brand->whitelist_apps->{15284} : $brand->whitelist_apps->{1};
    return $domain->{name};
}

=head2 deposit_page_warning_message

Place holder for crypto cashier deposit page currency warning message

=over 4

=item * C<$currency_code> - (string) The currency code

=back

=cut

sub deposit_page_warning_message {
    my $currency_code = shift;

    my $warning_message = localize('Sending any other digital currency will result in the loss of your deposit.');

    my %currency_warnings = (
        ETH   => ['Ethereum', 'ETH'],
        USDC  => ['Ethereum', 'ERC20'],
        eUSDT => ['Ethereum', 'ERC20'],
        tUSDT => ['TRON',     'TRC20'],
    );
    if (my $warning_params = $currency_warnings{$currency_code}) {
        $warning_message =
            localize('To avoid losing your funds, please use the [_1][_2] ([_3]) [_4][_5] only. Other networks are not supported for [_6] deposits.',
            '<strong>', $warning_params->@*, 'network', '</strong>', $currency_code);
    }

    return $warning_message;
}

=head2 format_transaction_date

Returns the domain per brand and app_id.

=cut

sub format_transaction_date {
    my $transaction = shift;
    $transaction->{submit_date} = Date::Utility->new($transaction->{submit_date})->datetime_yyyymmdd_hhmmss;
    return $transaction;
}

1;
