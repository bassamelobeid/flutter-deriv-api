
=head1 NAME

BOM::Platform::Authorization::Token - Auth Token Managmenet

=cut

package BOM::Platform::Authorization::Token;
use Moose;
use Carp;
use MIME::Base64 qw(encode_base64url);
use JSON qw(to_json from_json);

use BOM::Database::AutoGenerated::Rose::Auth::User;
use BOM::Database::AutoGenerated::Rose::Auth::Grant;
use BOM::Utility::Random;
use BOM::Database::AuthDB;

use 5.010;

sub _db {
    return BOM::Database::AuthDB::rose_db;
}

=head1 SYNOPSIS

  my $token = BOM::Platform::Authorization::Token->new(
       client_id => 1,
       token     => $string,
       login_id  => 'foo',
       scopes    => [qw(price trade password cashier) ]
  )->save();

  my $token = BOM::Platform::Authorization::Token->validate(
       scope => 'price', 
       token => $string,
      client_id => 1,
  ); # returns undef if not valid

=head1 PROPERTIES

=head2 client_id

Defaults to 1 (binary.com web site).  This is the ID of the client app, needed
for some Apigee uses.

=cut

has client_id => (
    is      => 'ro',
    isa     => 'Int',
    default => 1
);

=head2 token 

Defaults to a random string.  It is the secret key for the token

=cut

has token => (
    is      => 'ro',
    isa     => 'Str',
    default => sub {
        encode_base64url(BOM::Utility::Random->bytes(20));
    });

=head2 login_id

This is the username/login id of the auth principle

=cut

has login_id => (
    is       => 'ro',
    isa      => 'Str',
    required => 1
);

=head2 expiration_time

When the token expires.

=cut

has expiration_time => (is => 'ro');

=head2 scopes

Array ref of strings, indicating scopes.  This module does not check to see
if requested scopes are valid (which is useful when applications like backoffice
need tokens with different scopes).

=cut

has scopes => (
    is  => 'ro',
    isa => 'ArrayRef[Str]'
);

=head1 METHODS

=head2 save

Saves the token and returns self if successful (or undef if not).

=cut

sub save {
    my ($self) = @_;
    my $user = BOM::Database::AutoGenerated::Rose::Auth::User->new(
        login => $self->login_id,
        db    => _db,
    );
    $user->load(speculative => 1) || $user->save;
    my $expires = DateTime->from_epoch(epoch => $self->expiration_time);
    my $grant = BOM::Database::AutoGenerated::Rose::Auth::Grant->new(
        client => $self->client_id || 1,
        user => $user,
        expires => $expires,
        scopes  => to_json($self->scopes),
        token   => $self->token,
        db      => _db,
    );
    return $self if $grant->save;
    return;
}

=head2 validate

Retrieves the token from the db and returns it or undef if not validated.

=cut

my $last_err;

sub validate {
    my ($class, %args) = @_;
    my $wantscope = $args{scope};

    $last_err = undef;
    $args{client_id} //= 1;

    if (my $token_info = Cache::RedisDB->get('AUTH_TOKEN', $args{token})) {
        return $token_info unless defined $wantscope;
        unless (grep { $_ eq $args{scope} } @{$token_info->{scopes}}) {
            $last_err = "token is not authorized for this scope";
            return;
        }
        return $token_info;
    }

    # this will die if the given token has invalid format..
    my $grant = eval { BOM::Database::AutoGenerated::Rose::Auth::Grant->new(token => $args{token}, db => _db) };
    if ($last_err = $@) {
        return;
    }
    unless (
        $grant->load(
            speculative => 1,
        ))
    {
        return {reason => "token not found"};
    }
    unless (defined $grant->client_id) {
        $last_err = 'Client id not found';
        return;
    }
    unless ($grant->client_id == $args{client_id}) {
        $last_err = "token is not valid for this client";
        return;
    }
    unless ($grant->expires->epoch > time) {
        $last_err = "token has expired";
        return;
    }
    my $granted_scopes = from_json($grant->scopes);
    my %granted_scopes = map { $_ => 1 } @{$granted_scopes};
    if (defined $wantscope) {
        unless ($granted_scopes{$args{scope}}) {
            $last_err = "token is not authorized for this scope";
            return;
        }
    }
    my $login = $grant->user->login;

    my $token_info = __PACKAGE__->new(
        login_id        => $login,
        token           => $args{token},
        scopes          => $granted_scopes,
        expiration_time => $grant->expires,
    );
    # caching for  1 hr
    Cache::RedisDB->set('AUTH_TOKEN', $args{token}, $token_info, 3600);
    return $token_info;
}

=head2 last_err

Retrieves the last error from token validation.  Is undef unless last validation failed.

=cut

sub last_err { return $last_err; }

__PACKAGE__->meta->make_immutable;

no Moose;

1;
