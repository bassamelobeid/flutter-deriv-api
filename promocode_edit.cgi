#!/etc/rmg/bin/perl
package main;

use strict;
use warnings;

use Scalar::Util qw( blessed looks_like_number);
use Syntax::Keyword::Try;
use JSON::MaybeUTF8 qw(:v1);
use Date::Utility;

use BOM::Backoffice::PlackHelpers qw( PrintContentType );
use BOM::Backoffice::Request qw(request);
use f_brokerincludeall;
use BOM::Backoffice::Sysinit ();
BOM::Backoffice::Sysinit::init();

PrintContentType();
BrokerPresentation('EDIT PROMOTIONAL CODE DETAILS');

my %input = %{request()->params};

sub is_valid_promocode { return uc($_[0]->{promocode} // '') =~ /^\s*[A-Z0-9_\-\.]{1,20}\s*$/ ? 1 : 0 }

if (!is_valid_promocode(\%input) && $input{save}) {
    my $url = request()->url_for(sprintf 'backoffice/promocode_edit.cgi?broker=%s&isnew=1', $input{broker} || 'CR');
    print qq{<p class="notify notify--danger">Must enter a valid promocode: must be letters and numbers, and no longer than 20 characters</p>};
    print qq{<a class="btn btn--primary" href="$url">Create new promocode</a>};
    code_exit_BO();
}

my $pc;
if (my $code = $input{promocode}) {
    $code =~ s/^\s+|\s+$//g;
    $pc = BOM::Database::AutoGenerated::Rose::PromoCode->new(
        broker => 'FOG',
        code   => uc($code));
    $pc->set_db('collector');
    $pc->load(speculative => 1);
}

Bar($pc ? "EDIT PROMOTIONAL CODE" : "ADD PROMOTIONAL CODE");

my @messages;
my $countries_instance = request()->brand->countries_instance;

if ($input{save}) {
    $input{amount}       = $input{promo_code_type} =~ /^(FREE_BET|GET_X_WHEN_DEPOSIT_Y)$/ ? $input{amount_fixed}       : $input{amount_dynamic};
    $input{min_turnover} = $input{promo_code_type} eq 'FREE_BET'                          ? $input{min_turnover_fixed} : $input{min_turnover_dynamic};

    for (qw/currency amount country min_turnover turnover_type min_deposit min_amount max_amount payment_processor/) {
        if ($input{$_}) {
            $pc->{_json}{$_} = $input{$_};
        } else {
            delete $pc->{_json}{$_};
        }
    }

    for my $name (qw/ start_date expiry_date status promo_code_type description /) {
        $pc->$name($input{$name}) if $input{$name};
    }

    @messages = _validation_errors(%input);

    if (@messages == 0) {
        try {    ## no critic (RequireCheckingReturnValueOfEval)
            $pc->start_date($input{start_date})   if $input{start_date};
            $pc->expiry_date($input{expiry_date}) if $input{expiry_date};
            $pc->status($input{status});
            $pc->promo_code_type($input{promo_code_type});
            $pc->description($input{description});

            if ($input{country_type} eq 'not_offered') {
                my $countries_not_offered = ref $input{country} ? $input{country} : [$input{country}];
                my $rt_countries          = $countries_instance->countries;
                my @countries_offered;
                foreach my $country (map { $rt_countries->code_from_country($_) } $rt_countries->all_country_names) {
                    push @countries_offered, $country unless (grep { $_ eq $country } @{$countries_not_offered});
                }
                $input{country} = join(',', @countries_offered);
            } else {
                $input{country} = join(',', @{$input{country}}) if ref $input{country};
            }

            delete @input{qw/payment_processor turnover_type/} if $input{promo_code_type} eq 'FREE_BET';
            for (qw/currency amount country min_turnover turnover_type min_deposit payment_processor min_amount max_amount/) {
                if ($input{$_}) {
                    $pc->{_json}{$_} = $input{$_};
                } else {
                    delete $pc->{_json}{$_};
                }
            }

            $pc->promo_code_config(JSON::MaybeXS->new->encode($pc->{_json}));
            $pc->save;
            push @messages, 'Save completed';
        } catch ($e) {
            push @messages, $e;
        }

        ## We want the new code to show up right away to the 'local' broker (almost always CR)
        ## The cronjob will be just fine, even if we do a local insert right away
        my $broker        = $input{broker} || 'CR';
        my $client_dbh    = BOM::Database::ClientDB->new({broker_code => $broker})->db->dbic->dbh;
        my $collector_dbh = $pc->db->dbic->dbh;
        $collector_dbh->do('COPY (SELECT * FROM betonmarkets.promo_code WHERE code = ?) TO STDOUT', undef, $pc->code);
        my $myvar = '';
        $collector_dbh->pg_getcopydata($myvar);
        $client_dbh->do('DELETE FROM betonmarkets.promo_code WHERE code = ?', undef, $pc->code);
        $client_dbh->do('COPY betonmarkets.promo_code FROM STDIN');
        $client_dbh->pg_putcopydata($myvar);
        $client_dbh->pg_endcopy();
        $client_dbh->commit();

    }

}

if ($pc) {
    $pc->{_json} ||= eval { decode_json_text(($pc->promo_code_config)) } || {};
    $pc->{$_} = Date::Utility->new($pc->$_)->date_yyyymmdd for grep { $pc->$_ } qw/start_date expiry_date/;
}

my $stash = {
    pc                 => $pc,
    pc_json            => $pc->{_json},
    messages           => \@messages,
    countries_instance => $countries_instance,
    is_valid_promocode => is_valid_promocode(\%input),
};
$stash->{isnew} = 1 if $input{isnew};

BOM::Backoffice::Request::template()->process('backoffice/promocode_edit.html.tt', $stash)
    || die("in promocode_edit: " . BOM::Backoffice::Request::template()->error());

code_exit_BO();

sub _validation_errors {

    my %input = @_;
    my @errors;

    for (qw/amount description country/) {
        $input{$_} || push @errors, "Field '$_' must be supplied";
    }

    # some of these are stored as json thus aren't checked by the orm or the database..
    for (qw/amount min_turnover min_deposit min_amount max_amount/) {
        my $val = $input{$_} || next;
        next if looks_like_number($val);
        push @errors, "Field '$_' value '$val' is not numeric";
    }

    my ($start_date, $end_date) = @input{qw/start_date expiry_date/};

    # Date validation for start and expiry date
    try {

        $start_date = Date::Utility->new($start_date);
        $end_date   = Date::Utility->new($end_date);

        push @errors, "Expiry date must be set after Start date." if ($start_date && $end_date && $start_date->is_after($end_date));
    } catch {
        push @errors, "Start/Expiry date must be in the following format: YYYY-MM-DD";
    }

    # any more complex validation should go here..
    push @errors, "MINUMUM DEPOSIT is only for GET_X_WHEN_DEPOSIT_Y promotions"
        if $input{min_deposit} && $input{promo_code_type} ne 'GET_X_WHEN_DEPOSIT_Y';
    push @errors, "MINUMUM PAYOUT is only for GET_X_OF_DEPOSITS promotions"
        if $input{min_amount} && $input{promo_code_type} ne 'GET_X_OF_DEPOSITS';
    push @errors, "MAXIMUM PAYOUT is only for GET_X_OF_DEPOSITS promotions"
        if $input{max_amount} && $input{promo_code_type} ne 'GET_X_OF_DEPOSITS';
    if (defined $input{amount} and looks_like_number($input{amount})) {
        if ($input{promo_code_type} eq 'GET_X_OF_DEPOSITS') {
            push @errors, "Amount must be a percentage between 1 and 100" if ($input{amount} < 1 or $input{amount} > 100);
        } else {
            push @errors, "Amount must be a number between 0 and 999" if ($input{amount} < 0 or $input{amount} > 999);
        }
    }
    push @errors, "TURNOVER TYPE cannot be specified for FREE_BET promotions"
        if $input{turnover_type} && $input{promo_code_type} eq 'FREE_BET';
    push @errors, "TURNOVER TYPE must be specified for deposit promotions"
        if !$input{turnover_type} && $input{promo_code_type} ne 'FREE_BET';
    push @errors, "PAYMENT METHOD cannot be specified for FREE_BET promotions"
        if $input{payment_processor} && $input{promo_code_type} eq 'FREE_BET';
    push @errors, "PAYMENT METHOD must be specified for deposit promotions"
        if !$input{payment_processor} && $input{promo_code_type} ne 'FREE_BET';
    push @errors, "Promocode can only have: letters, underscore, minus and dot" unless is_valid_promocode(\%input);

    return @errors;
}

1;

