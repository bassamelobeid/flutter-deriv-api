#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long qw(GetOptions);
Getopt::Long::Configure qw(gnu_getopt);

# parse command line options
my ($path, $dbname, $port);

GetOptions(
    'path|p=s'    => \$path,
    'dbname|d=s' => \$dbname,
    'port|p=s' => \$port
) or die 'Usage $0 --path <path> --dbname <dbname> --port <port>';

my $has_dependent_constraint = _extract_dependent_constraint();

$/ = ';';
while (<STDIN>) {
    my $line = $_;
    if ($line =~ /CREATE TABLE "(\w+)"."(\w+)"/) {
        if (my $params = $has_dependent_constraint->{"$1.$2"}){
            $line = _get_dummy_func_def($params->{function_name}, $params->{function_arguments}, $params->{function_type}) . $line;
        }
        _write("tables", $1, $2, $line);
    } elsif ($line =~ /CREATE TYPE "(\w+)"."(\w+)"/) {
        _write("types", $1, $2, $line);
    } elsif ($line =~ /CREATE SEQUENCE "(\w+)"."(\w+)"/) {
        _write("sequences", $1, $2, $line);
    } elsif ($line =~ /CREATE SCHEMA "(\w+)";/) {
        _write("utilities", "all", "schemas", $line, 1);
    } elsif ($line =~ /CREATE(?: UNIQUE)? INDEX.*"(\w+)" ON "(\w+)"/) {
        _write("indices", $2, $1, $line); # Here Index name is the first match and the second match is the schema name
    } elsif ($line =~ /ALTER TABLE .* "(\w+)"."(\w+)"\n.*ADD CONSTRAINT.*PRIMARY KEY/) {
        _write("tables", $1, $2, $line, 1);
    } elsif ($line =~ /ALTER TABLE .*"(\w+)"."(\w+)".*CLUSTER ON/) {
        _write("tables", $1, $2, $line, 1);
    } elsif ($line =~ /ALTER TABLE .* "(\w+)"."(\w+)"\n.*ADD CONSTRAINT.*FOREIGN KEY/) { # pg_dump dump the constraint with a newline in the middle
        _write("fk_constraints", $1, $2, $line, 1);
    } elsif ($line =~ /ALTER TABLE .*"(\w+)"."(\w+)"\n.*ADD CONSTRAINT/) {
        _write("constraints", $1, $2, $line, 1);
    } elsif ($line =~ /CREATE FUNCTION "(\w+)"."(\w+)"(?:\w|\s|\W)+AS(.*\$)(?:\w|\s|\W)?/) {
        my ($schema, $function_name, $end_pattern) = ($1, $2, $3);
        my $function_def_text = `sudo -u postgres psql --dbname $dbname --port $port -A -F --no-align --pset="tuples_only=on" << 'EOF'
           SELECT string_agg(pg_get_functiondef(f.oid), e';\n') AS def
           FROM (SELECT oid FROM pg_proc
           WHERE proname = '$function_name' AND pronamespace = '$schema'::regnamespace) AS f;
EOF`;
        _write("functions", $schema, $function_name, $function_def_text);
        #skip sub def lines
        while (my $next_line = <STDIN>) {
            last if $next_line =~ /ALTER FUNCTION/;
            $line .= $next_line;
        }
    } elsif ($line =~ /GRANT/ or $line =~ /REVOKE/) {
         _write("utilities", "all", "grants", $line, 1);
    } elsif ($line =~ /CREATE EXTENSION/) {
        _write("utilities", "all", "extensions", $line, 1);
    } elsif ($line =~ /CREATE VIEW "(\w+)"."(\w+)"/) {
        _write("views", $1, $2, $line);
    } elsif ($line =~ /CREATE SERVER/) {
        _write("utilities", "all", "servers", $line, 1);
    } elsif ($line =~ /CREATE FOREIGN TABLE "(\w+)"."(\w+)"/) {
        _write("foreign_tables", $1, $2, $line);
    } elsif ($line =~ /CREATE(?: CONSTRAINT)? TRIGGER "\w+" .* ON "(\w+)"."(\w+)"/) {
        _write("triggers", $1, $2, $line, 1);
    } elsif ($line =~ /COMMENT/) {
        unless ($line =~ /[\w|\s|\W|\n]*';/) {
            while (my $next_line = <STDIN>) {
                $line .= $next_line;
                last if $next_line =~ /[\w|\s|\W|\n]*';/;
            }
        }
        _write("utilities", "all", "comments", $line, 1);
    } elsif ($line =~ /CREATE AGGREGATE "(\w+)"."(\w+)"/) {
        _write("aggregates", $1, $2, $line, 1);
    } elsif ($line =~ /OWNER TO/ or $line =~ /OWNED BY/) {
        _write("utilities", "all", "ownerships", $line, 1);
    } elsif ($line =~ /CREATE USER MAPPING/) {
        _write("utilities", "all", "mappings", $line, 1);
    } elsif ($line =~ /SET DEFAULT/) {
        _write("utilities", "all", "defaults", $line, 1);
    } elsif ($line =~ /CREATE EVENT TRIGGER/) {
        _write("utilities", "all", "events", $line, 1);
    } elsif ($line =~ /CREATE RULE/) {
        _write("utilities", "all", "rules", $line, 1);
    } elsif ($line =~ /SET/ or $line =~ /SELECT/) {
        # DO NOTHING
    } else {
        warn $line;
    }

}

sub _extract_dependent_constraint {

    my $result =  `sudo -u postgres psql --dbname $dbname --port $port -F ! --no-align --pset="footer=off" << 'EOF'
          SELECT c.conname::information_schema.sql_identifier AS constraint_name,
              c.conrelid::regclass AS constraint_table,
              p.oid::regproc AS function_name,
              p.prorettype::regtype AS function_type,
              pg_get_function_arguments(p.oid::regproc) AS function_arguments
          FROM pg_namespace nc,
              pg_constraint c,
              pg_depend d,
              pg_proc p,
              pg_namespace np
          WHERE nc.oid = c.connamespace AND c.contype = 'c'::"char"
              AND c.oid = d.objid AND d.classid = 'pg_constraint'::regclass::oid
              AND d.refobjid = p.oid AND d.refclassid = 'pg_proc'::regclass::oid
              AND p.pronamespace = np.oid;
EOF`;

    my @lines = split /\n/, $result;
    # shift the headers
    my @headers = _get_tokenize_values(shift @lines);
    # no result from query, therefore does not have any dependent constraint
    return {} unless @lines;

    my $constraints = {};
    foreach my $line (@lines) {
        my @tokens = _get_tokenize_values($line);
        my %c = map { $headers[$_] => $tokens[$_] } (0 .. $#headers);
        $constraints->{$c{constraint_table}} = \%c;
    }

    return $constraints;
}

sub _get_tokenize_values {
    my @tokens = split /!/, shift;
    map { $_ =~ s/^\s+|\s+$//g } @tokens;
    return @tokens;
}

sub _write {
    my ($object_type, $schema_name, $object_name, $definition, $append) = @_;
    # path will always looks like `/home/git/regentmarkets/bom-postgres-*/schema`

    my $dir_path = "$path/schema/$object_type/$schema_name";
    my $file_path = "$dir_path/$object_name.sql";

    `mkdir -p -v $dir_path && touch $file_path`;

    $definition =~ s/^\n//;
    $definition .= "\n\n";

    my $fh;
    $append ? open($fh, '>>:encoding(UTF-8)', $file_path) : open($fh, '>:encoding(UTF-8)', $file_path);
    print $fh $definition;

    return;
}

sub _get_dummy_func_def {
    my ($name, $args, $return_type) = @_;
    return "\
CREATE FUNCTION $name($args)
RETURNS $return_type AS \$\$
BEGIN
 -- dummy
END;
\$\$ LANGUAGE plpgsql;\n";
}
