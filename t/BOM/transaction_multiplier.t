#!/etc/rmg/bin/perl

use strict;
use warnings;
use Test::MockTime qw/:all/;
use Test::MockModule;
use Test::More;
use Test::Exception;
use Test::Warnings;

use BOM::Test::Data::Utility::UnitTestDatabase qw(:init);
use BOM::Test::Data::Utility::FeedTestDatabase qw(:init);
use BOM::Test::Data::Utility::UnitTestMarketData qw(:init);
use BOM::Test::Data::Utility::UnitTestRedis qw(initialize_realtime_ticks_db);
use BOM::Test::Helper::Client qw(top_up create_client);

use Guard;
use Crypt::NamedKeys;
use Date::Utility;
use List::Util qw(any);

use BOM::User::Client;
use BOM::User::Password;
use BOM::User::Utility;
use BOM::User;
use BOM::Config::Runtime;

use BOM::Transaction;
use BOM::Transaction::ContractUpdate;
use BOM::Transaction::Validation;
use BOM::Product::ContractFactory qw( produce_contract );
use BOM::Platform::Client::IDAuthentication;

use BOM::MarketData qw(create_underlying);
use BOM::MarketData::Types;

my $password = 'jskjd8292922';
my $email    = 'test' . rand(999) . '@binary.com';
my $hash_pwd = BOM::User::Password::hashpw($password);

my $user = BOM::User->create(
    email    => $email,
    password => $hash_pwd
);

Crypt::NamedKeys::keyfile '/etc/rmg/aes_keys.yml';

my $mock_validation = Test::MockModule->new('BOM::Transaction::Validation');

$mock_validation->mock(validate_tnc => sub { note "mocked Transaction::Validation->validate_tnc returning nothing"; undef });

my $underlying = create_underlying('R_100');
my $now        = Date::Utility->new;
BOM::Test::Data::Utility::UnitTestMarketData::create_doc('currency', {symbol => 'USD'});
BOM::Test::Data::Utility::UnitTestMarketData::create_doc(
    'index',
    {
        symbol => 'R_100',
        date   => $now,
    });
BOM::Test::Data::Utility::UnitTestMarketData::create_doc(
    'volsurface_delta',
    {
        symbol        => $_,
        recorded_date => $now
    }) for qw(frxUSDJPY frxGBPPLN);

my $current_tick = BOM::Test::Data::Utility::FeedTestDatabase::create_tick({
    underlying => $underlying->symbol,
    epoch      => $now->epoch,
    quote      => 100,
});

my $mocked_u = Test::MockModule->new('Quant::Framework::Underlying');
$mocked_u->mock('spot_tick', sub { return $current_tick });
initialize_realtime_ticks_db();

sub db {
    return BOM::Database::ClientDB->new({
            broker_code => 'VRTC',
        })->db;
}

sub get_transaction_from_db {
    my $bet_class = shift;
    my $txnid     = shift;

    my $stmt = <<"SQL";
SELECT t.*, b.*, c.*, v1.*, v2.*, t2.*
  FROM transaction.transaction t
  LEFT JOIN bet.financial_market_bet b ON t.financial_market_bet_id=b.id
  LEFT JOIN bet.${bet_class} c ON b.id=c.financial_market_bet_id
  LEFT JOIN data_collection.quants_bet_variables v1 ON t.id=v1.transaction_id
  LEFT JOIN data_collection.quants_bet_variables v2 ON b.id=v2.financial_market_bet_id AND v2.transaction_id<>t.id
  LEFT JOIN transaction.transaction t2 ON t2.financial_market_bet_id=t.financial_market_bet_id AND t2.id<>t.id
 WHERE t.id=\$1
SQL

    my $db = db;
    $stmt = $db->dbh->prepare($stmt);
    $stmt->execute($txnid);

    my $res = $stmt->fetchrow_arrayref;
    $stmt->finish;

    my @txn_col  = BOM::Database::AutoGenerated::Rose::Transaction->meta->columns;
    my @fmb_col  = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->columns;
    my @chld_col = BOM::Database::AutoGenerated::Rose::FinancialMarketBet->meta->{relationships}->{$bet_class}->class->meta->columns;
    my @qv_col   = BOM::Database::AutoGenerated::Rose::QuantsBetVariable->meta->columns;

    BAIL_OUT "DB structure does not match Rose classes"
        unless 2 * @txn_col + @fmb_col + @chld_col + 2 * @qv_col == @$res;

    my %txn;
    @txn{@txn_col} = splice @$res, 0, 0 + @txn_col;

    my %fmb;
    @fmb{@fmb_col} = splice @$res, 0, 0 + @fmb_col;

    my %chld;
    @chld{@chld_col} = splice @$res, 0, 0 + @chld_col;

    my %qv1;
    @qv1{@qv_col} = splice @$res, 0, 0 + @qv_col;

    my %qv2;
    @qv2{@qv_col} = splice @$res, 0, 0 + @qv_col;

    my %t2;
    @t2{@txn_col} = splice @$res, 0, 0 + @txn_col;

    return \%txn, \%fmb, \%chld, \%qv1, \%qv2, \%t2;
}

my $cl;
my $acc_usd;
my $acc_aud;

####################################################################
# real tests begin here
####################################################################

lives_ok {
    $cl = create_client('VRTC');

    #make sure client can trade
    ok(!BOM::Transaction::Validation->new({clients => [$cl]})->check_trade_status($cl),      "client can trade: check_trade_status");
    ok(!BOM::Transaction::Validation->new({clients => [$cl]})->_validate_client_status($cl), "client can trade: _validate_client_status");

    top_up $cl, 'USD', 5000;

    isnt + ($acc_usd = $cl->account), 'USD', 'got USD account';

    my $bal;
    is + ($bal = $acc_usd->balance + 0), 5000, 'USD balance is 5000 got: ' . $bal;
}
'client created and funded';

my ($trx, $fmb, $chld, $qv1, $qv2);

subtest 'buy MULTUP', sub {
    lives_ok {
        my $contract = produce_contract({
            underlying   => $underlying,
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
        });

        my $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        my $error = $txn->buy;
        ok !$error, 'buy without error';

        subtest 'transaction report', sub {
            note $txn->report;
            my $report = $txn->report;
            like $report, qr/\ATransaction Report:$/m,                                                    'header';
            like $report, qr/^\s*Client: \Q${\$cl}\E$/m,                                                  'client';
            like $report, qr/^\s*Contract: \Q${\$contract->code}\E$/m,                                    'contract';
            like $report, qr/^\s*Price: \Q${\$txn->price}\E$/m,                                           'price';
            like $report, qr/^\s*Payout: \Q${\$txn->payout}\E$/m,                                         'payout';
            like $report, qr/^\s*Amount Type: \Q${\$txn->amount_type}\E$/m,                               'amount_type';
            like $report, qr/^\s*Comment: \Q${\$txn->comment->[0]}\E$/m,                                  'comment';
            like $report, qr/^\s*Staff: \Q${\$txn->staff}\E$/m,                                           'staff';
            like $report, qr/^\s*Transaction Parameters: \$VAR1 = \{$/m,                                  'transaction parameters';
            like $report, qr/^\s*Transaction ID: \Q${\$txn->transaction_id}\E$/m,                         'transaction id';
            like $report, qr/^\s*Purchase Date: \Q${\$txn->purchase_date->datetime_yyyymmdd_hhmmss}\E$/m, 'purchase date';
        };
        ($trx, $fmb, $chld, $qv1, $qv2) = get_transaction_from_db multiplier => $txn->transaction_id;

        # note explain $trx;

        subtest 'transaction row', sub {
            plan tests => 12;
            cmp_ok $trx->{id}, '>', 0, 'id';
            is $trx->{account_id}, $acc_usd->id, 'account_id';
            is $trx->{action_type}, 'buy', 'action_type';
            is $trx->{amount} + 0, -100, 'amount';
            is $trx->{balance_after} + 0, 5000 - 100, 'balance_after';
            is $trx->{financial_market_bet_id}, $fmb->{id}, 'financial_market_bet_id';
            is $trx->{payment_id},    undef,                  'payment_id';
            is $trx->{referrer_type}, 'financial_market_bet', 'referrer_type';
            is $trx->{remark},        undef,                  'remark';
            is $trx->{staff_loginid}, $cl->loginid, 'staff_loginid';
            is $trx->{source}, 19, 'source';
            cmp_ok +Date::Utility->new($trx->{transaction_time})->epoch, '<=', time, 'transaction_time';
        };

        # note explain $fmb;

        subtest 'fmb row', sub {
            plan tests => 19;
            cmp_ok $fmb->{id}, '>', 0, 'id';
            is $fmb->{account_id}, $acc_usd->id, 'account_id';
            is $fmb->{bet_class}, 'multiplier', 'bet_class';
            is $fmb->{bet_type},  'MULTUP',     'bet_type';
            is $fmb->{buy_price} + 0, 100, 'buy_price';
            is !$fmb->{expiry_daily}, !$contract->expiry_daily, 'expiry_daily';
            cmp_ok +Date::Utility->new($fmb->{expiry_time})->epoch, '>', time, 'expiry_time';
            is $fmb->{fixed_expiry}, undef, 'fixed_expiry';
            is !$fmb->{is_expired}, !0, 'is_expired';
            is !$fmb->{is_sold},    !0, 'is_sold';
            cmp_ok +Date::Utility->new($fmb->{purchase_time})->epoch, '<=', time, 'purchase_time';
            like $fmb->{remark},   qr/\btrade\[100\.00000\]/, 'remark';
            is $fmb->{sell_price}, undef,                     'sell_price';
            is $fmb->{sell_time},  undef,                     'sell_time';
            cmp_ok +Date::Utility->new($fmb->{settlement_time})->epoch, '>', time, 'settlement_time';
            like $fmb->{short_code}, qr/MULTUP/, 'short_code';
            cmp_ok +Date::Utility->new($fmb->{start_time})->epoch, '<=', time, 'start_time';
            is $fmb->{tick_count},        undef,   'tick_count';
            is $fmb->{underlying_symbol}, 'R_100', 'underlying_symbol';
        };

        # note explain $chld;

        subtest 'chld row', sub {
            is $chld->{financial_market_bet_id}, $fmb->{id}, 'financial_market_bet_id';
            is $chld->{'multiplier'}, 10, 'multiplier is 10';
            is $chld->{'basis_spot'} + 0, 100, 'basis_spot is 100';
            is $chld->{'stop_loss_order_amount'}, undef, 'stop_loss_order_amount is undef';
            is $chld->{'stop_loss_basis_spot'},   undef, 'stop_loss_basis_spot is undef';
            is $chld->{'stop_out_order_amount'} + 0, -100, 'stop_out_order_amount is -100';
            cmp_ok $chld->{'stop_out_order_date'}, "eq", $fmb->{start_time}, 'stop_out_order_date is correctly set';
            is $chld->{'take_profit_order_amount'}, undef, 'take_profit_order_amount is undef';
            is $chld->{'take_profit_order_date'},   undef, 'take_profit_order_date is undef';
        };

    }
    'survived';
};

subtest 'buy MULTUP with take profit', sub {
    lives_ok {
        my $mock = Test::MockModule->new('Quant::Framework::Underlying');
        $mock->mock('spot_tick' => sub { return $current_tick });
        my $contract = produce_contract({
            underlying   => $underlying,
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
            limit_order  => {take_profit => 5},
        });

        my $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        my $error = $txn->buy;
        ok !$error, 'buy without error';

        subtest 'transaction report', sub {
            plan tests => 11;
            note $txn->report;
            my $report = $txn->report;
            like $report, qr/\ATransaction Report:$/m,                                                    'header';
            like $report, qr/^\s*Client: \Q${\$cl}\E$/m,                                                  'client';
            like $report, qr/^\s*Contract: \Q${\$contract->code}\E$/m,                                    'contract';
            like $report, qr/^\s*Price: \Q${\$txn->price}\E$/m,                                           'price';
            like $report, qr/^\s*Payout: \Q${\$txn->payout}\E$/m,                                         'payout';
            like $report, qr/^\s*Amount Type: \Q${\$txn->amount_type}\E$/m,                               'amount_type';
            like $report, qr/^\s*Comment: \Q${\$txn->comment->[0]}\E$/m,                                  'comment';
            like $report, qr/^\s*Staff: \Q${\$txn->staff}\E$/m,                                           'staff';
            like $report, qr/^\s*Transaction Parameters: \$VAR1 = \{$/m,                                  'transaction parameters';
            like $report, qr/^\s*Transaction ID: \Q${\$txn->transaction_id}\E$/m,                         'transaction id';
            like $report, qr/^\s*Purchase Date: \Q${\$txn->purchase_date->datetime_yyyymmdd_hhmmss}\E$/m, 'purchase date';
        };
        ($trx, $fmb, $chld, $qv1, $qv2) = get_transaction_from_db multiplier => $txn->transaction_id;

        # note explain $trx;

        subtest 'transaction row', sub {
            plan tests => 12;
            cmp_ok $trx->{id}, '>', 0, 'id';
            is $trx->{account_id}, $acc_usd->id, 'account_id';
            is $trx->{action_type}, 'buy', 'action_type';
            is $trx->{amount} + 0, -100, 'amount';
            is $trx->{balance_after} + 0, 4900 - 100, 'balance_after';
            is $trx->{financial_market_bet_id}, $fmb->{id}, 'financial_market_bet_id';
            is $trx->{payment_id},    undef,                  'payment_id';
            is $trx->{referrer_type}, 'financial_market_bet', 'referrer_type';
            is $trx->{remark},        undef,                  'remark';
            is $trx->{staff_loginid}, $cl->loginid, 'staff_loginid';
            is $trx->{source}, 19, 'source';
            cmp_ok +Date::Utility->new($trx->{transaction_time})->epoch, '<=', time, 'transaction_time';
        };

        # note explain $fmb;

        subtest 'fmb row', sub {
            plan tests => 19;
            cmp_ok $fmb->{id}, '>', 0, 'id';
            is $fmb->{account_id}, $acc_usd->id, 'account_id';
            is $fmb->{bet_class}, 'multiplier', 'bet_class';
            is $fmb->{bet_type},  'MULTUP',     'bet_type';
            is $fmb->{buy_price} + 0, 100, 'buy_price';
            is !$fmb->{expiry_daily}, !$contract->expiry_daily, 'expiry_daily';
            cmp_ok +Date::Utility->new($fmb->{expiry_time})->epoch, '>', time, 'expiry_time';
            is $fmb->{fixed_expiry}, undef, 'fixed_expiry';
            is !$fmb->{is_expired}, !0, 'is_expired';
            is !$fmb->{is_sold},    !0, 'is_sold';
            cmp_ok +Date::Utility->new($fmb->{purchase_time})->epoch, '<=', time, 'purchase_time';
            like $fmb->{remark},   qr/\btrade\[100\.00000\]/, 'remark';
            is $fmb->{sell_price}, undef,                     'sell_price';
            is $fmb->{sell_time},  undef,                     'sell_time';
            cmp_ok +Date::Utility->new($fmb->{settlement_time})->epoch, '>', time, 'settlement_time';
            like $fmb->{short_code}, qr/MULTUP/, 'short_code';
            cmp_ok +Date::Utility->new($fmb->{start_time})->epoch, '<=', time, 'start_time';
            is $fmb->{tick_count},        undef,   'tick_count';
            is $fmb->{underlying_symbol}, 'R_100', 'underlying_symbol';
        };

        # note explain $chld;

        subtest 'chld row', sub {
            is $chld->{financial_market_bet_id}, $fmb->{id}, 'financial_market_bet_id';
            is $chld->{'multiplier'}, 10, 'multiplier is 10';
            is $chld->{'basis_spot'} + 0, 100, 'basis_spot is 100';
            is $chld->{'stop_loss_order_amount'}, undef, 'stop_loss_order_amount is undef';
            is $chld->{'stop_loss_order_date'},   undef, 'stop_loss_order_date is undef';
            is $chld->{'stop_out_order_amount'} + 0, -100, 'stop_out_order_amount is -100';
            cmp_ok $chld->{'stop_out_order_date'}, "eq", $fmb->{start_time}, 'stop_out_order_date is correctly set';
            is $chld->{'take_profit_order_amount'}, 5, 'take_profit_order_amount is 5';
            cmp_ok $chld->{'take_profit_order_date'}, "eq", $fmb->{start_time}, 'take_profit_order_date is correctly set';
        };

    }
    'survived';
};

my $contract_start_time;
subtest 'buy MULTUP with stop loss', sub {
    lives_ok {
        my $mock = Test::MockModule->new('Quant::Framework::Underlying');
        $mock->mock('spot_tick' => sub { return $current_tick });
        my $contract = produce_contract({
            underlying   => $underlying,
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
            limit_order  => {stop_loss => 5},
        });

        my $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        my $error = $txn->buy;
        ok !$error, 'buy without error';

        subtest 'transaction report', sub {
            plan tests => 11;
            note $txn->report;
            my $report = $txn->report;
            like $report, qr/\ATransaction Report:$/m,                                                    'header';
            like $report, qr/^\s*Client: \Q${\$cl}\E$/m,                                                  'client';
            like $report, qr/^\s*Contract: \Q${\$contract->code}\E$/m,                                    'contract';
            like $report, qr/^\s*Price: \Q${\$txn->price}\E$/m,                                           'price';
            like $report, qr/^\s*Payout: \Q${\$txn->payout}\E$/m,                                         'payout';
            like $report, qr/^\s*Amount Type: \Q${\$txn->amount_type}\E$/m,                               'amount_type';
            like $report, qr/^\s*Comment: \Q${\$txn->comment->[0]}\E$/m,                                  'comment';
            like $report, qr/^\s*Staff: \Q${\$txn->staff}\E$/m,                                           'staff';
            like $report, qr/^\s*Transaction Parameters: \$VAR1 = \{$/m,                                  'transaction parameters';
            like $report, qr/^\s*Transaction ID: \Q${\$txn->transaction_id}\E$/m,                         'transaction id';
            like $report, qr/^\s*Purchase Date: \Q${\$txn->purchase_date->datetime_yyyymmdd_hhmmss}\E$/m, 'purchase date';
        };
        ($trx, $fmb, $chld, $qv1, $qv2) = get_transaction_from_db multiplier => $txn->transaction_id;

        # note explain $trx;

        subtest 'transaction row', sub {
            plan tests => 12;
            cmp_ok $trx->{id}, '>', 0, 'id';
            is $trx->{account_id}, $acc_usd->id, 'account_id';
            is $trx->{action_type}, 'buy', 'action_type';
            is $trx->{amount} + 0, -100, 'amount';
            is $trx->{balance_after} + 0, 4800 - 100, 'balance_after';
            is $trx->{financial_market_bet_id}, $fmb->{id}, 'financial_market_bet_id';
            is $trx->{payment_id},    undef,                  'payment_id';
            is $trx->{referrer_type}, 'financial_market_bet', 'referrer_type';
            is $trx->{remark},        undef,                  'remark';
            is $trx->{staff_loginid}, $cl->loginid, 'staff_loginid';
            is $trx->{source}, 19, 'source';
            cmp_ok +Date::Utility->new($trx->{transaction_time})->epoch, '<=', time, 'transaction_time';
        };

        # note explain $fmb;

        subtest 'fmb row', sub {
            plan tests => 19;
            cmp_ok $fmb->{id}, '>', 0, 'id';
            is $fmb->{account_id}, $acc_usd->id, 'account_id';
            is $fmb->{bet_class}, 'multiplier', 'bet_class';
            is $fmb->{bet_type},  'MULTUP',     'bet_type';
            is $fmb->{buy_price} + 0, 100, 'buy_price';
            is !$fmb->{expiry_daily}, !$contract->expiry_daily, 'expiry_daily';
            cmp_ok +Date::Utility->new($fmb->{expiry_time})->epoch, '>', time, 'expiry_time';
            is $fmb->{fixed_expiry}, undef, 'fixed_expiry';
            is !$fmb->{is_expired}, !0, 'is_expired';
            is !$fmb->{is_sold},    !0, 'is_sold';
            cmp_ok +Date::Utility->new($fmb->{purchase_time})->epoch, '<=', time, 'purchase_time';
            like $fmb->{remark},   qr/\btrade\[100\.00000\]/, 'remark';
            is $fmb->{sell_price}, undef,                     'sell_price';
            is $fmb->{sell_time},  undef,                     'sell_time';
            cmp_ok +Date::Utility->new($fmb->{settlement_time})->epoch, '>', time, 'settlement_time';
            like $fmb->{short_code}, qr/MULTUP/, 'short_code';
            cmp_ok +Date::Utility->new($fmb->{start_time})->epoch, '<=', time, 'start_time';
            is $fmb->{tick_count},        undef,   'tick_count';
            is $fmb->{underlying_symbol}, 'R_100', 'underlying_symbol';
        };

        # note explain $chld;
        subtest 'chld row', sub {
            is $chld->{financial_market_bet_id}, $fmb->{id}, 'financial_market_bet_id';
            is $chld->{'multiplier'}, 10, 'multiplier is 10';
            is $chld->{'basis_spot'} + 0, 100, 'basis_spot is 100';
            is $chld->{'stop_loss_order_amount'}, -5, 'stop_loss_order_amount is -5';
            cmp_ok $chld->{'stop_loss_order_date'}, "eq", $fmb->{start_time}, 'stop_loss_order_date is correctly set';
            is $chld->{'stop_out_order_amount'} + 0, -100, 'stop_out_order_amount is -100';
            cmp_ok $chld->{'stop_out_order_date'}, "eq", $fmb->{start_time}, 'stop_out_order_date is correctly set';
            is $chld->{'take_profit_order_amount'}, undef, 'take_profit_order_amount is undef';
            is $chld->{'take_profit_order_date'},   undef, 'take_profit_order_date is undef';
        };
        $contract_start_time = $contract->date_start->epoch;
    }
    'survived';
};

subtest 'sell a bet', sub {
    lives_ok {
        my $contract = produce_contract({
                underlying   => $underlying,
                date_start   => $contract_start_time,
                date_pricing => $contract_start_time + 1,
                bet_type     => 'MULTUP',
                currency     => 'USD',
                multiplier   => 10,
                amount       => 100,
                amount_type  => 'stake',
                current_tick => $current_tick,
                limit_order  => {
                    stop_out => {
                        order_type   => 'stop_out',
                        order_amount => -100,
                        order_date   => $contract_start_time,
                        basis_spot   => 100,
                    },
                    stop_loss => {
                        order_type   => 'stop_loss',
                        order_amount => -5,
                        order_date   => $contract_start_time,
                        basis_spot   => 100,
                    }}});
        my $txn;
        #note 'bid price: ' . $contract->bid_price;
        my $error = do {
            my $mocked           = Test::MockModule->new('BOM::Transaction');
            my $mocked_validator = Test::MockModule->new('BOM::Transaction::Validation');
            $mocked_validator->mock('_validate_trade_pricing_adjustment', sub { });
            $mocked->mock('price', sub { $contract->bid_price });
            $txn = BOM::Transaction->new({
                purchase_date => $contract->date_start,
                client        => $cl,
                contract      => $contract,
                contract_id   => $fmb->{id},
                price         => $contract->bid_price,
                source        => 23,
            });
            $txn->sell;
        };
        is $error, undef, 'no error';

        ($trx, $fmb, $chld, $qv1, $qv2) = get_transaction_from_db multiplier => $txn->transaction_id;

        # note explain $trx;

        subtest 'transaction row', sub {
            cmp_ok $trx->{id}, '>', 0, 'id';
            is $trx->{account_id}, $acc_usd->id, 'account_id';
            is $trx->{action_type}, 'sell', 'action_type';
            is $trx->{amount} + 0, $contract->bid_price + 0, 'amount';
            is $trx->{balance_after} + 0, 4799.5, 'balance_after';
            is $trx->{financial_market_bet_id}, $fmb->{id}, 'financial_market_bet_id';
            is $trx->{payment_id},    undef,                  'payment_id';
            is $trx->{quantity},      1,                      'quantity';
            is $trx->{referrer_type}, 'financial_market_bet', 'referrer_type';
            is $trx->{remark},        undef,                  'remark';
            is $trx->{staff_loginid}, $cl->loginid, 'staff_loginid';
            is $trx->{source}, 23, 'source';
            cmp_ok +Date::Utility->new($trx->{transaction_time})->epoch, '<=', time, 'transaction_time';
        };

        # note explain $fmb;

        subtest 'fmb row', sub {
            cmp_ok $fmb->{id}, '>', 0, 'id';
            is $fmb->{account_id}, $acc_usd->id, 'account_id';
            is $fmb->{bet_class}, 'multiplier', 'bet_class';
            is $fmb->{bet_type},  'MULTUP',     'bet_type';
            is $fmb->{buy_price} + 0, 100, 'buy_price';
            ok $fmb->{expiry_daily}, 'expiry_daily';
            is $fmb->{fixed_expiry}, undef, 'fixed_expiry';
            is $fmb->{is_expired},   0, 'is_expired';
            ok $fmb->{is_sold},      'is_sold';
            is $fmb->{sell_price} + 0, $contract->bid_price + 0, 'sell_price';
            cmp_ok +Date::Utility->new($fmb->{sell_time})->epoch, '<=', $contract->date_pricing->epoch, 'sell_time';
            cmp_ok +Date::Utility->new($fmb->{settlement_time})->epoch, '>', time, 'settlement_time';
            like $fmb->{short_code}, qr/MULTUP/, 'short_code';
            cmp_ok +Date::Utility->new($fmb->{start_time})->epoch, '<=', time, 'start_time';
            is $fmb->{tick_count},        undef,   'tick_count';
            is $fmb->{underlying_symbol}, 'R_100', 'underlying_symbol';
        };

        is $txn->contract_id,    $fmb->{id},            'txn->contract_id';
        is $txn->transaction_id, $trx->{id},            'txn->transaction_id';
        is $txn->balance_after,  $trx->{balance_after}, 'txn->balance_after';
    }
    'survived';
};

subtest 'sell failure due to update' => sub {
    my $contract = produce_contract({
        underlying   => $underlying,
        bet_type     => 'MULTUP',
        currency     => 'USD',
        multiplier   => 10,
        amount       => 100,
        amount_type  => 'stake',
        current_tick => $current_tick,
    });

    my $txn = BOM::Transaction->new({
        client        => $cl,
        contract      => $contract,
        price         => 100,
        amount        => 100,
        amount_type   => 'stake',
        source        => 19,
        purchase_date => $contract->date_start,
    });

    my $error = $txn->buy;
    ok !$error, 'buy without error';

    ($trx, $fmb, $chld, $qv1, $qv2) = get_transaction_from_db multiplier => $txn->transaction_id;
    # create sell transaction object
    my $contract_sell = produce_contract({
            underlying   => $underlying,
            bet_type     => 'MULTUP',
            date_start   => $contract->date_start,
            date_pricing => $contract->date_start->plus_time_interval(1),
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
            limit_order  => {
                stop_out => {
                    order_type   => 'stop_out',
                    order_amount => -100,
                    order_date   => $contract_start_time,
                    basis_spot   => 100,
                }}});
    my $sell_txn = BOM::Transaction->new({
        purchase_date => $contract->date_start,
        client        => $cl,
        contract      => $contract_sell,
        contract_id   => $fmb->{id},
        price         => $contract_sell->bid_price,
        source        => 23,
    });

    # update contract before sell
    my $updater = BOM::Transaction::ContractUpdate->new(
        client        => $cl,
        contract_id   => $fmb->{id},
        update_params => {take_profit => 10},
    );
    ok $updater->is_valid_to_update, 'valid to update';
    $updater->update;
    $error = $sell_txn->sell;
    ok $error, 'sell failed after contract is updated';
    is $error->{-mesg}, 'Contract is updated while attempting to sell', 'error mesg Contract is updated while attempting to sell';
    is $error->{-type}, 'SellFailureDueToUpdate', 'error type SellFailureDueToUpdate';

    subtest 'sell_expired_contract with contract id' => sub {
        # expiring the contract by setting current tick to 101.15 (the value of take profit)
        BOM::Test::Data::Utility::FeedTestDatabase::create_tick({
            underlying => $underlying->symbol,
            epoch      => $now->epoch + 1,
            quote      => 101.15,
        });
        sleep 1;
        my $out = BOM::Transaction::sell_expired_contracts({
                client       => $cl,
                source       => 23,
                contract_ids => [$fmb->{id}]});
        ok $out->{number_of_sold_bets} == 1, 'sold one contract';
    };

    subtest 'sell_expired_contract without contract id' => sub {
        BOM::Test::Data::Utility::FeedTestDatabase::create_tick({
            underlying => $underlying->symbol,
            epoch      => $now->epoch + 2,
            quote      => 0,
        });
        sleep 1;
        my $out = BOM::Transaction::sell_expired_contracts({
            client => $cl,
            source => 23,
        });
        # sold the remaining two contracts
        ok $out->{number_of_sold_bets} == 2, 'sold two contracts';
    };
};

# because the market of forex will be closed after Friday 20:55, we move back 3 days for safe
# if it is on Friday or weekend.
if (any { Date::Utility->new->day_of_week == $_ } (5, 6, 0)) {
    set_relative_time(0 - 3 * 24 * 60 * 60);
}

subtest 'buy multiplier for forex major pair' => sub {
    lives_ok {
        my $contract = produce_contract({
            underlying   => 'frxAUDJPY',
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
        });

        my $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        my $error = $txn->buy;
        ok $error, 'buy failed with error';
        is $error->{-mesg}, 'multiplier out of range', 'message - multiplier out of range';
        is $error->{-message_to_client}, 'Multiplier is not in acceptable range. Accepts 20,30,50,100,200.',
            'message to client - Multiplier is not in acceptable range. Accepts 100,200,300,500,1000.';

        $contract = produce_contract({
            underlying   => 'frxAUDJPY',
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 100,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
        });

        $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        ok !$txn->buy;
    }
    'can buy frxAUDJPY';
};

Test::Warnings::allow_warnings(1);
subtest 'buy multiplier with unsupported underlying' => sub {
    lives_ok {
        my $contract = produce_contract({
            underlying   => 'frxGBPPLN',
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
        });

        my $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        my $error = $txn->buy;
        ok $error, 'buy failed with error';
        is $error->{-mesg}, 'multiplier commission not defined for frxGBPPLN', 'message is multiplier commission not defined for frxGBPPLN';
        is $error->{-message_to_client}, 'Trading is not offered for this asset.', 'message to client Trading is not offered for this asset.';
    };

    restore_time();
};
Test::Warnings::allow_warnings(0);

subtest 'buy deal cancellation when it is disabled' => sub {
    lives_ok {
        my $contract = produce_contract({
            underlying   => 'R_100',
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
            cancellation => '1h',
        });

        my $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        my $error = $txn->buy;
        ok !$error, 'buy successful';

        note 'suspend deal cancellation';
        BOM::Config::Runtime->instance->app_config->quants->suspend_deal_cancellation->synthetic_index(1);

        $contract = produce_contract({
            underlying   => 'R_100',
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
            cancellation => '1h',
        });

        $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        $error = $txn->buy;
        is $error->{-mesg}, 'deal cancellation suspended', 'message is deal cancellation suspended';
        is $error->{-message_to_client}, 'Deal cancellation is not available at this moment.',
            'message to client is Deal cancellation is not available at this moment.';

        $contract = produce_contract({
            underlying   => 'R_100',
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 10,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
        });

        $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        $error = $txn->buy;
        ok !$error, 'can still buy multiplier without deal cancellation';

        note 'reset deal cancellation';
        BOM::Config::Runtime->instance->app_config->quants->suspend_deal_cancellation->synthetic_index(0);
    };
};

subtest 'buy multiplier on FX with VRTC' => sub {
    if (any { Date::Utility->new->day_of_week == $_ } (5, 6, 0)) {
        set_relative_time(0 - 3 * 24 * 60 * 60);
    }
    lives_ok {
        my $contract = produce_contract({
            underlying   => 'frxAUDJPY',
            bet_type     => 'MULTUP',
            currency     => 'USD',
            multiplier   => 50,
            amount       => 100,
            amount_type  => 'stake',
            current_tick => $current_tick,
        });

        my $txn = BOM::Transaction->new({
            client        => $cl,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        my $error = $txn->buy;
        ok !$error, 'buy without error';
    };

    restore_time();
};

subtest 'buy multiplier on synthetic with CR' => sub {
    my $cr = create_client('CR');
    top_up $cr, 'USD', 5000;

    my $contract = produce_contract({
        underlying   => 'R_100',
        bet_type     => 'MULTUP',
        currency     => 'USD',
        multiplier   => 10,
        amount       => 100,
        amount_type  => 'stake',
        current_tick => $current_tick,
        cancellation => '1h',
    });

    my $txn = BOM::Transaction->new({
        client        => $cr,
        contract      => $contract,
        price         => 100,
        amount        => 100,
        amount_type   => 'stake',
        source        => 19,
        purchase_date => $contract->date_start,
    });

    my $error = $txn->buy;
    ok !$error, 'synthetic buy successful';

    $contract = produce_contract({
        underlying   => 'frxUSDJPY',
        bet_type     => 'MULTUP',
        currency     => 'USD',
        multiplier   => 50,
        amount       => 100,
        amount_type  => 'stake',
        current_tick => $current_tick,
        cancellation => '1h',
    });

    SKIP: {
        # skipping forex test on non-trading day
        skip "weekend on forex", 3, unless $contract->trading_calendar->is_open($contract->underlying->exchange);

        $txn = BOM::Transaction->new({
            client        => $cr,
            contract      => $contract,
            price         => 100,
            amount        => 100,
            amount_type   => 'stake',
            source        => 19,
            purchase_date => $contract->date_start,
        });

        $error = $txn->buy;
        ok !$error, 'major pair buy successful';
    }
};

done_testing();
